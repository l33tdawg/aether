#!/usr/bin/env python3
"""
Exploit Testing Framework for AetherAudit

Comprehensive system for testing generated exploit code against real audited contracts
using Anvil, Foundry, and mainnet forks for realistic validation.
"""

import asyncio
import json
import logging
import os
import shutil
import subprocess
import tempfile
import time
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass, field

from rich.console import Console
from core.database_manager import AetherDatabase
from core.foundry_poc_generator import FoundryPoCGenerator

logger = logging.getLogger(__name__)

@dataclass
class ExploitTestResult:
    """Result of an exploit test attempt."""
    finding_id: str
    contract_name: str
    vulnerability_type: str
    test_compiled: bool
    test_passed: bool
    exploit_deployed: bool
    exploit_executed: bool
    profit_generated: float
    gas_used: int
    execution_time: float
    errors: List[str] = field(default_factory=list)
    test_output: str = ""
    exploit_output: str = ""

@dataclass
class ExploitTestSuite:
    """Complete test suite for a project."""
    project_name: str
    project_path: str
    findings_tested: int
    tests_passed: int
    exploits_successful: int
    total_execution_time: float
    results: List[ExploitTestResult] = field(default_factory=list)

class ExploitTester:
    """Comprehensive exploit testing framework."""

    def __init__(self, db_path: Optional[str] = None):
        self.console = Console()
        self.db = AetherDatabase(db_path)
        self.poc_generator = FoundryPoCGenerator()
        self.anvil_process = None

    def _start_anvil(self, port: int = 8545, fork_url: Optional[str] = None) -> bool:
        """Start Anvil process for testing."""
        try:
            cmd = ['anvil', '--port', str(port)]

            if fork_url:
                cmd.extend(['--fork-url', fork_url])

            # Run in background
            self.anvil_process = subprocess.Popen(
                cmd,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True
            )

            # Wait a moment for Anvil to start
            time.sleep(2)

            # Check if it's running
            if self.anvil_process.poll() is None:
                logger.info(f"Anvil started on port {port}")
                return True
            else:
                logger.error("Failed to start Anvil")
                return False

        except Exception as e:
            logger.error(f"Error starting Anvil: {e}")
            return False

    def _stop_anvil(self):
        """Stop Anvil process."""
        if self.anvil_process:
            self.anvil_process.terminate()
            self.anvil_process.wait()
            logger.info("Anvil stopped")

    def get_project_contracts(self, project_name: str) -> List[Dict[str, Any]]:
        """Get all contracts for a project with their file paths."""
        try:
            # Query database for project and contracts
            cursor = self.db.connection.cursor()

            # Get project info
            cursor.execute("""
                SELECT id, cache_path FROM projects WHERE repo_name = ?
            """, (project_name,))

            project = cursor.fetchone()
            if not project:
                logger.error(f"Project {project_name} not found in database")
                return []

            project_id, cache_path = project

            # Get all contracts for this project
            cursor.execute("""
                SELECT id, file_path, contract_name FROM contracts
                WHERE project_id = ? ORDER BY file_path
            """, (project_id,))

            contracts = []
            for contract in cursor.fetchall():
                contract_id, file_path, contract_name = contract

                # Construct full path to contract
                if cache_path:
                    full_path = Path(cache_path) / file_path
                    contracts.append({
                        'id': contract_id,
                        'file_path': file_path,
                        'contract_name': contract_name,
                        'full_path': str(full_path),
                        'project_path': cache_path
                    })

            logger.info(f"Found {len(contracts)} contracts for project {project_name}")
            return contracts

        except Exception as e:
            logger.error(f"Error getting project contracts: {e}")
            return []

    def get_critical_findings(self, project_name: str) -> List[Dict[str, Any]]:
        """Get critical findings for a project."""
        try:
            cursor = self.db.connection.cursor()

            # Get project ID
            cursor.execute("SELECT id FROM projects WHERE repo_name = ?", (project_name,))
            project = cursor.fetchone()
            if not project:
                return []

            project_id = project[0]

            # Get critical findings
            cursor.execute("""
                SELECT vf.id, vf.vulnerability_type, vf.severity, vf.description,
                       vf.line_number, vf.swc_id, vf.contract_name, c.file_path
                FROM vulnerability_findings vf
                JOIN audit_results ar ON vf.audit_result_id = ar.id
                JOIN contracts c ON ar.contract_name = c.contract_name
                WHERE c.project_id = ? AND vf.severity IN ('critical', 'high')
                ORDER BY vf.severity DESC, vf.confidence DESC
            """, (project_id,))

            findings = []
            for finding in cursor.fetchall():
                finding_id, vuln_type, severity, description, line_num, swc_id, contract_name, file_path = finding
                findings.append({
                    'id': finding_id,
                    'vulnerability_type': vuln_type,
                    'severity': severity,
                    'description': description,
                    'line_number': line_num,
                    'swc_id': swc_id,
                    'contract_name': contract_name,
                    'file_path': file_path
                })

            logger.info(f"Found {len(findings)} critical findings for {project_name}")
            return findings

        except Exception as e:
            logger.error(f"Error getting critical findings: {e}")
            return []

    def setup_test_environment(self, project_name: str, finding: Dict[str, Any]) -> Tuple[str, str, str]:
        """Set up test environment for a specific finding."""
        try:
            # Get project and contract info
            contracts = self.get_project_contracts(project_name)
            contract = next((c for c in contracts if c['contract_name'] == finding['contract_name']), None)

            if not contract:
                raise Exception(f"Contract {finding['contract_name']} not found")

            # Create test directory
            test_dir = f"output/exploit_tests/{project_name}/{finding['contract_name']}_{finding['id']}"
            os.makedirs(test_dir, exist_ok=True)

            # Copy real contract source
            contract_source = Path(contract['full_path']).read_text()

            # Generate POC code
            poc_result = self.poc_generator.generate_poc(finding, contract_source, contract['project_path'])

            if not poc_result:
                raise Exception("Failed to generate POC code")

            # Write files
            contract_file = os.path.join(test_dir, f"{finding['contract_name']}.sol")
            test_file = os.path.join(test_dir, f"{finding['contract_name']}_test.sol")
            exploit_file = os.path.join(test_dir, f"{finding['contract_name']}_exploit.sol")

            with open(contract_file, 'w') as f:
                f.write(contract_source)

            with open(test_file, 'w') as f:
                f.write(poc_result['test_code'])

            with open(exploit_file, 'w') as f:
                f.write(poc_result['exploit_code'])

            logger.info(f"Test environment set up at {test_dir}")
            return test_dir, test_file, exploit_file

        except Exception as e:
            logger.error(f"Error setting up test environment: {e}")
            raise

    async def compile_and_test_exploit(self, test_dir: str, test_file: str, exploit_file: str) -> ExploitTestResult:
        """Compile and test exploit code."""
        start_time = time.time()

        try:
            # Change to test directory
            original_cwd = os.getcwd()
            os.chdir(test_dir)

            # Initialize Foundry project if needed
            if not os.path.exists('foundry.toml'):
                subprocess.run(['forge', 'init', '--no-git'], check=True, capture_output=True)

            # Install dependencies
            subprocess.run(['forge', 'install', 'foundry-rs/forge-std', '--no-git'],
                         check=True, capture_output=True)

            # Compile
            compile_result = subprocess.run(['forge', 'build'],
                                          capture_output=True, text=True, timeout=60)

            compiled = compile_result.returncode == 0

            # Run tests
            test_result = subprocess.run(['forge', 'test', '--fork-url', 'http://localhost:8545'],
                                       capture_output=True, text=True, timeout=120)

            test_passed = test_result.returncode == 0

            execution_time = time.time() - start_time

            # Restore working directory
            os.chdir(original_cwd)

            return ExploitTestResult(
                finding_id="test",
                contract_name="TestContract",
                vulnerability_type="test",
                test_compiled=compiled,
                test_passed=test_passed,
                exploit_deployed=False,
                exploit_executed=False,
                profit_generated=0.0,
                gas_used=0,
                execution_time=execution_time,
                errors=compile_result.stderr.split('\n') if not compiled else test_result.stderr.split('\n'),
                test_output=test_result.stdout,
                exploit_output=""
            )

        except Exception as e:
            os.chdir(original_cwd) if 'original_cwd' in locals() else None
            logger.error(f"Error in compile_and_test_exploit: {e}")
            return ExploitTestResult(
                finding_id="test",
                contract_name="TestContract",
                vulnerability_type="test",
                test_compiled=False,
                test_passed=False,
                exploit_deployed=False,
                exploit_executed=False,
                profit_generated=0.0,
                gas_used=0,
                execution_time=time.time() - start_time,
                errors=[str(e)]
            )

    async def run_comprehensive_exploit_tests(self, project_name: str, fork_url: Optional[str] = None) -> ExploitTestSuite:
        """Run comprehensive exploit tests for a project."""
        self.console.print(f"[bold blue]üß™ Starting Comprehensive Exploit Testing for {project_name}[/bold blue]")

        start_time = time.time()
        results = []

        # Start Anvil
        if not self._start_anvil(fork_url=fork_url):
            self.console.print("[red]‚ùå Failed to start Anvil[/red]")
            return ExploitTestSuite(project_name, "", 0, 0, 0, 0.0, [])

        try:
            # Get critical findings
            findings = self.get_critical_findings(project_name)

            if not findings:
                self.console.print(f"[yellow]‚ö†Ô∏è  No critical findings found for {project_name}[/yellow]")
                return ExploitTestSuite(project_name, "", 0, 0, 0, 0.0, [])

            self.console.print(f"[green]‚úÖ Found {len(findings)} critical findings to test[/green]")

            # Test each finding
            for finding in findings:
                self.console.print(f"\n[cyan]üîç Testing: {finding['contract_name']} - {finding['vulnerability_type']}[/cyan]")

                try:
                    # Set up test environment
                    test_dir, test_file, exploit_file = self.setup_test_environment(project_name, finding)

                    # Run the test
                    result = await self.compile_and_test_exploit(test_dir, test_file, exploit_file)
                    results.append(result)

                    # Report result
                    if result.test_compiled and result.test_passed:
                        self.console.print(f"[green]‚úÖ Exploit test PASSED for {finding['contract_name']}[/green]")
                    else:
                        self.console.print(f"[red]‚ùå Exploit test FAILED for {finding['contract_name']}[/red]")
                        if result.errors:
                            self.console.print(f"[red]   Errors: {result.errors[:3]}[/red]")

                except Exception as e:
                    self.console.print(f"[red]‚ùå Error testing {finding['contract_name']}: {e}[/red]")
                    results.append(ExploitTestResult(
                        finding_id=finding['id'],
                        contract_name=finding['contract_name'],
                        vulnerability_type=finding['vulnerability_type'],
                        test_compiled=False,
                        test_passed=False,
                        exploit_deployed=False,
                        exploit_executed=False,
                        profit_generated=0.0,
                        gas_used=0,
                        execution_time=0.0,
                        errors=[str(e)]
                    ))

            # Calculate summary
            tests_passed = sum(1 for r in results if r.test_passed)
            exploits_successful = sum(1 for r in results if r.exploit_executed)

            total_time = time.time() - start_time

            suite = ExploitTestSuite(
                project_name=project_name,
                project_path="",
                findings_tested=len(findings),
                tests_passed=tests_passed,
                exploits_successful=exploits_successful,
                total_execution_time=total_time,
                results=results
            )

            # Print summary
            self.console.print(f"\n[bold green]üìä EXPLOIT TESTING COMPLETE[/bold green]")
            self.console.print(f"   Findings Tested: {suite.findings_tested}")
            self.console.print(f"   Tests Passed: {suite.tests_passed}")
            self.console.print(f"   Exploits Successful: {suite.exploits_successful}")
            self.console.print(f"   Total Time: {suite.total_execution_time:.2f}s")

            return suite

        finally:
            self._stop_anvil()

    def run_exploit_tests_cli(self, project_name: str):
        """CLI interface for exploit testing."""
        self.console.print(f"[bold blue]üöÄ AetherAudit Exploit Testing Framework[/bold blue]")
        self.console.print(f"[bold]Testing exploits for project: {project_name}[/bold]")

        # Check if project exists in database
        contracts = self.get_project_contracts(project_name)
        if not contracts:
            self.console.print(f"[red]‚ùå Project '{project_name}' not found in database[/red]")
            self.console.print(f"[yellow]üí° Run an audit first: python main.py audit <github-url>[/yellow]")
            return

        # Run comprehensive tests
        suite = asyncio.run(self.run_comprehensive_exploit_tests(project_name))

        # Save results
        results_file = f"output/exploit_tests/{project_name}_exploit_test_results.json"
        os.makedirs(os.path.dirname(results_file), exist_ok=True)

        with open(results_file, 'w') as f:
            json.dump({
                'project_name': suite.project_name,
                'findings_tested': suite.findings_tested,
                'tests_passed': suite.tests_passed,
                'exploits_successful': suite.exploits_successful,
                'total_execution_time': suite.total_execution_time,
                'results': [
                    {
                        'finding_id': r.finding_id,
                        'contract_name': r.contract_name,
                        'vulnerability_type': r.vulnerability_type,
                        'test_compiled': r.test_compiled,
                        'test_passed': r.test_passed,
                        'execution_time': r.execution_time,
                        'errors': r.errors[:5]  # Limit error output
                    } for r in suite.results
                ]
            }, f, indent=2)

        self.console.print(f"\n[green]‚úÖ Results saved to: {results_file}[/green]")

# CLI entry point
if __name__ == "__main__":
    import sys

    if len(sys.argv) != 2:
        print("Usage: python core/exploit_tester.py <project_name>")
        print("Example: python core/exploit_tester.py rocketpool")
        sys.exit(1)

    project_name = sys.argv[1]
    tester = ExploitTester()
    tester.run_exploit_tests_cli(project_name)
