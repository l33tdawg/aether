"""
Simple vulnerability detector for AetherAudit.
Basic pattern-based detection for common smart contract vulnerabilities.
"""

import re
from typing import Dict, List, Any
from dataclasses import dataclass


@dataclass
class VulnerabilityMatch:
    """Represents a detected vulnerability."""
    vulnerability_type: str
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    swc_id: str = ""
    category: str = ""


class SimpleVulnerabilityDetector:
    """Simple vulnerability detection using pattern matching."""

    def __init__(self):
        self.patterns = self._initialize_patterns()

    def _initialize_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns."""
        return {
            'reentrancy': [
                {
                    'pattern': r'\.call\s*\{[^}]*value\s*:\s*[^}]*\}',
                    'description': 'Call with value parameter (reentrancy risk)',
                    'severity': 'medium',
                    'confidence': 0.5,
                    'swc_id': 'SWC-107',
                    'category': 'reentrancy'
                },
                {
                    'pattern': r'call\.value\s*\(',
                    'description': 'Call.value() pattern (older Solidity reentrancy)',
                    'severity': 'high',
                    'confidence': 0.8,
                    'swc_id': 'SWC-107',
                    'category': 'reentrancy'
                }
            ],
            'access_control': [
                {
                    'pattern': r'onlyOwner\s*\(\)',
                    'description': 'Owner-only access control check',
                    'severity': 'medium',
                    'confidence': 0.7,
                    'swc_id': 'SWC-105',
                    'category': 'access_control'
                },
                {
                    'pattern': r'require\s*\(\s*msg\.sender\s*==\s*owner',
                    'description': 'Direct owner check without modifier',
                    'severity': 'medium',
                    'confidence': 0.6,
                    'swc_id': 'SWC-105',
                    'category': 'access_control'
                }
            ],
            'integer_overflow': [
                {
                    'pattern': r'(\w+)\s*\+\s*(\w+)',
                    'description': 'Potential integer overflow in addition',
                    'severity': 'medium',
                    'confidence': 0.5,
                    'swc_id': 'SWC-101',
                    'category': 'arithmetic'
                },
                {
                    'pattern': r'(\w+)\s*\*\s*(\w+)',
                    'description': 'Potential integer overflow in multiplication',
                    'severity': 'medium',
                    'confidence': 0.5,
                    'swc_id': 'SWC-101',
                    'category': 'arithmetic'
                }
            ],
            'unchecked_calls': [
                {
                    'pattern': r'(\w+)\.call\s*\(',
                    'description': 'Unchecked external call',
                    'severity': 'medium',
                    'confidence': 0.6,
                    'swc_id': 'SWC-104',
                    'category': 'external_calls'
                },
                {
                    'pattern': r'(\w+)\.delegatecall\s*\(',
                    'description': 'Unchecked delegatecall',
                    'severity': 'high',
                    'confidence': 0.8,
                    'swc_id': 'SWC-104',
                    'category': 'external_calls'
                }
            ]
        }

    def detect_vulnerabilities(self, content: str, contract_path: str = "") -> List[VulnerabilityMatch]:
        """Detect vulnerabilities in contract content."""
        vulnerabilities = []
        lines = content.split('\n')

        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info['pattern']
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                
                for match in regex.finditer(content):
                    line_num = content[:match.start()].count('\n') + 1
                    
                    # Get code snippet around the match
                    start_line = max(0, line_num - 2)
                    end_line = min(len(lines), line_num + 2)
                    code_snippet = '\n'.join(lines[start_line:end_line])
                    
                    vulnerability = VulnerabilityMatch(
                        vulnerability_type=vuln_type,
                        severity=pattern_info['severity'],
                        confidence=pattern_info['confidence'],
                        line_number=line_num,
                        description=pattern_info['description'],
                        code_snippet=code_snippet,
                        swc_id=pattern_info['swc_id'],
                        category=pattern_info['category']
                    )
                    vulnerabilities.append(vulnerability)

        return vulnerabilities

    def validate_vulnerability(self, vulnerability: VulnerabilityMatch, content: str) -> bool:
        """Basic validation to reduce false positives."""
        line_num = vulnerability.line_number
        lines = content.split('\n')
        
        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()
            
            # Skip constructors and interfaces
            if ('constructor' in line_content.lower() or 
                'interface' in line_content.lower() or
                'abstract' in line_content.lower()):
                return False
                
            # Skip comments
            if line_content.startswith('//') or line_content.startswith('/*'):
                return False
                
        return True
