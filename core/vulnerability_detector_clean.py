"""
Comprehensive vulnerability detection module for AetherAudit.
Implements pattern-based detection for common smart contract vulnerabilities.
"""

import re
import ast
from typing import Dict, List, Tuple, Any, Optional
from dataclasses import dataclass


@dataclass
class VulnerabilityMatch:
    """Represents a detected vulnerability."""
    vulnerability_type: str
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    swc_id: str = ""
    category: str = ""


class VulnerabilityDetector:
    """Comprehensive vulnerability detection using pattern matching and static analysis."""

    def __init__(self):
        self.patterns = self._initialize_patterns()
        self.contract_context = {}  # Store contract analysis context

    def set_contract_context(self, context: Dict[str, Any]):
        """Set contract analysis context for better vulnerability validation."""
        self.contract_context = context

    def _initialize_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns."""
        # Get base patterns
        all_patterns = {
            'reentrancy': [
                {
                    'pattern': r'call\s*\([^)]*value[^)]*\)',
                    'description': 'External call with value transfer (potential reentrancy)',
                    'severity': 'high',
                    'confidence': 0.8,
                    'swc_id': 'SWC-107',
                    'category': 'reentrancy'
                },
                {
pattern: r\.call\s*\{[^}]*value\s*:\s*[^}]*\},
description: Call with value parameter (reentrancy risk),
severity: high,
confidence: 0.9,
swc_id: SWC-107,
category: reentrancy                },
                {
pattern: rcall\.value\s*\(,
description: Call.value() pattern (older Solidity reentrancy),
severity: high,
confidence: 0.9,
swc_id: SWC-107,
category: reentrancy                },
                {
pattern: rsend\s*\([^)]*\)\s*;,
description: Unchecked send call (potential reentrancy),
severity: medium,
confidence: 0.7,
swc_id: SWC-107,
category: reentrancy                }
            ],
access_control: [
                {
pattern: rfunction\s+\w+\s*\([^)]*\)\s*(public|external)?\s*\{,
description: Function without access control modifier,
severity: high,
confidence: 0.7,
swc_id: SWC-100,
category: access_control                },
                {
pattern: rtx\.origin\s*==,
description: Use of tx.origin for authorization (vulnerable to phishing),
severity: high,
confidence: 0.9,
swc_id: SWC-115,
category: access_control                },
                {
pattern: rselfdestruct\s*\(,
description: Unprotected selfdestruct call,
severity: high,
confidence: 0.8,
swc_id: SWC-106,
category: access_control                }
            ],
arithmetic: [
                {
pattern: r\+\+|\-\-|\+=|\-=|\*=|/=,
description: Unchecked arithmetic operation,
severity: high,
confidence: 0.6,
swc_id: SWC-101,
category: arithmetic                },
                {
pattern: rbalance\s*\[\s*[^]]+\s*\]\s*[\+\-\*\/]?=\s*[^;]+,
description: Direct balance manipulation (overflow risk),
severity: high,
confidence: 0.8,
swc_id: SWC-101,
category: arithmetic                }
            ],
unchecked_calls: [
                {
pattern: r\.call\s*\([^)]*\)\s*;,
description: Unchecked low-level call,
severity: high,
confidence: 0.9,
swc_id: SWC-104,
category: unchecked_low_level_calls                },
                {
pattern: r\.send\s*\([^)]*\)\s*;,
description: Unchecked send call,
severity: high,
confidence: 0.9,
swc_id: SWC-104,
category: unchecked_low_level_calls                }
            ],
time_manipulation: [
                {
pattern: rblock\.timestamp,
description: Use of block.timestamp (miner manipulable),
severity: medium,
confidence: 0.8,
swc_id: SWC-116,
category: time_manipulation                },
                {
pattern: rblock\.number,
description: Use of block.number (miner manipulable),
severity: medium,
confidence: 0.7,
swc_id: SWC-116,
category: time_manipulation                }
            ],
gas_griefing: [
                {
pattern: rfor\s*\(\s*uint\s+\w+\s*=\s*\d+\s*;\s*\w+\s*<\s*[^;]+;\s*\w+\+\+\s*\)\s*\{,
description: Unbounded loop (potential gas griefing),
severity: medium,
confidence: 0.7,
swc_id: SWC-128,
category: denial_of_service                }
            ],
tx_origin: [
                {
pattern: rtx\.origin\s*==,
description: Use of tx.origin for authorization,
severity: high,
confidence: 0.9,
swc_id: SWC-115,
category: access_control                }
            ],
selfdestruct: [
                {
pattern: rselfdestruct\s*\(,
description: Unprotected selfdestruct call,
severity: high,
confidence: 0.8,
swc_id: SWC-106,
category: access_control                }
            ]
        }

        # Merge Aave-specific patterns
        aave_patterns = self._initialize_aave_specific_patterns()
        all_patterns.update(aave_patterns)

        return all_patterns

    def _initialize_aave_specific_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize Aave-specific vulnerability patterns for high-value bug bounty hunting."""
        return {
flash_loan_attacks: [
                {
pattern: rflashLoan\s*\(,
description: Flash loan function call - potential for price manipulation,
severity: critical,
confidence: 0.9,
swc_id: SWC-999,  # Custom Aave pattern
category: flash_loan_attack,
immunefi_value: 1000000  # $1M potential
                },
                {
pattern: rexecuteOperation\s*\([^)]*params[^)]*\),
description: Flash loan executeOperation - check for state manipulation,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: flash_loan_attack,
immunefi_value: 500000  # $500K potential
                }
            ],
liquidation_manipulation: [
                {
pattern: rliquidate\s*\([^)]*collateralAsset[^)]*debtAsset[^)]*\),
description: Liquidation function - check for incentive calculation exploits,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: liquidation_manipulation,
immunefi_value: 500000
                },
                {
pattern: rcalculateHealthFactor\s*\(,
description: Health factor calculation - potential for manipulation,
severity: high,
confidence: 0.7,
swc_id: SWC-999,
category: liquidation_manipulation,
immunefi_value: 300000
                }
            ],
oracle_manipulation: [
                {
pattern: rgetAssetPrice\s*\([^)]*\),
description: Oracle price retrieval - check for stale price exploitation,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: oracle_manipulation,
immunefi_value: 750000
                },
                {
pattern: rlatestAnswer\s*\(\s*\),
description: Chainlink latestAnswer - check for price feed manipulation,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: oracle_manipulation,
immunefi_value: 500000
                }
            ],
interest_rate_manipulation: [
                {
pattern: rcalculateInterestRates\s*\(,
description: Interest rate calculation - potential for manipulation,
severity: medium,
confidence: 0.7,
swc_id: SWC-999,
category: interest_rate_manipulation,
immunefi_value: 200000
                },
                {
pattern: raccrueInterest\s*\(,
description: Interest accrual - check for rounding exploits,
severity: medium,
confidence: 0.7,
swc_id: SWC-999,
category: interest_rate_manipulation,
immunefi_value: 150000
                }
            ],
governance_attacks: [
                {
pattern: rpropose\s*\([^)]*targets[^)]*values[^)]*signatures[^)]*calldatas[^)]*\),
description: Governance proposal - check for proposal hijacking,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: governance_attack,
immunefi_value: 300000
                },
                {
pattern: remergencyAction\s*\(,
description: Emergency action - check for unauthorized emergency calls,
severity: critical,
confidence: 0.9,
swc_id: SWC-999,
category: governance_attack,
immunefi_value: 1000000
                }
            ],
cross_chain_bridge: [
                {
pattern: rccipReceive\s*\(,
description: CCIP receive function - check for bridge logic vulnerabilities,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: cross_chain_bridge,
immunefi_value: 500000
                },
                {
pattern: rvalidateMessage\s*\(,
description: Message validation - check for cross-chain validation bypass,
severity: high,
confidence: 0.8,
swc_id: SWC-999,
category: cross_chain_bridge,
immunefi_value: 400000
                }
            ]
        }

    def analyze_contract(self, contract_path: str, content: str) -> List[VulnerabilityMatch]:
        """
        Analyze a smart contract for vulnerabilities using pattern matching.

        Args:
            contract_path: Path to the contract file
            content: Contract source code

        Returns:
            List of detected vulnerabilities
        """
        # Set contract context for validation
        self.contract_context = {contract_content: content, contract_path: contract_path}

        vulnerabilities = []

        # Split content into lines for line number tracking
        lines = content.split(\n
        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info[pattern]
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)

                for match in regex.finditer(content):
                    # Find the line number
                    line_number = content[:match.start()].count(\n + 1

                    # Extract code snippet (current line + context)
                    start_line = max(0, line_number - 2)
                    end_line = min(len(lines), line_number + 2)
                    snippet_lines = lines[start_line:end_line]
                    code_snippet = \n.join(snippet_lines)

                    # Heuristic filter: avoid FP for access control when protection exists
                    if vuln_type == access_control and Function without access control modifier in pattern_info.get(description, :
                        if self._is_function_protected_heuristic(content, line_number):
                            # Skip adding this vulnerability if protection is detected
                            continue

                    vulnerability = VulnerabilityMatch(
                        vulnerability_type=vuln_type,
                        severity=pattern_info[severity],
                        confidence=pattern_info[confidence],
                        line_number=line_number,
                        description=pattern_info[description],
                        code_snippet=code_snippet,
                        swc_id=pattern_info.get(swc_id, ,
                        category=pattern_info.get(category,                     )

                    vulnerabilities.append(vulnerability)

        # Apply additional analysis techniques
        vulnerabilities.extend(self._analyze_semantic_patterns(content, lines))
        vulnerabilities.extend(self._analyze_function_patterns(content, lines))

        # Debug: Print found vulnerabilities
        if vulnerabilities:
            print(f"ðŸ” Pattern detection found {len(vulnerabilities)} vulnerabilities:")
            for vuln in vulnerabilities:
                print(f"  - {vuln.vulnerability_type} at line {vuln.line_number}: {vuln.description[:50]}...")

        return vulnerabilities

    def _analyze_semantic_patterns(self, content: str, lines: List[str]) -> List[VulnerabilityMatch]:
        """Analyze semantic patterns that require more complex detection."""
        vulnerabilities = []

        # Check for missing require statements in critical functions
        critical_functions = [withdraw, transfer, mint, burn]
        for func_name in critical_functions:
            if func_name in content.lower():
                # Look for function definition
                func_pattern = rfunction\s+ + re.escape(func_name) + r\s*\([^)]*\)\s*(public|external)?\s*\{                func_match = re.search(func_pattern, content, re.IGNORECASE)

                if func_match:
                    func_start = content[:func_match.end()].count(\n + 1
                    # Extract a bounded slice of the function body for heuristics
                    body_slice = content[func_match.end():func_match.end()+1000]

                    # Consider protected if any of the common protections appear early in the function
                    protected_markers = [
require(hasRole(,
require(msg.sender ==,
require(_msgSender() ==,
onlyOwner,
onlyGov,
onlyRole,
AccessControl                    ]
                    has_protection = any(m in body_slice for m in protected_markers) or self._has_modifier_on_signature(lines, func_start)

                    # Check if function has require statements at all
                    has_require = require( in body_slice

                    if not has_require and not has_protection:
                        vulnerability = VulnerabilityMatch(
                            vulnerability_type=missing_input_validation,
                            severity=medium,
                            confidence=0.6,
                            line_number=func_start,
                            description=fFunction {func_name} lacks input validation,
                            code_snippet=lines[func_start-1] if func_start <= len(lines) else ,
                            swc_id=SWC-123,
                            category=access_control                        )
                        vulnerabilities.append(vulnerability)

        return vulnerabilities

    def _has_modifier_on_signature(self, lines: List[str], func_start_line: int) -> bool:
        """Check if a function signature line includes common access modifiers."""
        if 1 <= func_start_line <= len(lines):
            sig = lines[func_start_line-1]
            modifiers = [onlyOwner, onlyGov, onlyRole, whenNotPaused, nonReentrant]
            return any(m in sig for m in modifiers)
        return False

    def _is_function_protected_heuristic(self, content: str, hit_line: int) -> bool:
        """Heuristic: determine if the matched function likely has access control.

        We look backwards for a nearby function signature and scan the signature and the
        next ~1000 chars of body for typical protection markers.
        """
        # Find approximate function start by searching backward for function        current_pos = 0
        for _ in range(hit_line):
            next_nl = content.find(\n, current_pos)
            if next_nl == -1:
                break
            current_pos = next_nl + 1
        # current_pos is start of hit_line; search backward up to 2000 chars
        scan_start = max(0, current_pos - 2000)
        segment = content[scan_start:current_pos]
        func_kw = segment.rfind(function         if func_kw == -1:
            # Could not locate signature; fallback to forward-only heuristics
            func_body = content[current_pos:current_pos+1000]
            markers = [require(hasRole(, require(msg.sender ==, require(_msgSender() ==, onlyOwner, onlyGov, onlyRole]
            return any(m in func_body for m in markers)

        # Signature line
        sig_start_global = scan_start + func_kw
        sig_line_start = content.rfind(\n, 0, sig_start_global)
        sig_line_end = content.find(\n, sig_start_global)
        sig_text = content[sig_line_start+1 if sig_line_start != -1 else 0 : sig_line_end if sig_line_end != -1 else sig_start_global+200]

        # Check signature modifiers
        if any(m in sig_text for m in [onlyOwner, onlyGov, onlyRole]):
            return True

        # Scan body slice for protections
        body_start = content.find({, sig_start_global)
        body_slice = content[body_start+1: body_start+1+1200] if body_start != -1 else content[sig_start_global:sig_start_global+1200]
        body_markers = [require(hasRole(, require(msg.sender ==, require(_msgSender() ==, onlyOwner, onlyGov, onlyRole]
        return any(m in body_slice for m in body_markers)

    def _analyze_function_patterns(self, content: str, lines: List[str]) -> List[VulnerabilityMatch]:
        """Analyze function-level patterns for vulnerabilities."""
        vulnerabilities = []

        # Find all function definitions
        function_pattern = rfunction\s+(\w+)\s*\([^)]*\)\s*(public|external|internal|private)?\s*(view|pure|payable)?\s*\{        functions = re.findall(function_pattern, content, re.IGNORECASE)

        for func_match in re.finditer(function_pattern, content, re.IGNORECASE):
            func_name = func_match.group(1)
            visibility = func_match.group(2) or public  # Default visibility is public
            modifier = func_match.group(3) or             func_line = content[:func_match.start()].count(\n + 1

            # Check for dangerous function patterns
            if func_name.lower() in [withdraw, transfer] and payable not in modifier.lower():
                if value in content[func_match.end():func_match.end()+200]:  # Check next 200 chars
                    vulnerability = VulnerabilityMatch(
                        vulnerability_type=dangerous_payable_function,
                        severity=medium,
                        confidence=0.7,
                        line_number=func_line,
                        description=fFunction {func_name} handles value but is not payable,
                        code_snippet=lines[func_line-1] if func_line <= len(lines) else ,
                        swc_id=SWC-105,
                        category=access_control                    )
                    vulnerabilities.append(vulnerability)

        return vulnerabilities

    def get_vulnerability_summary(self, vulnerabilities: List[VulnerabilityMatch]) -> Dict[str, Any]:
        """Generate a summary of detected vulnerabilities."""
        summary = {
total_vulnerabilities: len(vulnerabilities),
by_severity: {
critical: 0,
high: 0,
medium: 0,
low: 0
            },
by_category: {},
by_swc: {},
top_issues: []
        }

        for vuln in vulnerabilities:
            # Count by severity
            summary[by_severity][vuln.severity] += 1

            # Count by category
            category = vuln.category or other            summary[by_category][category] = summary[by_category].get(category, 0) + 1

            # Count by SWC ID
            if vuln.swc_id:
                summary[by_swc][vuln.swc_id] = summary[by_swc].get(vuln.swc_id, 0) + 1

        # Get top issues (highest confidence first)
        sorted_vulns = sorted(vulnerabilities, key=lambda x: x.confidence, reverse=True)
        summary[top_issues] = sorted_vulns[:10]  # Top 10 issues

        return summary

    def validate_vulnerability_context(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate if a vulnerability is actually exploitable based on contract context."""
        vuln_type = vulnerability.vulnerability_type
        line_number = vulnerability.line_number

        # Context-aware validation for different vulnerability types
        if vuln_type == access_control:
            # Use enhanced validation for function access control patterns
            if hasattr(vulnerability, validation_function and vulnerability.validation_function == _validate_function_access_control:
                return self._validate_function_access_control(vulnerability)
            else:
                return self._validate_access_control(vulnerability)
        elif vuln_type == arithmetic:
            return self._validate_arithmetic(vulnerability)
        elif vuln_type == time_manipulation:
            return self._validate_time_manipulation(vulnerability)
        elif vuln_type == reentrancy:
            return self._validate_reentrancy(vulnerability)
        elif vuln_type == unchecked_calls:
            return self._validate_unchecked_calls(vulnerability)
        elif vuln_type in [flash_loan_attack, liquidation_manipulation, oracle_manipulation, governance_attack, cross_chain_bridge]:
            return self._validate_aave_specific(vulnerability)

        # Default: keep vulnerability if confidence is high enough
        return vulnerability.confidence > 0.7

    def _validate_access_control(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate access control vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        line_num = vulnerability.line_number

        # Check if this is in a constructor or interface (often false positives)
        lines = content.split(\n\n        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()

            # Skip constructors and interfaces
            if (constructor in line_content.lower() or
interface in content[:line_num*50].lower() or
abstract in content[:line_num*50].lower()):
                return False

            # Check if function already has access control
            if self._function_has_access_control(content, line_num):
                return False

        return True

    def _validate_arithmetic(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate arithmetic vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if using SafeMath or Solidity 0.8+
            context_before = content[:content.find(line_content)].lower()
            if (safemath in context_before or
using safemath in context_before or
pragma solidity in context_before and >=0.8 in context_before):
                return False  # Protected by SafeMath or modern Solidity

        return True

    def _validate_time_manipulation(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate time manipulation vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if this is in a view/pure function (cant manipulate state)
            function_context = self._get_function_context(content, line_num)
            if function_context and (view in function_context or pure in function_context):
                return False  # View/pure functions cant manipulate state

            # Check if timestamp is used for critical logic vs. informational
            if block.timestamp in line_content:
                # If its just for logging or non-critical logic, downgrade
                if any(keyword in line_content.lower() for keyword in [emit, log, event]):
                    return False

        return True

    def _validate_reentrancy(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate reentrancy vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number

        # Check if this is in a view/pure function
        function_context = self._get_function_context(content, line_num)
        if function_context and (view in function_context or pure in function_context):
            return False

        # Check for reentrancy guards
        if nonreentrant in content[:line_num*100].lower():
            return False

        return True

    def _validate_unchecked_calls(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate unchecked low-level call vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if the call result is actually checked
            # Look for patterns that check the return value
            context_after = content[line_num*50:(line_num+5)*50] if line_num < len(lines) else ""
            if (any(keyword in context_after.lower() for keyword in [require(, if (!, assert(]) or
.call{ in line_content):  # Structured call with return value
                return False

        return True

    def _get_contract_content(self) -> Optional[str]:
        """Get the contract content from context."""
        # This would need to be set when calling analyze_contract
        return self.contract_context.get(contract_content
    def _function_has_access_control(self, content: str, line_num: int) -> bool:
        """Check if a function has access control modifiers."""
        lines = content.split(\n\n        if line_num > len(lines):
            return False

        # Look backwards for function declaration
        for i in range(line_num - 1, max(0, line_num - 20), -1):
            line = lines[i].strip()
            if line.startswith(function:
                # Check if function has modifiers
                return (modifier in line.lower() or
onlyowner in line.lower() or
onlyadmin in line.lower() or
onlygovernance in line.lower())
        return False

    def _get_function_context(self, content: str, line_num: int) -> Optional[str]:
        """Get the function context around a line."""
        lines = content.split(\n\n        if line_num > len(lines):
            return None

        # Look backwards for function declaration
        for i in range(line_num - 1, max(0, line_num - 10), -1):
            line = lines[i].strip()
            if line.startswith(function:
                return line
        return None

    def filter_false_positives(self, vulnerabilities: List[VulnerabilityMatch]) -> List[VulnerabilityMatch]:
        """Filter out false positive vulnerabilities using context-aware validation."""
        filtered = []

        for vuln in vulnerabilities:
            if self.validate_vulnerability_context(vuln):
                filtered.append(vuln)
            else:
                # Downgrade confidence for filtered vulnerabilities
                vuln.confidence = max(0.1, vuln.confidence * 0.3)


    def _validate_function_access_control(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate function access control vulnerabilities with enhanced logic."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        line_num = vulnerability.line_number
        lines = content.split(\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()

            # Skip constructors - they often dont need access control
            if constructor in line_content.lower():
                return False

            # Skip interfaces and abstract contracts
            contract_prefix = content[:line_num*50].lower()
            if (interface in contract_prefix or abstract in contract_prefix):
                return False

            # Skip functions that are clearly internal/private
            if any(modifier in line_content.lower() for modifier in [internal, private]):
                return False

            # Check if function already has access control
            if self._function_has_access_control(content, line_num):
                return False

            # Check if this is a view/pure function (often doesnt need access control)
            if any(modifier in line_content.lower() for modifier in [view, pure]):
                return False

            # Check if function is in a library (libraries often dont need access control)
            if library in content[:line_num*100].lower():
                return False

            # Only flag external/public functions without access control
            if any(modifier in line_content.lower() for modifier in [public, external]):
                return True

        return False  # Default to false if we cant determine
        return filtered

    def enhance_with_ml_analysis(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> List[VulnerabilityMatch]:
        """Enhance vulnerability detection using machine learning patterns."""
        try:
            from core.ml_analyzer import MLAnalyzer

            ml_analyzer = MLAnalyzer()
            enhanced_vulns = []

            for vuln in vulnerabilities:
                # Convert to dict for ML analysis
                vuln_dict = {
vulnerability_type: vuln.vulnerability_type,
severity: vuln.severity,
confidence: vuln.confidence,
line: vuln.line_number,
description: vuln.description,
code_snippet: vuln.code_snippet,
swc_id: vuln.swc_id,
category: vuln.category,
tool: pattern_analyzer,
status: suspected                }

                # Get ML enhancement
                contract_features = self._extract_contract_features_for_ml(contract_content, vuln_dict)
                ml_prediction = ml_analyzer.predict_vulnerability_confidence(
                    vuln.vulnerability_type,
                    contract_features
                )

                # Apply ML enhancements
                if ml_prediction[pattern_match]:
                    vuln.confidence = max(vuln.confidence, ml_prediction[confidence])
                    vuln.severity = self._upgrade_severity_with_ml(vuln.severity, ml_prediction)

                    # Add ML insights
                    vuln.ml_enhanced = True
                    vuln.historical_success_rate = ml_prediction[historical_success_rate]
                    vuln.expected_funds_at_risk = ml_prediction[expected_funds_at_risk]

                enhanced_vulns.append(vuln)

            return enhanced_vulns

        except ImportError:
            print("âš ï¸ ML Analyzer not available, skipping ML enhancement")
            return vulnerabilities
        except Exception as e:
            print(f"Error in ML enhancement: {e}")
            return vulnerabilities

    def _extract_contract_features_for_ml(self, contract_content: str, vulnerability: Dict[str, Any]) -> Dict[str, Any]:
        """Extract contract features for ML analysis."""
        vuln_type = vulnerability.get(vulnerability_type,         line_num = vulnerability.get(line, 0)

        # Use the same feature extraction logic as in MLAnalyzer
        if vuln_type == reentrancy:
            return self._extract_reentrancy_features(contract_content, line_num)
        elif vuln_type == access_control:
            return self._extract_access_control_features(contract_content, line_num)
        elif vuln_type == oracle_manipulation:
            return self._extract_oracle_features(contract_content, line_num)
        elif vuln_type == flash_loan_attack:
            return self._extract_flash_loan_features(contract_content, line_num)
        else:
            return self._extract_generic_features(contract_content, line_num)

    def _upgrade_severity_with_ml(self, current_severity: str, ml_prediction: Dict[str, float]) -> str:
        """Upgrade severity based on ML insights."""
        if ml_prediction[confidence] > 0.8 and ml_prediction[historical_success_rate] > 0.7:
            if current_severity == medium:
                return high            elif current_severity == low:
                return medium
        return current_severity

    def assess_economic_impact(self, vulnerabilities: List[VulnerabilityMatch]) -> Dict[str, Any]:
        """Assess economic impact of vulnerabilities for Immunefi bounty assessment."""
        impact_summary = {
total_funds_at_risk: 0,
critical_vulnerabilities: 0,
high_vulnerabilities: 0,
medium_vulnerabilities: 0,
low_vulnerabilities: 0,
immunefi_eligible_count: 0,
max_potential_bounty: 0,
vulnerability_breakdown: {}
        }

        for vuln in vulnerabilities:
            vuln_type = vuln.vulnerability_type
            severity = vuln.severity

            # Count by severity
            if severity == critical:
                impact_summary[critical_vulnerabilities] += 1
                impact_summary[immunefi_eligible_count] += 1
            elif severity == high:
                impact_summary[high_vulnerabilities] += 1
                impact_summary[immunefi_eligible_count] += 1
            elif severity == medium:
                impact_summary[medium_vulnerabilities] += 1
            elif severity == low:
                impact_summary[low_vulnerabilities] += 1

            # Calculate economic impact based on vulnerability type
            economic_impact = self._calculate_vulnerability_impact(vuln)

            # Update totals
            impact_summary[total_funds_at_risk] += economic_impact[funds_at_risk]
            impact_summary[max_potential_bounty] += economic_impact[bounty_potential]

            # Track by vulnerability type
            if vuln_type not in impact_summary[vulnerability_breakdown]:
                impact_summary[vulnerability_breakdown][vuln_type] = {
count: 0,
funds_at_risk: 0,
bounty_potential: 0
                }

            impact_summary[vulnerability_breakdown][vuln_type][count] += 1
            impact_summary[vulnerability_breakdown][vuln_type][funds_at_risk] += economic_impact[funds_at_risk]
            impact_summary[vulnerability_breakdown][vuln_type][bounty_potential] += economic_impact[bounty_potential]

        return impact_summary

    def _calculate_vulnerability_impact(self, vulnerability: VulnerabilityMatch) -> Dict[str, float]:
        """Calculate economic impact of a specific vulnerability."""
        vuln_type = vulnerability.vulnerability_type
        severity = vulnerability.severity

        # Base impact calculations
        if severity == critical:
            base_funds = 1000000  # $1M base for critical
        elif severity == high:
            base_funds = 100000   # $100K base for high
        elif severity == medium:
            base_funds = 10000    # $10K base for medium
        else:
            base_funds = 1000     # $1K base for low

        # Adjust based on vulnerability type for Aave-specific scenarios
        multiplier = 1.0

        if vuln_type == flash_loan_attack:
            multiplier = 3.0  # Flash loans can manipulate large amounts
        elif vuln_type == liquidation_manipulation:
            multiplier = 2.5  # Liquidations affect protocol health
        elif vuln_type == oracle_manipulation:
            multiplier = 2.0  # Oracles control pricing across protocol
        elif vuln_type == governance_attack:
            multiplier = 2.0  # Governance controls entire protocol
        elif vuln_type == cross_chain_bridge:
            multiplier = 1.5  # Bridge issues affect cross-chain assets

        funds_at_risk = base_funds * multiplier

        # Calculate Immunefi bounty potential (10% of funds at risk, capped)
        if severity == critical:
            bounty_potential = min(funds_at_risk * 0.1, 1000000)  # Cap at $1M
        elif severity == high:
            bounty_potential = min(funds_at_risk * 0.1, 75000)   # Cap at $75K
        elif severity == medium:
            bounty_potential = min(funds_at_risk * 0.1, 10000)   # Cap at $10K
        else:
            bounty_potential = min(funds_at_risk * 0.1, 1000)    # Cap at $1K

        return {
funds_at_risk: funds_at_risk,
bounty_potential: bounty_potential
        }

    def analyze_state_machine_exploits(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> List[Dict[str, Any]]:
        """Analyze for multi-transaction exploit chains and state-dependent vulnerabilities."""
        state_exploits = []

        # Group vulnerabilities by contract and function context
        vuln_groups = self._group_vulnerabilities_by_context(vulnerabilities)

        for context_key, context_vulns in vuln_groups.items():
            if len(context_vulns) >= 2:  # Need at least 2 vulnerabilities for multi-transaction exploits
                # Check for state-dependent exploit chains
                exploit_chain = self._analyze_exploit_chain(context_vulns, contract_content)
                if exploit_chain:
                    state_exploits.append(exploit_chain)

        return state_exploits

    def _group_vulnerabilities_by_context(self, vulnerabilities: List[VulnerabilityMatch]) -> Dict[str, List[VulnerabilityMatch]]:
        """Group vulnerabilities by contract function context."""
        groups = {}

        for vuln in vulnerabilities:
            # Create context key based on function and vulnerability type
            context_key = f"{vuln.vulnerability_type}_{vuln.line_number}"
            if context_key not in groups:
                groups[context_key] = []
            groups[context_key].append(vuln)

        return groups

    def _analyze_exploit_chain(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> Optional[Dict[str, Any]]:
        """Analyze if vulnerabilities can be chained into a multi-transaction exploit."""
        if len(vulnerabilities) < 2:
            return None

        # Look for specific exploit patterns
        vuln_types = [v.vulnerability_type for v in vulnerabilities]

        # Flash loan + Oracle manipulation chain
        if flash_loan_attack in vuln_types and oracle_manipulation in vuln_types:
            return self._analyze_flash_loan_oracle_chain(vulnerabilities, contract_content)

        # Liquidation + Interest rate manipulation chain
        elif liquidation_manipulation in vuln_types and interest_rate_manipulation in vuln_types:
            return self._analyze_liquidation_interest_chain(vulnerabilities, contract_content)

        # Governance + Access control chain
        elif governance_attack in vuln_types and access_control in vuln_types:
            return self._analyze_governance_access_chain(vulnerabilities, contract_content)

        return None

    def _analyze_flash_loan_oracle_chain(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> Dict[str, Any]:
        """Analyze flash loan + oracle manipulation exploit chain."""
        return {
exploit_type: flash_loan_oracle_manipulation,
severity: critical,
description: Flash loan can be used to manipulate oracle prices for profitable liquidations,
steps: [
1. Deploy flash loan contract,
2. Borrow large amount via flash loan,
3. Manipulate oracle price using borrowed funds,
4. Trigger liquidations at manipulated price,
5. Repay flash loan and keep profits            ],
funds_at_risk: 2000000,  # $2M potential
bounty_potential: 200000,  # $200K potential bounty
vulnerabilities_involved: [v.vulnerability_type for v in vulnerabilities]
        }

    def _analyze_liquidation_interest_chain(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> Dict[str, Any]:
        """Analyze liquidation + interest rate manipulation exploit chain."""
        return {
exploit_type: liquidation_interest_manipulation,
severity: high,
description: Interest rate manipulation can force unwanted liquidations,
steps: [
1. Manipulate interest rates to increase borrowing costs,
2. Force users into liquidation threshold,
3. Execute liquidation with manipulated incentives,
4. Profit from liquidation bonus            ],
funds_at_risk: 500000,  # $500K potential
bounty_potential: 50000,  # $50K potential bounty
vulnerabilities_involved: [v.vulnerability_type for v in vulnerabilities]
        }

    def _analyze_governance_access_chain(self, vulnerabilities: List[VulnerabilityMatch], contract_content: str) -> Dict[str, Any]:
        """Analyze governance + access control exploit chain."""
        return {
exploit_type: governance_access_bypass,
severity: critical,
description: Access control bypass can lead to governance manipulation,
steps: [
1. Bypass access control to gain unauthorized access,
2. Propose malicious governance changes,
3. Execute governance attack,
4. Control protocol parameters            ],
funds_at_risk: 1000000,  # $1M potential
bounty_potential: 100000,  # $100K potential bounty
vulnerabilities_involved: [v.vulnerability_type for v in vulnerabilities]
        }

    def _validate_aave_specific(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate Aave-specific vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        vuln_type = vulnerability.vulnerability_type
        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Flash loan validation
            if vuln_type == flash_loan_attack:
                # Check if flash loan has proper validation
                if require not in content[max(0, line_num-10):line_num+10]:
                    return False  # No validation, likely false positive

                # Check for executeOperation implementation
                if executeOperation in line_content and require in content[line_num:line_num+20]:
                    return True  # Proper validation exists

            # Liquidation validation
            elif vuln_type == liquidation_manipulation:
                # Check if liquidation has proper checks
                context_before = content[max(0, line_num-20):line_num]
                if any(keyword in context_before for keyword in [require, if (, modifier]):
                    return True  # Proper validation exists

            # Oracle validation
            elif vuln_type == oracle_manipulation:
                # Check for oracle validation patterns
                context_after = content[line_num:min(len(lines), line_num+10)]
                if any(keyword in context_after for keyword in [require, assert, if (]):
                    return False  # Oracle calls are validated

            # Governance validation
            elif vuln_type == governance_attack:
                # Check for governance validation
                if onlyGovernance in content or onlyOwner in content or require in line_content:
                    return False  # Proper access control exists

            # Cross-chain validation
            elif vuln_type == cross_chain_bridge:
                # Check for proper message validation
                if validateMessage in line_content and require in content[line_num:line_num+15]:
                    return False  # Proper validation exists

        return True


class SlitherIntegration:
    """Integration with Slither static analyzer."""

    def __init__(self):
        self.slither_available = self._check_slither_availability()

    def _check_slither_availability(self) -> bool:
        """Check if Slither is available and working."""
        try:
            import subprocess
            result = subprocess.run([slither, --help],
                                  capture_output=True, text=True, timeout=10)
            return result.returncode == 0
        except (FileNotFoundError, subprocess.TimeoutExpired):
            return False

    def analyze_with_slither(self, contract_path: str) -> List[Dict[str, Any]]:
        """Run Slither analysis on a contract."""
        if not self.slither_available:
            return []

        try:
            import subprocess
            import json
            import tempfile
            import shutil
            from pathlib import Path

            # Create a temporary directory for the contract
            with tempfile.TemporaryDirectory() as temp_dir:
                # Copy the contract to the temp directory
                contract_file = Path(contract_path)
                temp_contract_path = Path(temp_dir) / contract_file.name
                shutil.copy2(contract_path, temp_contract_path)

                # Create a minimal foundry.toml
                foundry_toml = Path(temp_dir) / "foundry.toml"
                foundry_toml.write_text("""
[profile.default]
src = "src"
out = "out"
libs = ["lib"]

[dependencies]
forge-std = "1.11.0"
                """.strip())

                # Create src directory and move contract there
                src_dir = Path(temp_dir) / "src"
                src_dir.mkdir()
                final_contract_path = src_dir / contract_file.name
                shutil.move(str(temp_contract_path), str(final_contract_path))

                # Run slither from the temp directory with Foundry compilation
                cmd = [
slither,
                    str(final_contract_path),
--json, -,
--exclude-dependencies,
--exclude-informational,
--compile-force-framework, foundry                ]

                # Set up environment with Foundry in PATH and library paths
                import os
                env = os.environ.copy()
                env[PATH] = f"/Users/l33tdawg/.foundry/bin:{env.get(PATH, }"
                env[FOUNDRY_LIBRARIES] = /Users/l33tdawg/lib
                result = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=300,
                    env=env,
                    cwd=temp_dir  # Run from the temp directory
                )

                if result.returncode == 0 or result.returncode == 255:
                    try:
                        if result.stdout.strip().startswith({:
                            data = json.loads(result.stdout)
                            vulnerabilities = self._parse_slither_output(data)
                            return vulnerabilities
                        else:
                            return []
                    except json.JSONDecodeError as e:
                        return []
                else:
                    return []

        except Exception as e:
            return []

    def _parse_slither_output(self, data: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Parse Slither JSON output into standardized format."""
        vulnerabilities = []

        # Handle the actual slither JSON structure
        results = data.get(results, {})
        detectors = results.get(detectors, [])

        for detector in detectors:
            # Each detector has elements array with vulnerability info
            for element in detector.get(elements, []):
                vulnerabilities.append({
type: detector.get(check, unknown,
title: detector.get(check, Unknown,
description: detector.get(description, ,
severity: detector.get(impact, Medium.lower(),
confidence: detector.get(confidence, Medium.lower(),
line: element.get(source_mapping, {}).get(lines, [0])[0] if element.get(source_mapping else 0,
file: element.get(source_mapping, {}).get(filename_relative,  if element.get(source_mapping else ,
swc_id: detector.get(id, ,
category: detector.get(check, unknown                })

        return vulnerabilities

    def validate_vulnerability_context(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate if a vulnerability is actually exploitable based on contract context."""
        vuln_type = vulnerability.vulnerability_type
        line_number = vulnerability.line_number

        # Context-aware validation for different vulnerability types
        if vuln_type == access_control:
            # Use enhanced validation for function access control patterns
            if hasattr(vulnerability, validation_function and vulnerability.validation_function == _validate_function_access_control:
                return self._validate_function_access_control(vulnerability)
            else:
                return self._validate_access_control(vulnerability)
        elif vuln_type == arithmetic:
            return self._validate_arithmetic(vulnerability)
        elif vuln_type == time_manipulation:
            return self._validate_time_manipulation(vulnerability)
        elif vuln_type == reentrancy:
            return self._validate_reentrancy(vulnerability)
        elif vuln_type == unchecked_calls:
            return self._validate_unchecked_calls(vulnerability)
        elif vuln_type in [flash_loan_attack, liquidation_manipulation, oracle_manipulation, governance_attack, cross_chain_bridge]:
            return self._validate_aave_specific(vulnerability)

        # Default: keep vulnerability if confidence is high enough
        return vulnerability.confidence > 0.7

    def _validate_access_control(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate access control vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        line_num = vulnerability.line_number

        # Check if this is in a constructor or interface (often false positives)
        lines = content.split(\n\n        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()

            # Skip constructors and interfaces
            if (constructor in line_content.lower() or
interface in content[:line_num*50].lower() or
abstract in content[:line_num*50].lower()):
                return False

            # Check if function already has access control
            if self._function_has_access_control(content, line_num):
                return False

        return True

    def _validate_arithmetic(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate arithmetic vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if using SafeMath or Solidity 0.8+
            context_before = content[:content.find(line_content)].lower()
            if (safemath in context_before or
using safemath in context_before or
pragma solidity in context_before and >=0.8 in context_before):
                return False  # Protected by SafeMath or modern Solidity

        return True

    def _validate_time_manipulation(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate time manipulation vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if this is in a view/pure function (cant manipulate state)
            function_context = self._get_function_context(content, line_num)
            if function_context and (view in function_context or pure in function_context):
                return False  # View/pure functions cant manipulate state

            # Check if timestamp is used for critical logic vs. informational
            if block.timestamp in line_content:
                # If its just for logging or non-critical logic, downgrade
                if any(keyword in line_content.lower() for keyword in [emit, log, event]):
                    return False

        return True

    def _validate_reentrancy(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate reentrancy vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number

        # Check if this is in a view/pure function
        function_context = self._get_function_context(content, line_num)
        if function_context and (view in function_context or pure in function_context):
            return False

        # Check for reentrancy guards
        if nonreentrant in content[:line_num*100].lower():
            return False

        return True

    def _validate_unchecked_calls(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate unchecked low-level call vulnerabilities."""
        content = self._get_contract_content()
        if not content:
            return True

        line_num = vulnerability.line_number
        lines = content.split(\n\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1]

            # Check if the call result is actually checked
            # Look for patterns that check the return value
            context_after = content[line_num*50:(line_num+5)*50] if line_num < len(lines) else ""
            if (any(keyword in context_after.lower() for keyword in [require(, if (!, assert(]) or
.call{ in line_content):  # Structured call with return value
                return False

        return True

    def _get_contract_content(self) -> Optional[str]:
        """Get the contract content from context."""
        # This would need to be set when calling analyze_contract
        return self.contract_context.get(contract_content
    def _function_has_access_control(self, content: str, line_num: int) -> bool:
        """Check if a function has access control modifiers."""
        lines = content.split(\n\n        if line_num > len(lines):
            return False

        # Look backwards for function declaration
        for i in range(line_num - 1, max(0, line_num - 20), -1):
            line = lines[i].strip()
            if line.startswith(function:
                # Check if function has modifiers
                return (modifier in line.lower() or
onlyowner in line.lower() or
onlyadmin in line.lower() or
onlygovernance in line.lower())
        return False

    def _get_function_context(self, content: str, line_num: int) -> Optional[str]:
        """Get the function context around a line."""
        lines = content.split(\n\n        if line_num > len(lines):
            return None

        # Look backwards for function declaration
        for i in range(line_num - 1, max(0, line_num - 10), -1):
            line = lines[i].strip()
            if line.startswith(function:
                return line
        return None

    def filter_false_positives(self, vulnerabilities: List[VulnerabilityMatch]) -> List[VulnerabilityMatch]:
        """Filter out false positive vulnerabilities using context-aware validation."""
        filtered = []

        for vuln in vulnerabilities:
            if self.validate_vulnerability_context(vuln):
                filtered.append(vuln)
            else:
                # Downgrade confidence for filtered vulnerabilities
                vuln.confidence = max(0.1, vuln.confidence * 0.3)


    def _validate_function_access_control(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate function access control vulnerabilities with enhanced logic."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        line_num = vulnerability.line_number
        lines = content.split(\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()

            # Skip constructors - they often dont need access control
            if constructor in line_content.lower():
                return False

            # Skip interfaces and abstract contracts
            contract_prefix = content[:line_num*50].lower()
            if (interface in contract_prefix or abstract in contract_prefix):
                return False

            # Skip functions that are clearly internal/private
            if any(modifier in line_content.lower() for modifier in [internal, private]):
                return False

            # Check if function already has access control
            if self._function_has_access_control(content, line_num):
                return False

            # Check if this is a view/pure function (often doesnt need access control)
            if any(modifier in line_content.lower() for modifier in [view, pure]):
                return False

            # Check if function is in a library (libraries often dont need access control)
            if library in content[:line_num*100].lower():
                return False

            # Only flag external/public functions without access control
            if any(modifier in line_content.lower() for modifier in [public, external]):
                return True

        return False  # Default to false if we cant determine
        return filtered

    def _validate_function_access_control(self, vulnerability: VulnerabilityMatch) -> bool:
        """Validate function access control vulnerabilities with enhanced logic."""
        content = self._get_contract_content()
        if not content:
            return True  # Keep if we cant validate

        line_num = vulnerability.line_number
        lines = content.split(\n
        if line_num <= len(lines):
            line_content = lines[line_num - 1].strip()

            # Skip constructors - they often dont need access control
            if constructor in line_content.lower():
                return False

            # Skip interfaces and abstract contracts
            contract_prefix = content[:line_num*50].lower()
            if (interface in contract_prefix or abstract in contract_prefix):
                return False

            # Skip functions that are clearly internal/private
            if any(modifier in line_content.lower() for modifier in [internal, private]):
                return False

            # Check if function already has access control
            if self._function_has_access_control(content, line_num):
                return False

            # Check if this is a view/pure function (often doesnt need access control)
            if any(modifier in line_content.lower() for modifier in [view, pure]):
                return False

            # Check if function is in a library (libraries often dont need access control)
            if library in content[:line_num*100].lower():
                return False

            # Only flag external/public functions without access control
            if any(modifier in line_content.lower() for modifier in [public, external]):
                return True

        return False  # Default to false if we cant determine
