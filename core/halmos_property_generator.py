"""
Halmos Symbolic Property Generator for Aether.

Converts vulnerability findings and invariants into Halmos-compatible
symbolic test functions (``check_*`` style) that can be verified with
``halmos --function check_*``.

Unlike Foundry fuzz tests (which use ``test_*`` or ``invariant_*``), Halmos
symbolically explores *all* inputs and therefore provides much stronger
guarantees â€” equivalent to bounded model checking.
"""

import logging
import re
from dataclasses import dataclass, field
from typing import Any, Dict, List, Optional

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Data structures
# ---------------------------------------------------------------------------

@dataclass
class HalmosProperty:
    """A single symbolic property test function."""
    function_name: str
    function_body: str
    description: str
    related_finding_id: Optional[str] = None
    property_type: str = "safety"  # safety | liveness | invariant


@dataclass
class HalmosTestSuite:
    """A complete Halmos test contract."""
    contract_name: str
    target_contract: str
    target_import_path: str
    properties: List[HalmosProperty] = field(default_factory=list)
    setup_body: str = ""
    extra_imports: List[str] = field(default_factory=list)

    def to_solidity(self) -> str:
        """Render as a compilable Solidity file."""
        imports = ['import "forge-std/Test.sol";']
        imports.append(f'import "{self.target_import_path}";')
        for extra in self.extra_imports:
            imports.append(f'import "{extra}";')
        imports_text = "\n".join(imports)

        setup = self.setup_body or (
            f"        // TODO: deploy and initialize target\n"
            f"        // target = new {self.target_contract}(...);"
        )

        funcs = []
        for prop in self.properties:
            funcs.append(
                f"    /// @notice {prop.description}\n"
                f"    function {prop.function_name}({prop.function_body.split('(', 1)[1] if '(' in prop.function_body else ') public {'}\n"
                if "function " in prop.function_body
                else f"    /// @notice {prop.description}\n"
                     f"    {prop.function_body}"
            )

        # Simpler rendering: just emit the body directly
        prop_blocks = []
        for prop in self.properties:
            prop_blocks.append(
                f"    /// @notice {prop.description}\n"
                f"    {prop.function_body}"
            )
        props_text = "\n\n".join(prop_blocks)

        return (
            f"// SPDX-License-Identifier: MIT\n"
            f"pragma solidity ^0.8.0;\n\n"
            f"{imports_text}\n\n"
            f"/// @title Halmos symbolic tests for {self.target_contract}\n"
            f"/// @notice Auto-generated by Aether's HalmosPropertyGenerator\n"
            f"contract {self.contract_name} is Test {{\n"
            f"    {self.target_contract} public target;\n\n"
            f"    function setUp() public {{\n"
            f"{setup}\n"
            f"    }}\n\n"
            f"{props_text}\n"
            f"}}\n"
        )


# ---------------------------------------------------------------------------
# Vulnerability-type -> property mapping
# ---------------------------------------------------------------------------

_VULN_PROPERTY_TEMPLATES: Dict[str, Dict[str, str]] = {
    "reentrancy": {
        "name": "check_noReentrancy_{index}",
        "description": "No reentrancy: state changes before external calls",
        "body": (
            "function check_noReentrancy_{index}(uint256 amount) public {{\n"
            "        // Symbolic check: balance consistency after external call\n"
            "        uint256 balBefore = address(target).balance;\n"
            "        // Call the vulnerable function with symbolic input\n"
            "        try target.{function}(amount) {{}} catch {{}}\n"
            "        uint256 balAfter = address(target).balance;\n"
            "        // Balance should not decrease more than amount\n"
            "        assert(balBefore - balAfter <= amount);\n"
            "    }}"
        ),
    },
    "integer_overflow": {
        "name": "check_noOverflow_{index}",
        "description": "No integer overflow in arithmetic operations",
        "body": (
            "function check_noOverflow_{index}(uint256 a, uint256 b) public {{\n"
            "        // Symbolic check: overflow safety\n"
            "        // The compiler should enforce this for Solidity >=0.8\n"
            "        // For unchecked blocks, halmos will find counterexamples\n"
            "        try target.{function}(a, b) {{}} catch {{}}\n"
            "    }}"
        ),
    },
    "share_inflation": {
        "name": "check_noShareInflation_{index}",
        "description": "No share inflation: first depositor cannot steal funds",
        "body": (
            "function check_noShareInflation_{index}(uint256 depositAmount) public {{\n"
            "        vm.assume(depositAmount > 0 && depositAmount < type(uint128).max);\n"
            "        uint256 shares = target.convertToShares(depositAmount);\n"
            "        uint256 redeemed = target.convertToAssets(shares);\n"
            "        // Depositor should be able to redeem at least what they deposited\n"
            "        assert(redeemed >= depositAmount - 1);  // Allow 1 wei rounding\n"
            "    }}"
        ),
    },
    "price_manipulation": {
        "name": "check_noPriceManipulation_{index}",
        "description": "No oracle / price manipulation via spot price",
        "body": (
            "function check_noPriceManipulation_{index}(uint256 amount) public {{\n"
            "        vm.assume(amount > 0 && amount < type(uint128).max);\n"
            "        // Snapshot price before\n"
            "        // uint256 priceBefore = target.getPrice();\n"
            "        // Execute potentially manipulable operation\n"
            "        // try target.{function}(amount) {{}} catch {{}}\n"
            "        // uint256 priceAfter = target.getPrice();\n"
            "        // Price should not change by more than slippage tolerance\n"
            "        // assert(priceAfter * 100 >= priceBefore * 95);\n"
            "        assert(true);  // TODO: customize for specific oracle\n"
            "    }}"
        ),
    },
    "access_control": {
        "name": "check_accessControl_{index}",
        "description": "Privileged function cannot be called by arbitrary address",
        "body": (
            "function check_accessControl_{index}(address caller) public {{\n"
            "        vm.assume(caller != address(this));\n"
            "        vm.prank(caller);\n"
            "        // Attempt to call the restricted function as non-owner\n"
            "        // try target.{function}() {{}} catch {{ return; }}\n"
            "        // If we reach here, access control is missing\n"
            "        // assert(false);\n"
            "        assert(true);  // TODO: customize for specific function\n"
            "    }}"
        ),
    },
    "flash_loan": {
        "name": "check_noFlashLoanExploit_{index}",
        "description": "No flash loan exploit: invariants hold within single tx",
        "body": (
            "function check_noFlashLoanExploit_{index}(uint256 loanAmount) public {{\n"
            "        vm.assume(loanAmount > 0 && loanAmount < type(uint128).max);\n"
            "        // Snapshot state before\n"
            "        // uint256 totalBefore = target.totalAssets();\n"
            "        // Simulate flash loan + interaction\n"
            "        // try target.{function}(loanAmount) {{}} catch {{}}\n"
            "        // uint256 totalAfter = target.totalAssets();\n"
            "        // No value should be extractable\n"
            "        // assert(totalAfter >= totalBefore);\n"
            "        assert(true);  // TODO: customize for specific flash loan vector\n"
            "    }}"
        ),
    },
    "rounding_error": {
        "name": "check_noRoundingLoss_{index}",
        "description": "No rounding error that loses user funds",
        "body": (
            "function check_noRoundingLoss_{index}(uint256 amount) public {{\n"
            "        vm.assume(amount > 0 && amount < type(uint128).max);\n"
            "        // Deposit then withdraw should return approximately same amount\n"
            "        // uint256 shares = target.deposit(amount, address(this));\n"
            "        // uint256 redeemed = target.redeem(shares, address(this), address(this));\n"
            "        // Allow 1 wei rounding\n"
            "        // assert(redeemed >= amount - 1);\n"
            "        assert(true);  // TODO: customize for specific rounding path\n"
            "    }}"
        ),
    },
}

# Default template for vulnerability types without a specific mapping
_DEFAULT_PROPERTY_TEMPLATE = {
    "name": "check_property_{index}",
    "description": "Symbolic verification of finding: {title}",
    "body": (
        "function check_property_{index}(uint256 x) public {{\n"
        "        vm.assume(x > 0 && x < type(uint128).max);\n"
        "        // TODO: Implement symbolic check for: {title}\n"
        "        // Vulnerability type: {vuln_type}\n"
        "        assert(true);\n"
        "    }}"
    ),
}


# ---------------------------------------------------------------------------
# Generator
# ---------------------------------------------------------------------------

class HalmosPropertyGenerator:
    """Convert audit findings and invariants into Halmos symbolic test properties."""

    def generate_from_findings(
        self,
        findings: List[Dict[str, Any]],
        contract_name: str,
        contract_path: str = "",
    ) -> Optional[HalmosTestSuite]:
        """Generate Halmos properties from vulnerability findings.

        Args:
            findings: List of vulnerability dicts (must have at least
                     ``vulnerability_type`` and ``title`` keys).
            contract_name: Name of the contract under test.
            contract_path: Import path for the contract.

        Returns:
            HalmosTestSuite or None if no properties could be generated.
        """
        if not findings:
            return None

        properties: List[HalmosProperty] = []
        for i, finding in enumerate(findings):
            prop = self._finding_to_property(finding, i)
            if prop:
                properties.append(prop)

        if not properties:
            return None

        import_path = contract_path or f"src/{contract_name}.sol"
        test_contract_name = f"{contract_name}HalmosTest"

        return HalmosTestSuite(
            contract_name=test_contract_name,
            target_contract=contract_name,
            target_import_path=import_path,
            properties=properties,
        )

    def generate_from_invariants(
        self,
        invariants: List[Any],
        contract_name: str,
        contract_path: str = "",
    ) -> Optional[HalmosTestSuite]:
        """Generate Halmos properties from extracted invariants.

        Args:
            invariants: List of Invariant objects (from InvariantEngine).
            contract_name: Name of the contract under test.
            contract_path: Import path for the contract.

        Returns:
            HalmosTestSuite or None if no testable invariants.
        """
        if not invariants:
            return None

        properties: List[HalmosProperty] = []
        for i, inv in enumerate(invariants):
            prop = self._invariant_to_property(inv, i)
            if prop:
                properties.append(prop)

        if not properties:
            return None

        import_path = contract_path or f"src/{contract_name}.sol"
        test_contract_name = f"{contract_name}HalmosTest"

        return HalmosTestSuite(
            contract_name=test_contract_name,
            target_contract=contract_name,
            target_import_path=import_path,
            properties=properties,
        )

    # ------------------------------------------------------------------
    # Internal conversion helpers
    # ------------------------------------------------------------------

    def _finding_to_property(
        self,
        finding: Dict[str, Any],
        index: int,
    ) -> Optional[HalmosProperty]:
        """Convert a single vulnerability finding to a HalmosProperty."""
        vuln_type = self._normalize_vuln_type(
            finding.get("vulnerability_type", "")
        )
        title = finding.get("title", finding.get("description", "Unknown"))
        finding_id = finding.get("id", f"F-{index}")
        function_name = finding.get("function", "unknownFunction")

        template = _VULN_PROPERTY_TEMPLATES.get(vuln_type, _DEFAULT_PROPERTY_TEMPLATE)

        func_name = template["name"].format(index=index)
        description = template["description"].format(
            title=title, vuln_type=vuln_type, index=index,
        )
        body = template["body"].format(
            index=index,
            function=function_name,
            title=title,
            vuln_type=vuln_type,
        )

        return HalmosProperty(
            function_name=func_name,
            function_body=body,
            description=description,
            related_finding_id=finding_id,
            property_type="safety",
        )

    def _invariant_to_property(
        self,
        invariant: Any,
        index: int,
    ) -> Optional[HalmosProperty]:
        """Convert an Invariant dataclass to a HalmosProperty."""
        inv_id = getattr(invariant, "id", f"INV-{index}")
        description = getattr(invariant, "description", "")
        expression = getattr(invariant, "solidity_expression", "")

        # Generate function name from invariant id
        safe_name = re.sub(r"[^a-zA-Z0-9_]", "_", inv_id).lower()
        func_name = f"check_{safe_name}"

        if expression:
            body = (
                f"function {func_name}(uint256 x) public view {{\n"
                f"        vm.assume(x > 0);\n"
                f"        // Invariant: {description}\n"
                f"        assert({expression});\n"
                f"    }}"
            )
        else:
            body = (
                f"function {func_name}(uint256 x) public view {{\n"
                f"        vm.assume(x > 0);\n"
                f"        // TODO: Implement check for invariant: {description}\n"
                f"        assert(true);\n"
                f"    }}"
            )

        return HalmosProperty(
            function_name=func_name,
            function_body=body,
            description=description,
            related_finding_id=inv_id,
            property_type="invariant",
        )

    @staticmethod
    def _normalize_vuln_type(raw: str) -> str:
        """Normalize vulnerability type string to a known template key."""
        raw_lower = raw.lower().replace("-", "_").replace(" ", "_")

        mappings = {
            "reentrancy": "reentrancy",
            "reentrant": "reentrancy",
            "re_entrancy": "reentrancy",
            "integer_overflow": "integer_overflow",
            "overflow": "integer_overflow",
            "underflow": "integer_overflow",
            "arithmetic": "integer_overflow",
            "unchecked_math": "integer_overflow",
            "share_inflation": "share_inflation",
            "first_deposit": "share_inflation",
            "vault_inflation": "share_inflation",
            "donation_attack": "share_inflation",
            "price_manipulation": "price_manipulation",
            "oracle_manipulation": "price_manipulation",
            "oracle": "price_manipulation",
            "spot_price": "price_manipulation",
            "access_control": "access_control",
            "missing_access_control": "access_control",
            "unauthorized": "access_control",
            "privilege_escalation": "access_control",
            "flash_loan": "flash_loan",
            "flash_loan_attack": "flash_loan",
            "flashloan": "flash_loan",
            "rounding_error": "rounding_error",
            "rounding": "rounding_error",
            "precision_loss": "rounding_error",
            "truncation": "rounding_error",
        }

        for key, value in mappings.items():
            if key in raw_lower:
                return value

        return raw_lower
