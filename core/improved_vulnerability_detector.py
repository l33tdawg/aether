"""
Improved vulnerability detector for AetherAudit with reduced false positives.
Implements context-aware pattern detection and validation.
"""

import re
import ast
from typing import Dict, List, Tuple, Any, Optional
from dataclasses import dataclass


@dataclass
class VulnerabilityMatch:
    """Represents a detected vulnerability."""
    vulnerability_type: str
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    swc_id: str = ""
    category: str = ""
    context: Dict[str, Any] = None

    def __post_init__(self):
        if self.context is None:
            self.context = {}


class ImprovedVulnerabilityDetector:
    """Improved vulnerability detection with context-aware validation."""

    def __init__(self):
        self.patterns = self._initialize_patterns()
        self.contract_context = {}
        self.is_delegatecall_target = False

    def set_contract_context(self, context: Dict[str, Any]):
        """Set contract analysis context for better vulnerability validation."""
        self.contract_context = context

    def _initialize_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize vulnerability detection patterns with improved specificity."""
        return {
            'reentrancy': [
                {
                    'pattern': r'\.call\s*\{[^}]*value\s*:\s*[^}]*\}',
                    'description': 'External call with value transfer (potential reentrancy)',
                    'severity': 'high',
                    'confidence': 0.8,
                    'swc_id': 'SWC-107',
                    'category': 'reentrancy',
                    'requires_context': True
                },
                {
                    'pattern': r'call\.value\s*\(',
                    'description': 'Call.value() pattern (older Solidity reentrancy)',
                    'severity': 'high',
                    'confidence': 0.9,
                    'swc_id': 'SWC-107',
                    'category': 'reentrancy',
                    'requires_context': False
                }
            ],
            'access_control': [
                {
                    'pattern': r'function\s+\w+\s*\([^)]*\)\s*(public|external)',
                    'description': 'Public/external function (check for access control)',
                    'severity': 'medium',
                    'confidence': 0.6,
                    'swc_id': 'SWC-105',
                    'category': 'access_control',
                    'requires_context': True
                }
            ],
            'arithmetic': [
                {
                    'pattern': r'(\+\+|--|\+=|--=|\*=|\/=)',
                    'description': 'Arithmetic operation (potential overflow)',
                    'severity': 'medium',
                    'confidence': 0.7,
                    'swc_id': 'SWC-101',
                    'category': 'arithmetic',
                    'requires_context': True
                }
            ],
            'unchecked_calls': [
                {
                    'pattern': r'(\w+)\.call\s*\([^)]*\)\s*;',
                    'description': 'Low-level call (check for validation)',
                    'severity': 'high',
                    'confidence': 0.8,
                    'swc_id': 'SWC-104',
                    'category': 'unchecked_calls',
                    'requires_context': True
                }
            ],
            'time_manipulation': [
                {
                    'pattern': r'block\.timestamp',
                    'description': 'Use of block.timestamp (check for critical logic)',
                    'severity': 'medium',
                    'confidence': 0.6,
                    'swc_id': 'SWC-116',
                    'category': 'time_manipulation',
                    'requires_context': True
                }
            ]
        }

    def analyze_contract(self, contract_path: str, content: str) -> List[VulnerabilityMatch]:
        """
        Analyze a smart contract for vulnerabilities with improved false positive reduction.
        """
        self.contract_context = {'contract_content': content, 'contract_path': contract_path}
        
        # Detect if this contract is designed as a delegatecall target
        self.is_delegatecall_target = self._is_delegatecall_target_contract(content)
        
        vulnerabilities = []
        lines = content.split('\n')
        
        # First pass: detect potential vulnerabilities
        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info['pattern']
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                
                for match in regex.finditer(content):
                    line_number = content[:match.start()].count('\n') + 1
                    
                    # Extract code snippet with context
                    start_line = max(0, line_number - 3)
                    end_line = min(len(lines), line_number + 3)
                    code_snippet = '\n'.join(lines[start_line:end_line])
                    
                    vulnerability = VulnerabilityMatch(
                        vulnerability_type=vuln_type,
                        severity=pattern_info['severity'],
                        confidence=pattern_info['confidence'],
                        line_number=line_number,
                        description=pattern_info['description'],
                        code_snippet=code_snippet,
                        swc_id=pattern_info['swc_id'],
                        category=pattern_info['category'],
                        context={'pattern_match': match.group(), 'requires_context': pattern_info.get('requires_context', False)}
                    )
                    
                    # Apply context-aware validation
                    if self._validate_vulnerability_context(vulnerability, content, lines):
                        vulnerabilities.append(vulnerability)
        
        # Second pass: additional semantic analysis
        vulnerabilities.extend(self._analyze_semantic_patterns(content, lines))
        
        # Filter out duplicates and low-confidence findings
        vulnerabilities = self._filter_duplicates(vulnerabilities)
        vulnerabilities = [v for v in vulnerabilities if v.confidence > 0.5]
        
        print(f"ðŸ” Improved pattern detection found {len(vulnerabilities)} vulnerabilities:")
        for vuln in vulnerabilities:
            print(f"  - {vuln.vulnerability_type} at line {vuln.line_number}: {vuln.description[:50]}...")
        
        return vulnerabilities

    def _validate_vulnerability_context(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Context-aware validation to reduce false positives."""
        vuln_type = vulnerability.vulnerability_type
        line_number = vulnerability.line_number
        
        if line_number > len(lines):
            return False
            
        line_content = lines[line_number - 1].strip()
        
        # Skip comments and empty lines
        if line_content.startswith('//') or line_content.startswith('/*') or not line_content:
            return False
        
        # Skip constructors and interfaces
        if self._is_in_constructor_or_interface(content, line_number):
            return False
        
        # Type-specific validation
        if vuln_type == 'reentrancy':
            return self._validate_reentrancy(vulnerability, content, lines)
        elif vuln_type == 'access_control':
            return self._validate_access_control(vulnerability, content, lines)
        elif vuln_type == 'arithmetic':
            return self._validate_arithmetic(vulnerability, content, lines)
        elif vuln_type == 'unchecked_calls':
            return self._validate_unchecked_calls(vulnerability, content, lines)
        elif vuln_type == 'time_manipulation':
            return self._validate_time_manipulation(vulnerability, content, lines)
        
        return True

    def _validate_reentrancy(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Validate reentrancy vulnerabilities with context."""
        line_number = vulnerability.line_number
        line_content = lines[line_number - 1]
        
        # Check if this is in a view/pure function
        if self._is_in_view_or_pure_function(content, line_number):
            return False
        
        # Check for reentrancy guards
        function_context = self._get_function_context(content, line_number)
        if function_context and 'nonReentrant' in function_context:
            return False
        
        # Check if the call is properly guarded
        context_after = content[content.find(line_content):content.find(line_content) + 500]
        if any(guard in context_after for guard in ['require(', 'if (!', 'assert(']):
            return False
        
        # Check if this is a legitimate external call pattern
        if '.call{' in line_content and 'value:' in line_content:
            # This is a legitimate external call with value - flag it
            return True
        
        return False

    def _validate_access_control(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Validate access control vulnerabilities with enhanced logic."""
        line_number = vulnerability.line_number
        line_content = lines[line_number - 1]
        
        # Skip if this is a delegatecall target contract (access control is in proxy/caller)
        if self.is_delegatecall_target:
            return False
        
        # Skip if this is a library function (access control is in calling contract)
        if self._is_library_context(content, line_number):
            return False
        
        # Skip if this is an abstract/virtual function (implementations add access control)
        if 'virtual' in line_content and ('abstract' in content[:line_number*100] or not '{' in line_content):
            return False
        
        # Skip if function has access control modifiers
        if any(modifier in line_content for modifier in ['onlyOwner', 'onlyRole', 'onlyAdmin', 'modifier']):
            return False
        
        # Skip internal/private functions
        if any(visibility in line_content for visibility in ['internal', 'private']):
            return False
        
        # Skip view/pure functions (usually don't need access control)
        if any(modifier in line_content for modifier in ['view', 'pure']):
            return False
        
        # Check if function body has access control
        function_body = self._get_function_body(content, line_number)
        if function_body and any(guard in function_body for guard in ['require(msg.sender', 'require(_msgSender()', 'hasRole(']):
            return False
        
        # Only flag external/public functions without access control
        return any(visibility in line_content for visibility in ['public', 'external'])
    
    def _is_library_context(self, content: str, line_number: int) -> bool:
        """Check if code is in a library rather than a contract."""
        lines = content.split('\n')
        
        # Look backwards from the line to find contract/library declaration
        for i in range(line_number - 1, max(0, line_number - 100), -1):
            if i < len(lines):
                line = lines[i].strip()
                # Found library declaration
                if re.search(r'^\s*library\s+\w+', line):
                    return True
                # Found contract declaration (not a library)
                if re.search(r'^\s*contract\s+\w+', line):
                    return False
        
        return False

    def _validate_arithmetic(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Validate arithmetic vulnerabilities with context."""
        line_number = vulnerability.line_number
        line_content = lines[line_number - 1]
        
        # Check if using SafeMath or Solidity 0.8+
        if 'SafeMath' in content or 'pragma solidity ^0.8' in content or 'pragma solidity >=0.8' in content:
            return False
        
        # Check if operation is in unchecked block
        context_before = content[:content.find(line_content)]
        if 'unchecked' in context_before[-200:]:  # Check last 200 chars before this line
            return False
        
        # Check if this is a simple increment/decrement that's safe
        if re.match(r'^\s*\w+\+\+\s*;?\s*$', line_content) or re.match(r'^\s*\w+--\s*;?\s*$', line_content):
            return False
        
        return True

    def _validate_unchecked_calls(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Validate unchecked call vulnerabilities."""
        line_number = vulnerability.line_number
        line_content = lines[line_number - 1]
        
        # Check if the call result is checked in subsequent lines
        context_after = content[content.find(line_content):content.find(line_content) + 300]
        if any(check in context_after for check in ['require(', 'if (!', 'assert(', 'success']):
            return False
        
        # Check if this is a structured call with return value handling
        if '.call{' in line_content:
            return False  # Structured calls usually handle return values
        
        return True

    def _validate_time_manipulation(self, vulnerability: VulnerabilityMatch, content: str, lines: List[str]) -> bool:
        """Validate time manipulation vulnerabilities."""
        line_number = vulnerability.line_number
        line_content = lines[line_number - 1]
        
        # Check if this is in a view/pure function
        if self._is_in_view_or_pure_function(content, line_number):
            return False
        
        # Check if timestamp is used for non-critical purposes
        if any(keyword in line_content.lower() for keyword in ['emit', 'log', 'event', 'comment']):
            return False
        
        # Check if there's a reasonable time buffer
        if re.search(r'block\.timestamp\s*[+\-]\s*\d+', line_content):
            return False  # Has time buffer
        
        return True

    def _is_in_constructor_or_interface(self, content: str, line_number: int) -> bool:
        """Check if line is in constructor or interface."""
        lines = content.split('\n')
        if line_number > len(lines):
            return False
        
        # Look backwards for contract/interface/constructor keywords
        for i in range(max(0, line_number - 20), line_number):
            line = lines[i].strip()
            if any(keyword in line.lower() for keyword in ['constructor', 'interface', 'abstract']):
                return True
        
        return False

    def _is_in_view_or_pure_function(self, content: str, line_number: int) -> bool:
        """Check if line is in a view or pure function."""
        lines = content.split('\n')
        
        # Look backwards for function declaration
        for i in range(max(0, line_number - 10), line_number):
            line = lines[i].strip()
            if line.startswith('function'):
                return 'view' in line or 'pure' in line
        
        return False

    def _get_function_context(self, content: str, line_number: int) -> Optional[str]:
        """Get the function signature containing the line."""
        lines = content.split('\n')
        
        # Look backwards for function declaration
        for i in range(max(0, line_number - 10), line_number):
            line = lines[i].strip()
            if line.startswith('function'):
                return line
        
        return None

    def _get_function_body(self, content: str, line_number: int) -> Optional[str]:
        """Get the function body starting from the line."""
        lines = content.split('\n')
        
        # Find function start
        func_start = None
        for i in range(max(0, line_number - 10), line_number):
            if lines[i].strip().startswith('function'):
                func_start = i
                break
        
        if func_start is None:
            return None
        
        # Extract function body (first 20 lines)
        end_line = min(len(lines), func_start + 20)
        return '\n'.join(lines[func_start:end_line])

    def _analyze_semantic_patterns(self, content: str, lines: List[str]) -> List[VulnerabilityMatch]:
        """Analyze semantic patterns that require more complex detection."""
        vulnerabilities = []
        
        # Check for dangerous function patterns
        function_pattern = r'function\s+(\w+)\s*\([^)]*\)\s*(public|external|internal|private)?\s*(view|pure|payable)?'
        
        for match in re.finditer(function_pattern, content, re.IGNORECASE):
            func_name = match.group(1)
            visibility = match.group(2) or 'public'
            modifier = match.group(3) or ''
            func_line = content[:match.start()].count('\n') + 1
            
            # Check for dangerous payable functions without proper validation
            if 'payable' in modifier and func_name.lower() in ['withdraw', 'transfer', 'deposit']:
                func_body = self._get_function_body(content, func_line)
                if func_body and not any(guard in func_body for guard in ['require(', 'if (', 'modifier']):
                    vulnerability = VulnerabilityMatch(
                        vulnerability_type='dangerous_payable_function',
                        severity='high',
                        confidence=0.8,
                        line_number=func_line,
                        description=f'Payable function {func_name} lacks proper validation',
                        code_snippet=lines[func_line-1] if func_line <= len(lines) else '',
                        swc_id='SWC-105',
                        category='access_control'
                    )
                    vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    def _filter_duplicates(self, vulnerabilities: List[VulnerabilityMatch]) -> List[VulnerabilityMatch]:
        """Filter out duplicate vulnerabilities."""
        seen = set()
        filtered = []
        
        for vuln in vulnerabilities:
            # Create a unique key based on type, line, and description
            key = (vuln.vulnerability_type, vuln.line_number, vuln.description[:50])
            if key not in seen:
                seen.add(key)
                filtered.append(vuln)
        
        return filtered

    def _is_delegatecall_target_contract(self, content: str) -> bool:
        """
        Detect if a contract is designed to be used as a delegatecall target.
        
        Indicators:
        1. Contract is referenced in delegatecall calls from another contract
        2. Contract has comment indicating it's for delegatecall/proxy use
        3. Contract name includes Executor, Module, Logic, Implementation
        4. All external functions lack access control but contract has invoke pattern
        
        Returns:
            bool: True if contract is designed for delegatecall usage
        """
        # Check contract name patterns
        contract_name_patterns = [
            r'contract\s+\w*Executor\w*',
            r'contract\s+\w*Module\w*',
            r'contract\s+\w*Logic\w*',
            r'contract\s+\w*Implementation\w*',
            r'contract\s+\w*Facet\w*',
        ]
        
        for pattern in contract_name_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                # Found a delegatecall target name pattern
                # Verify this is indeed used for delegation
                
                # Check for delegatecall usage comments
                delegatecall_comments = [
                    r'delegatecall',
                    r'will run within.*using.*delegatecall',
                    r'code which will.*delegatecall',
                    r'executed.*delegatecall',
                    r'logic contract',
                    r'implementation contract',
                ]
                
                for comment_pattern in delegatecall_comments:
                    if re.search(comment_pattern, content, re.IGNORECASE):
                        return True
                
                # Check if there's a corresponding proxy/agent contract pattern
                # Look for evidence that another contract will call this via delegatecall
                proxy_indicators = [
                    r'\.delegatecall\s*\(',
                    r'\.invoke\s*\(',  # Common pattern in proxy contracts
                    r'_delegate\s*\(',
                ]
                
                # If the contract name suggests delegatecall AND there are delegatecall indicators
                # in comments/documentation, it's likely a delegatecall target
                has_delegatecall_indicators = any(
                    re.search(pattern, content, re.IGNORECASE) 
                    for pattern in delegatecall_comments
                )
                
                if has_delegatecall_indicators:
                    return True
        
        # Check for library contracts (also delegatecall targets)
        if re.search(r'library\s+\w+\s*\{', content):
            return True
        
        return False

    def get_vulnerability_summary(self, vulnerabilities: List[VulnerabilityMatch]) -> Dict[str, Any]:
        """Generate a summary of detected vulnerabilities."""
        summary = {
            'total_vulnerabilities': len(vulnerabilities),
            'by_severity': {
                'critical': 0,
                'high': 0,
                'medium': 0,
                'low': 0
            },
            'by_category': {},
            'by_swc': {},
            'top_issues': []
        }
        
        for vuln in vulnerabilities:
            # Count by severity
            summary['by_severity'][vuln.severity] += 1
            
            # Count by category
            category = vuln.category or 'other'
            summary['by_category'][category] = summary['by_category'].get(category, 0) + 1
            
            # Count by SWC ID
            if vuln.swc_id:
                summary['by_swc'][vuln.swc_id] = summary['by_swc'].get(vuln.swc_id, 0) + 1
        
        # Get top issues (highest confidence first)
        sorted_vulns = sorted(vulnerabilities, key=lambda x: x.confidence, reverse=True)
        summary['top_issues'] = sorted_vulns[:10]
        
        return summary
