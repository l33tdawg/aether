"""
Exploit Knowledge Base — Structured database of 75+ real-world exploit patterns.

Replaces the static 10-pattern ZERO_DAY_VULNERABILITY_PATTERNS with a
categorized, filterable collection. Each pattern includes code indicators,
missing protections, exploit mechanism, real-world examples, and archetype
applicability.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set

from core.protocol_archetypes import ProtocolArchetype


class ExploitCategory(Enum):
    INFLATION_SHARE = "inflation_share"
    REENTRANCY = "reentrancy"
    ORACLE = "oracle"
    GOVERNANCE = "governance"
    BRIDGE = "bridge"
    PRECISION_ROUNDING = "precision_rounding"
    ACCESS_CONTROL = "access_control"
    ECONOMIC_DEFI = "economic_defi"
    LOGIC = "logic"
    CROSS_CONTRACT = "cross_contract"
    SIGNATURE_AUTH = "signature_auth"
    TOKEN_INTEGRATION = "token_integration"
    PROXY_UPGRADE = "proxy_upgrade"
    TYPE_SAFETY = "type_safety"


@dataclass
class ExploitPattern:
    """A single real-world exploit pattern."""
    id: str
    name: str
    category: ExploitCategory
    severity: str  # critical / high / medium
    description: str
    code_indicators: List[str]
    missing_protections: List[str]
    exploit_mechanism: str
    real_world_examples: List[str]
    applicable_archetypes: List[ProtocolArchetype]
    detection_prompt: str
    # Optional extra fields
    capital_required: str = "flash loan (0)"
    atomic: bool = True


# ---------------------------------------------------------------------------
# Pattern definitions — 75+ patterns across 14 categories
# ---------------------------------------------------------------------------

_ALL_PATTERNS: List[ExploitPattern] = [
    # ===== INFLATION / SHARE ATTACKS (6) =====
    ExploitPattern(
        id="INF-001",
        name="ERC-4626 First Depositor Inflation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="Attacker deposits 1 wei, donates large amount directly to inflate share price. Subsequent depositors receive 0 shares due to rounding.",
        code_indicators=["ERC4626", "totalAssets()", "deposit(", "totalSupply == 0"],
        missing_protections=["_decimalsOffset()", "virtual shares/assets", "minimum initial deposit"],
        exploit_mechanism="Deposit 1 wei → donate 10^18 tokens directly → share price = 10^18. Next depositor with < 10^18 gets 0 shares.",
        real_world_examples=["Multiple ERC-4626 vault exploits (2022-2023)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Check for _decimalsOffset(), virtual shares, or minimum deposit. If absent and vault uses ERC-4626, this is exploitable.",
    ),
    ExploitPattern(
        id="INF-002",
        name="LP Token Inflation via First Mint",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="First liquidity provider manipulates initial LP token price, extracting value from subsequent providers.",
        code_indicators=["totalSupply == 0", "mint(", "sqrt(", "MINIMUM_LIQUIDITY"],
        missing_protections=["MINIMUM_LIQUIDITY burn", "dead shares"],
        exploit_mechanism="First LP provides tiny liquidity at manipulated ratio, then front-runs normal LPs to extract value.",
        real_world_examples=["Uniswap V2 mitigation (MINIMUM_LIQUIDITY)"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM],
        detection_prompt="Does pool burn MINIMUM_LIQUIDITY or equivalent on first mint? Without it, first LP can manipulate share price.",
    ),
    ExploitPattern(
        id="INF-003",
        name="Donation-Based Share Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Direct token transfer to vault/pool inflates totalAssets without minting shares, manipulating exchange rate.",
        code_indicators=["totalAssets()", "balanceOf(address(this))", "convertToShares"],
        missing_protections=["Internal accounting separate from balanceOf", "virtual balance"],
        exploit_mechanism="Transfer tokens directly → totalAssets increases → share price inflated → depositors get fewer shares.",
        real_world_examples=["Various vault implementations using balanceOf for accounting"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="Does totalAssets() or reserve calculation use balanceOf(address(this))? Direct transfers can manipulate it.",
    ),
    ExploitPattern(
        id="INF-004",
        name="Virtual Balance Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Protocol tracks virtual balances that can diverge from actual balances, creating accounting gaps.",
        code_indicators=["_totalAssets", "internalBalance", "virtualBalance"],
        missing_protections=["Reconciliation checks", "balance invariant assertions"],
        exploit_mechanism="Exploit divergence between virtual and actual balance through edge cases in deposit/withdraw paths.",
        real_world_examples=["Various DeFi accounting exploits"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does the protocol maintain virtual balances? Can they diverge from actual token balances through any code path?",
    ),
    ExploitPattern(
        id="INF-005",
        name="Exchange Rate Flash Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="Flash loan to temporarily manipulate exchange rate between deposit/withdrawal in same transaction.",
        code_indicators=["exchangeRate", "getRate()", "sharePrice"],
        missing_protections=["TWAP for exchange rate", "same-block manipulation checks"],
        exploit_mechanism="Flash loan → manipulate rate → deposit at low rate → restore rate → withdraw at high rate.",
        real_world_examples=["Multiple DeFi flash loan attacks"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM],
        detection_prompt="Can the exchange rate be manipulated within a single transaction? Is rate derived from spot values?",
    ),
    ExploitPattern(
        id="INF-006",
        name="Rebasing Token Integration Mismatch",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Protocol doesn't handle rebasing tokens (like stETH) whose balance changes without transfers.",
        code_indicators=["balanceOf", "totalAssets", "rebase"],
        missing_protections=["Wrapped token usage (wstETH)", "rebase-aware accounting"],
        exploit_mechanism="Balance changes from rebase create accounting discrepancies between protocol's tracked amount and actual.",
        real_world_examples=["Multiple protocols affected by stETH rebasing"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.STAKING],
        detection_prompt="Does the protocol handle rebasing tokens? If it uses balanceOf for accounting, rebasing tokens will cause discrepancies.",
    ),

    # ===== REENTRANCY (7) =====
    ExploitPattern(
        id="RE-001",
        name="Classic ETH Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="critical",
        description="ETH transfer via call{value:} allows recipient to re-enter before state update.",
        code_indicators=[".call{value:", ".transfer(", ".send(", "withdraw("],
        missing_protections=["nonReentrant modifier", "checks-effects-interactions pattern"],
        exploit_mechanism="call{value: amount}('') triggers fallback → re-enters withdraw() → drains funds.",
        real_world_examples=["The DAO ($60M, 2016)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.TOKEN, ProtocolArchetype.ORACLE, ProtocolArchetype.LIQUID_STAKING, ProtocolArchetype.PERPETUAL_DEX, ProtocolArchetype.CDP_STABLECOIN, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Does any function send ETH before updating state? Check for call{value:} or transfer() before balance/state updates.",
    ),
    ExploitPattern(
        id="RE-002",
        name="Read-Only Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="View functions return stale state during external callback, exploited by other protocols reading the state.",
        code_indicators=["balanceOf(", "totalSupply(", "getReserves(", "view", "nonReentrant"],
        missing_protections=["Reentrancy guard on view functions", "state update before external calls"],
        exploit_mechanism="During callback, view function returns pre-update state → external protocol uses stale price → profit.",
        real_world_examples=["Curve/Vyper read-only reentrancy (2023)", "Sentiment Protocol"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.TOKEN, ProtocolArchetype.ORACLE, ProtocolArchetype.LIQUID_STAKING, ProtocolArchetype.PERPETUAL_DEX, ProtocolArchetype.CDP_STABLECOIN, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Can view functions return stale state during a callback? Are external protocols reading this contract's state during its operations?",
    ),
    ExploitPattern(
        id="RE-003",
        name="Cross-Function Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Function A has reentrancy guard but Function B modifies same state without it.",
        code_indicators=["nonReentrant", "ReentrancyGuard"],
        missing_protections=["Consistent nonReentrant across all state-modifying functions"],
        exploit_mechanism="During Function A callback, call unprotected Function B to manipulate shared state.",
        real_world_examples=["Lendf.Me ($25M)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.TOKEN, ProtocolArchetype.ORACLE, ProtocolArchetype.LIQUID_STAKING, ProtocolArchetype.PERPETUAL_DEX, ProtocolArchetype.CDP_STABLECOIN, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Do ALL functions that modify shared state have nonReentrant? Check for inconsistent guard application.",
    ),
    ExploitPattern(
        id="RE-004",
        name="Cross-Contract Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Reentrancy guard is per-contract, not cross-contract. Attacker re-enters a different contract in the protocol.",
        code_indicators=["nonReentrant", "external call", "cross-contract"],
        missing_protections=["Global reentrancy lock across protocol contracts", "shared lock"],
        exploit_mechanism="Contract A calls external → callback re-enters Contract B → B reads A's stale state.",
        real_world_examples=["Fei Protocol cross-contract reentrancy"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.TOKEN, ProtocolArchetype.ORACLE, ProtocolArchetype.LIQUID_STAKING, ProtocolArchetype.PERPETUAL_DEX, ProtocolArchetype.CDP_STABLECOIN, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Does the protocol use a shared reentrancy lock across contracts, or per-contract? Can reentrancy in one contract affect another?",
    ),
    ExploitPattern(
        id="RE-005",
        name="ERC-777 Token Hook Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="ERC-777 tokens trigger tokensReceived/tokensToSend hooks during transfers, enabling reentrancy.",
        code_indicators=["ERC777", "tokensReceived", "tokensToSend", "IERC1820"],
        missing_protections=["nonReentrant on all token-receiving functions", "ERC-777 awareness"],
        exploit_mechanism="Token transfer triggers hook → re-enter protocol before state update.",
        real_world_examples=["imBTC Uniswap pool drain (2020)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.TOKEN, ProtocolArchetype.ORACLE, ProtocolArchetype.LIQUID_STAKING, ProtocolArchetype.PERPETUAL_DEX, ProtocolArchetype.CDP_STABLECOIN, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Does the protocol accept arbitrary ERC-20 tokens? ERC-777 tokens have transfer hooks that enable reentrancy.",
    ),
    ExploitPattern(
        id="RE-006",
        name="ERC-1155 Callback Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="ERC-1155 safeTransferFrom triggers onERC1155Received callback before completing.",
        code_indicators=["ERC1155", "safeTransferFrom", "onERC1155Received", "safeBatchTransferFrom"],
        missing_protections=["nonReentrant on NFT operations", "callback guard"],
        exploit_mechanism="safeTransferFrom triggers callback → re-enter before state update.",
        real_world_examples=["Various NFT marketplace exploits"],
        applicable_archetypes=[ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Does the protocol handle ERC-1155 tokens? safeTransferFrom has a callback that can enable reentrancy.",
    ),
    ExploitPattern(
        id="RE-007",
        name="Flash Loan Callback Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Flash loan callback allows re-entering the lending protocol before loan state is finalized.",
        code_indicators=["flashLoan(", "onFlashLoan(", "executeOperation(", "IERC3156"],
        missing_protections=["State finalization before callback", "reentrancy guard on flash loan"],
        exploit_mechanism="During flash loan callback, re-enter borrow/deposit to manipulate collateral state.",
        real_world_examples=["Multiple flash loan reentrancy exploits"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM],
        detection_prompt="Is flash loan state finalized before the callback? Can the callback re-enter protocol functions?",
    ),

    # ===== ORACLE (5) =====
    ExploitPattern(
        id="ORC-001",
        name="Spot Price Manipulation",
        category=ExploitCategory.ORACLE,
        severity="critical",
        description="Using spot AMM reserves as price oracle allows flash loan manipulation.",
        code_indicators=["getReserves(", "reserve0", "reserve1", "balanceOf", "price ="],
        missing_protections=["TWAP oracle", "Chainlink price feed", "multi-source oracle"],
        exploit_mechanism="Flash loan → swap to manipulate reserves → read manipulated price → profit → repay.",
        real_world_examples=["Cream Finance ($130M)", "Harvest Finance ($34M)", "Warp Finance"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Is the price derived from spot AMM reserves or balanceOf? These are manipulable via flash loans.",
    ),
    ExploitPattern(
        id="ORC-002",
        name="TWAP Manipulation",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="Short-window TWAP can be manipulated by sustained trading pressure across multiple blocks.",
        code_indicators=["TWAP", "observe(", "consult(", "twapInterval", "cumulativePrice"],
        missing_protections=["Sufficiently long TWAP window", "price deviation circuit breaker"],
        exploit_mechanism="Sustained trading pressure across TWAP window to shift average price.",
        real_world_examples=["Inverse Finance ($15M TWAP manipulation)"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.ORACLE],
        detection_prompt="What is the TWAP window duration? Short windows (< 30 min) are manipulable with sufficient capital.",
        capital_required="substantial (multi-block)",
        atomic=False,
    ),
    ExploitPattern(
        id="ORC-003",
        name="Oracle Staleness Exploitation",
        category=ExploitCategory.ORACLE,
        severity="critical",
        description="Stale price data from oracle allows actions at outdated prices.",
        code_indicators=["latestRoundData(", "updatedAt", "answeredInRound", "roundId"],
        missing_protections=["Staleness check", "heartbeat validation", "require(updatedAt > block.timestamp - MAX_DELAY)"],
        exploit_mechanism="Wait for oracle to go stale → execute trades/liquidations at outdated prices.",
        real_world_examples=["Synthetix oracle delay exploit", "Various protocols during Chainlink delays"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.ORACLE],
        detection_prompt="Is latestRoundData() return value checked for staleness? Is updatedAt compared against a maximum age?",
    ),
    ExploitPattern(
        id="ORC-004",
        name="Oracle Decimals Mismatch",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="Different oracle feeds return prices with different decimal scales, causing valuation errors.",
        code_indicators=["decimals()", "priceFeed", "latestRoundData", "10 **"],
        missing_protections=["Explicit decimal normalization", "feed-specific decimal handling"],
        exploit_mechanism="Mismatched decimals cause collateral to be over/under-valued by orders of magnitude.",
        real_world_examples=["Various multi-oracle protocols"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.ORACLE],
        detection_prompt="Does the protocol normalize oracle decimals? Are different feeds assumed to have the same precision?",
    ),
    ExploitPattern(
        id="ORC-005",
        name="L2 Sequencer Downtime Exploitation",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="On L2, sequencer downtime causes stale prices; unfair liquidations when it restarts.",
        code_indicators=["sequencerUptimeFeed", "isSequencerUp", "GRACE_PERIOD"],
        missing_protections=["Sequencer uptime feed check", "grace period after restart"],
        exploit_mechanism="Prices go stale during downtime → sequencer restarts → liquidate positions at stale prices.",
        real_world_examples=["Arbitrum/Optimism sequencer downtime incidents"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.ORACLE],
        detection_prompt="On L2: is sequencer uptime checked? Is there a grace period after restart before allowing liquidations?",
    ),

    # ===== GOVERNANCE (4) =====
    ExploitPattern(
        id="GOV-001",
        name="Flash Loan Governance Attack",
        category=ExploitCategory.GOVERNANCE,
        severity="critical",
        description="Flash loan tokens to gain voting power, create+vote+execute proposal in same transaction.",
        code_indicators=["castVote(", "propose(", "balanceOf", "votingPower", "delegate("],
        missing_protections=["Snapshot-based voting (past block)", "timelock between vote and execution"],
        exploit_mechanism="Flash loan gov tokens → delegate → propose → vote → execute → return tokens.",
        real_world_examples=["Beanstalk Governance ($182M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is voting power snapshot-based (historical block) or current balance? Current balance allows flash loan voting.",
    ),
    ExploitPattern(
        id="GOV-002",
        name="Timelock Bypass",
        category=ExploitCategory.GOVERNANCE,
        severity="critical",
        description="Emergency functions or admin roles bypass timelock, allowing immediate execution.",
        code_indicators=["timelock", "emergency", "bypass", "admin", "owner"],
        missing_protections=["No emergency bypass exists", "multi-sig for emergency", "community veto"],
        exploit_mechanism="Compromised admin uses emergency function to bypass timelock and execute malicious proposal.",
        real_world_examples=["Various DAO governance bypasses"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Are there any functions that bypass the timelock? Can admin/owner execute proposals without delay?",
    ),
    ExploitPattern(
        id="GOV-003",
        name="Quorum Manipulation",
        category=ExploitCategory.GOVERNANCE,
        severity="high",
        description="Low quorum allows minority to pass proposals when participation is low.",
        code_indicators=["quorum", "proposalThreshold", "quorumNumerator"],
        missing_protections=["Dynamic quorum based on participation", "sufficient minimum quorum"],
        exploit_mechanism="Wait for low participation period → propose and vote with minority stake → pass proposal.",
        real_world_examples=["Various DAO low-quorum attacks"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="What is the quorum threshold? Is it dynamic or fixed? Can proposals pass with very low participation?",
        capital_required="governance tokens",
        atomic=False,
    ),
    ExploitPattern(
        id="GOV-004",
        name="Proposal Front-Running",
        category=ExploitCategory.GOVERNANCE,
        severity="medium",
        description="Seeing a proposal in mempool, front-run to gain position before it executes.",
        code_indicators=["execute(", "proposal", "queue("],
        missing_protections=["Private mempool", "commit-reveal voting", "anti-frontrunning delay"],
        exploit_mechanism="See profitable proposal pending → front-run to position before execution → profit from expected state change.",
        real_world_examples=["Various governance proposal front-running"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Can pending governance proposals be front-run? Is there a way to profit from knowing a proposal will execute?",
    ),

    # ===== BRIDGE (5) =====
    ExploitPattern(
        id="BRG-001",
        name="Cross-Chain Message Replay",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Cross-chain messages can be replayed, causing double-spending.",
        code_indicators=["relayMessage(", "executeMessage(", "messageHash", "nonce"],
        missing_protections=["Nonce tracking per message", "executed message bitmap", "unique hash per message"],
        exploit_mechanism="Replay valid message → claim tokens again → drain bridge.",
        real_world_examples=["Nomad Bridge ($190M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="Is each cross-chain message uniquely identified and tracked as executed? Can a valid message be submitted twice?",
    ),
    ExploitPattern(
        id="BRG-002",
        name="Validator Compromise / Insufficient Threshold",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Bridge validator set has insufficient threshold or single points of failure.",
        code_indicators=["verifySignatures(", "threshold", "validator", "multisig"],
        missing_protections=["Sufficient threshold (2/3+)", "validator diversity", "key rotation"],
        exploit_mechanism="Compromise threshold-many validators → forge cross-chain messages → drain bridge.",
        real_world_examples=["Ronin Bridge ($625M, 2022)", "Harmony Horizon ($100M)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="What is the validator threshold? How many validators need to be compromised to forge messages?",
        capital_required="validator compromise",
        atomic=False,
    ),
    ExploitPattern(
        id="BRG-003",
        name="Token Mapping Mismatch",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Token mapping between chains is incorrect or exploitable, allowing minting of unbacked tokens.",
        code_indicators=["tokenMapping", "wrappedToken", "bridgeToken", "canonicalToken"],
        missing_protections=["Verified bidirectional token mapping", "supply consistency"],
        exploit_mechanism="Exploit incorrect mapping to bridge non-existent token → receive real tokens on destination.",
        real_world_examples=["Wormhole Bridge ($320M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="How is the token mapping verified? Can an attacker register a fake token mapping?",
    ),
    ExploitPattern(
        id="BRG-004",
        name="Withdrawal Proof Forgery",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Insufficient proof verification allows forged proofs to claim bridge funds.",
        code_indicators=["proveWithdrawal(", "verifyProof(", "merkleProof", "stateRoot"],
        missing_protections=["Complete merkle proof verification", "trusted state root source"],
        exploit_mechanism="Forge merkle proof → submit to bridge → claim tokens never deposited.",
        real_world_examples=["Various optimistic bridge exploits"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="How are withdrawal proofs verified? Is the merkle root from a trusted source? Can proofs be forged?",
    ),
    ExploitPattern(
        id="BRG-005",
        name="Relay Race Condition",
        category=ExploitCategory.BRIDGE,
        severity="high",
        description="Race condition between relayers allows message to be processed with outdated state.",
        code_indicators=["relayer", "processMessage(", "relayMessage(", "latestBlock"],
        missing_protections=["Sequential message processing", "state root finality check"],
        exploit_mechanism="Submit message with stale state root during relay delay → execute before state updates.",
        real_world_examples=["Various bridge timing attacks"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="Can messages be processed out of order or with stale state? Is there a finality check?",
    ),

    # ===== PRECISION / ROUNDING (4) =====
    ExploitPattern(
        id="PREC-001",
        name="Rounding Direction Exploitation",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Consistent favorable rounding allows value extraction through repeated operations.",
        code_indicators=["mulDiv", "Math.Rounding", "/ ", "convertToShares", "convertToAssets"],
        missing_protections=["Round against user (deposits DOWN, withdrawals UP)", "minimum amounts"],
        exploit_mechanism="Repeated deposit/withdraw with amounts that consistently round in attacker's favor.",
        real_world_examples=["Multiple vault rounding exploits"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL],
        detection_prompt="In deposit/mint, does division round DOWN (against depositor)? In withdraw/redeem, does it round UP (against withdrawer)?",
    ),
    ExploitPattern(
        id="PREC-002",
        name="Phantom Overflow in Unchecked Blocks",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="critical",
        description="Arithmetic inside unchecked{} blocks silently overflows/underflows.",
        code_indicators=["unchecked {", "unchecked{"],
        missing_protections=["Explicit bounds checking inside unchecked", "input validation before unchecked"],
        exploit_mechanism="Craft input that causes overflow inside unchecked → wrap around to unexpected value.",
        real_world_examples=["Various Solidity 0.8+ unchecked block bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.TOKEN],
        detection_prompt="What arithmetic operations are inside unchecked{} blocks? Can any of them overflow/underflow with attacker-controlled inputs?",
    ),
    ExploitPattern(
        id="PREC-003",
        name="Fee-on-Transfer Token Accounting",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Protocol uses transfer amount for accounting instead of actual received amount.",
        code_indicators=["transferFrom(", "amount", "balanceOf"],
        missing_protections=["Pre/post balance delta check", "fee-on-transfer token handling"],
        exploit_mechanism="Deposit fee-on-transfer token → protocol credits full amount → withdraw more than deposited.",
        real_world_examples=["SushiSwap fee-on-transfer issues", "Various DeFi protocols"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="After transferFrom, does the protocol use 'amount' or the actual balance delta for accounting?",
    ),
    ExploitPattern(
        id="PREC-004",
        name="Rebasing Token Balance Drift",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Rebasing token balance changes without transfers, causing accounting drift.",
        code_indicators=["balanceOf", "totalAssets", "shares", "rebase"],
        missing_protections=["Wrapped token usage", "rebase-aware internal accounting"],
        exploit_mechanism="Rebase changes actual balance → protocol's tracked balance diverges → exploitable gap.",
        real_world_examples=["stETH integration issues across multiple protocols"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.STAKING],
        detection_prompt="Does the protocol handle rebasing tokens? Does it track balances internally or rely on balanceOf?",
    ),

    # ===== ACCESS CONTROL (5) =====
    ExploitPattern(
        id="AC-001",
        name="Uninitialized Proxy",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Implementation contract is not initialized, allowing attacker to call initialize() and take ownership.",
        code_indicators=["initialize(", "Initializable", "initializer", "proxy"],
        missing_protections=["_disableInitializers() in constructor", "initialized check"],
        exploit_mechanism="Call initialize() on implementation contract → become owner → selfdestruct or manipulate.",
        real_world_examples=["Wormhole uninitialized proxy", "Audius ($6M)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is the implementation contract initialized? Does the constructor call _disableInitializers()?",
    ),
    ExploitPattern(
        id="AC-002",
        name="Storage Collision in Proxy Upgrade",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="New variables in upgraded implementation collide with existing storage layout.",
        code_indicators=["UUPSUpgradeable", "TransparentProxy", "__gap", "upgradeTo("],
        missing_protections=["Storage gap arrays (__gap)", "append-only storage layout"],
        exploit_mechanism="Upgrade adds new variable → overwrites existing storage → corrupts state (balances, ownership).",
        real_world_examples=["Various proxy upgrade storage collision bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE],
        detection_prompt="Do all base contracts have __gap storage arrays? Is the storage layout append-only across upgrades?",
    ),
    ExploitPattern(
        id="AC-003",
        name="Phantom Function / Selector Collision",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Two functions have the same 4-byte selector, causing proxy to route to wrong implementation.",
        code_indicators=["fallback()", "delegatecall", "selector", "proxy"],
        missing_protections=["Selector collision check", "transparent proxy pattern"],
        exploit_mechanism="Attacker calls function with colliding selector → proxy routes to unintended function.",
        real_world_examples=["Poly Network ($611M) — function selector issues"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Are there any function selector collisions? Does the proxy properly separate admin and user function spaces?",
    ),
    ExploitPattern(
        id="AC-004",
        name="Delegatecall to User-Controlled Target",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Contract delegatecalls to an address controlled by the user.",
        code_indicators=["delegatecall(", "target", "implementation"],
        missing_protections=["Whitelist of valid delegatecall targets", "hardcoded implementation"],
        exploit_mechanism="Pass malicious contract as target → delegatecall executes attacker's code in protocol's context.",
        real_world_examples=["Poly Network ($611M)", "Various proxy exploits"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does any function delegatecall to a user-provided address? Is the target hardcoded or validated?",
    ),
    ExploitPattern(
        id="AC-005",
        name="Missing initialize() Access Control",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="initialize() function lacks access control, allowing anyone to re-initialize after deployment.",
        code_indicators=["initialize(", "initializer", "onlyInitializing"],
        missing_protections=["initializer modifier", "initialized state variable check"],
        exploit_mechanism="Call initialize() again → reset ownership/state → take control.",
        real_world_examples=["Audius ($6M re-initialization)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Can initialize() be called more than once? Does it have the initializer modifier?",
    ),

    # ===== ECONOMIC / DEFI (8) =====
    ExploitPattern(
        id="ECON-001",
        name="Sandwich Attack",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="MEV bot front-runs and back-runs a swap transaction to extract value.",
        code_indicators=["swap(", "amountOutMin", "deadline", "slippage"],
        missing_protections=["Slippage protection (amountOutMin)", "transaction deadline", "private mempool"],
        exploit_mechanism="See pending swap → front-run buy → user swaps at worse price → back-run sell → profit.",
        real_world_examples=["Extremely common MEV attack on all DEXes"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.DEX_ORDERBOOK],
        detection_prompt="Does swap() enforce minimum output amount and deadline? Without both, swaps are vulnerable to sandwich attacks.",
    ),
    ExploitPattern(
        id="ECON-002",
        name="JIT Liquidity Attack",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="medium",
        description="Just-in-time liquidity provision to capture fees from pending large swap.",
        code_indicators=["addLiquidity(", "removeLiquidity(", "mint(", "burn("],
        missing_protections=["Minimum liquidity duration", "fee vesting"],
        exploit_mechanism="See pending large swap → add concentrated liquidity → swap executes → remove liquidity with fees.",
        real_world_examples=["Common on Uniswap V3 concentrated liquidity"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM],
        detection_prompt="Can liquidity be added and removed in the same block? Is there a minimum duration for fee accrual?",
    ),
    ExploitPattern(
        id="ECON-003",
        name="Bad Debt Cascade",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="critical",
        description="Underwater position creates cascading liquidations and socialized bad debt.",
        code_indicators=["liquidat", "healthFactor", "collateral", "borrow(", "shortfall"],
        missing_protections=["Bad debt socialization mechanism", "reserve fund", "position limits"],
        exploit_mechanism="Create leveraged position → price drops fast → liquidation unprofitable → bad debt cascades.",
        real_world_examples=["Euler Finance ($197M)", "Venus Protocol bad debt"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="What happens when liquidation doesn't cover debt? Is there a bad debt handling or socialization mechanism?",
    ),
    ExploitPattern(
        id="ECON-004",
        name="Interest Rate Manipulation",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Flash loan manipulates utilization rate to spike interest for existing borrowers.",
        code_indicators=["interestRate", "utilization", "borrowRate", "totalBorrows", "totalDeposits"],
        missing_protections=["Rate smoothing", "utilization caps", "flash loan detection in rate calc"],
        exploit_mechanism="Flash loan borrow → spike utilization → interest accrues at inflated rate → repay flash loan.",
        real_world_examples=["Various lending protocol rate manipulation"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="Is interest rate based on current utilization? Can a flash loan temporarily spike it?",
    ),
    ExploitPattern(
        id="ECON-005",
        name="Liquidation Front-Running",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="MEV bots front-run liquidation transactions to extract liquidation bonuses.",
        code_indicators=["liquidat", "liquidationBonus", "liquidationIncentive"],
        missing_protections=["Private liquidation period", "Dutch auction liquidation"],
        exploit_mechanism="Monitor mempool → front-run liquidation call → claim liquidation bonus.",
        real_world_examples=["Common on all lending protocols"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="Can liquidations be front-run? Is there a mechanism to prevent MEV extraction from liquidation bonuses?",
    ),
    ExploitPattern(
        id="ECON-006",
        name="MEV Extraction via Transaction Ordering",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="medium",
        description="Protocol operations are sensitive to transaction ordering in the block.",
        code_indicators=["block.timestamp", "block.number", "oracle update", "price update"],
        missing_protections=["Commit-reveal scheme", "batch auction", "order-independent pricing"],
        exploit_mechanism="Reorder transactions within block to extract maximum value from protocol operations.",
        real_world_examples=["Common across all DeFi protocols"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Are any protocol operations sensitive to transaction ordering? Can reordering provide an advantage?",
    ),
    ExploitPattern(
        id="ECON-007",
        name="Returndata Bomb",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Malicious contract returns massive returndata, consuming all gas in memory expansion.",
        code_indicators=[".call(", "abi.decode", "returndatasize", "returndata"],
        missing_protections=["Gas limit on external calls", "returndata size check", "assembly-level protection"],
        exploit_mechanism="Target makes low-level call → malicious contract returns huge data → gas consumed by memory expansion → DoS.",
        real_world_examples=["Various returndata bomb DoS attacks"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Does any function make a low-level call without limiting gas or checking returndata size?",
    ),
    ExploitPattern(
        id="ECON-008",
        name="Signature Replay Across Forks",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Cached DOMAIN_SEPARATOR allows signature replay after chain fork.",
        code_indicators=["DOMAIN_SEPARATOR", "ecrecover", "block.chainid", "EIP712"],
        missing_protections=["Runtime chainid check", "DOMAIN_SEPARATOR recomputation"],
        exploit_mechanism="After chain fork, replay signatures from original chain on forked chain.",
        real_world_examples=["Post-merge Ethereum fork replay concerns"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is DOMAIN_SEPARATOR computed at runtime with block.chainid, or cached in constructor? Cached = replay risk.",
    ),
    ExploitPattern(
        id="ECON-009",
        name="First Depositor Inflation Attack (Generalized)",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="critical",
        description="First depositor to any share-based pool (not just ERC-4626) inflates share price to steal from subsequent depositors via rounding.",
        code_indicators=["totalSupply == 0", "deposit(", "mint(", "shares = amount * totalSupply / totalAssets"],
        missing_protections=["Virtual offset / dead shares", "minimum first deposit", "initial share mint to dead address"],
        exploit_mechanism="First deposit of 1 wei → donate large amount to pool directly → totalAssets inflated → next depositor's shares round to 0.",
        real_world_examples=["Yearn V2 vault inflation", "Custom staking pool first-depositor attacks"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.STAKING, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Does any share-based pool (staking, vault, LP) protect against first depositor inflation? Check for virtual offsets or minimum deposits.",
    ),
    ExploitPattern(
        id="ECON-010",
        name="JIT Liquidity Extraction",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Just-in-time liquidity added in concentrated range to capture swap fees, then immediately removed — parasitically extracts fees from passive LPs.",
        code_indicators=["mint(", "burn(", "tickLower", "tickUpper", "collect(", "positions["],
        missing_protections=["Minimum liquidity lock duration", "fee vesting period", "anti-JIT cooldown"],
        exploit_mechanism="Monitor mempool → add concentrated liquidity around pending swap tick → swap executes through position → remove liquidity and collect fees.",
        real_world_examples=["Widespread on Uniswap V3 since 2021", "Ambient Finance JIT mitigation"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.PERPETUAL_DEX],
        detection_prompt="Can liquidity be added and removed in the same block or transaction? Is there a cooldown or fee vesting to prevent JIT extraction?",
    ),
    ExploitPattern(
        id="ECON-011",
        name="Concentrated Liquidity Tick Manipulation",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Attacker manipulates price to cross specific ticks, triggering liquidity activation/deactivation to create price impact asymmetry.",
        code_indicators=["tick", "sqrtPriceX96", "cross(", "tickBitmap", "liquidityNet"],
        missing_protections=["Tick crossing gas limits", "price impact circuit breaker", "TWAP-based bounds"],
        exploit_mechanism="Push price to tick boundary → trigger large liquidity delta → reduced liquidity in next range → amplified price impact for attacker's trade.",
        real_world_examples=["Various concentrated liquidity pool manipulation incidents"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.PERPETUAL_DEX],
        detection_prompt="Can an attacker strategically cross tick boundaries to exploit liquidity gaps? Are there circuit breakers for large tick-boundary crossings?",
    ),
    ExploitPattern(
        id="ECON-012",
        name="Rounding Direction Exploitation in Share/Asset Conversion",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Inconsistent rounding in share-to-asset or asset-to-share conversions allows value extraction through repeated deposit/withdraw cycles.",
        code_indicators=["convertToShares(", "convertToAssets(", "mulDiv(", "Math.Rounding", "previewDeposit(", "previewRedeem("],
        missing_protections=["Round against user on deposits (down)", "round against user on withdrawals (up)", "minimum deposit/withdrawal amount"],
        exploit_mechanism="Repeatedly deposit/withdraw at amounts where rounding consistently favors attacker → extract 1 wei per cycle → scale with many iterations.",
        real_world_examples=["OpenZeppelin ERC-4626 rounding guidance", "Multiple vault audit findings"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.YIELD_AGGREGATOR, ProtocolArchetype.STAKING],
        detection_prompt="Does convertToShares round DOWN and convertToAssets round UP (or vice versa consistently against user)? Check mulDiv rounding direction in both paths.",
    ),

    # ===== LOGIC (6) =====
    ExploitPattern(
        id="LOG-001",
        name="Off-by-One Bounds Error",
        category=ExploitCategory.LOGIC,
        severity="medium",
        description="Loop or array bounds off by one, causing missed elements or out-of-bounds access.",
        code_indicators=["for (", "< length", "<= length", "i++", "array[i]"],
        missing_protections=["Correct bounds checking (< vs <=)", "array length validation"],
        exploit_mechanism="Off-by-one allows processing one extra/fewer element, causing state inconsistency.",
        real_world_examples=["Various smart contract off-by-one bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Check all loop bounds: should it be < or <=? Does the loop process all elements or miss the last one?",
    ),
    ExploitPattern(
        id="LOG-002",
        name="Incorrect Comparison Operator",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Wrong comparison operator (> vs >=, < vs <=) causes boundary condition failures.",
        code_indicators=["require(", "if (", ">", "<", ">=", "<=", "=="],
        missing_protections=["Correct operator for boundary condition"],
        exploit_mechanism="Boundary value passes/fails check incorrectly, allowing unauthorized action or blocking valid action.",
        real_world_examples=["Various smart contract logic bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="Check all comparison operators in require/if statements. Should it be > or >=? Are boundary values handled correctly?",
    ),
    ExploitPattern(
        id="LOG-003",
        name="Missing Deadline Check",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Transaction has no expiration, allowing it to be held in mempool and executed at unfavorable time.",
        code_indicators=["deadline", "block.timestamp", "expiry", "validUntil"],
        missing_protections=["require(block.timestamp <= deadline)", "transaction expiration"],
        exploit_mechanism="Hold transaction in mempool → execute when market conditions are unfavorable for user.",
        real_world_examples=["Common DEX transaction replay/delay attacks"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Do time-sensitive operations (swaps, orders) have a deadline parameter that's checked?",
    ),
    ExploitPattern(
        id="LOG-004",
        name="Missing Slippage Protection",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="No minimum output amount check allows unlimited slippage.",
        code_indicators=["swap(", "amountOut", "minAmount", "slippage"],
        missing_protections=["minAmountOut parameter", "require(amountOut >= minAmountOut)"],
        exploit_mechanism="Without minimum output check, sandwich attacks can extract unlimited value.",
        real_world_examples=["Extremely common vulnerability in DEX integrations"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Is there a minimum output amount check? Can a user lose all value through slippage?",
    ),
    ExploitPattern(
        id="LOG-005",
        name="Unchecked Low-Level Call Return",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Return value from low-level call/send not checked, silently failing.",
        code_indicators=[".call(", ".send(", "(bool success", "success"],
        missing_protections=["require(success)", "if (!success) revert"],
        exploit_mechanism="Call fails silently → state assumes success → inconsistent state.",
        real_world_examples=["Various protocols with unchecked calls"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.DEX_AMM],
        detection_prompt="Are all low-level call return values checked? Is the success boolean verified?",
    ),
    ExploitPattern(
        id="LOG-006",
        name="Self-Transfer Accounting Error",
        category=ExploitCategory.LOGIC,
        severity="medium",
        description="Transfer to self causes double-counting or balance corruption.",
        code_indicators=["transfer(", "from", "to", "balances["],
        missing_protections=["require(from != to)", "self-transfer handling"],
        exploit_mechanism="Transfer to self → balance deducted then added → potential overflow or state corruption.",
        real_world_examples=["Various token self-transfer bugs"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="What happens when from == to in a transfer? Does the accounting handle self-transfers correctly?",
    ),

    # ===== CROSS-CONTRACT (5) =====
    ExploitPattern(
        id="CC-001",
        name="Cross-Contract Reentrancy via Shared State",
        category=ExploitCategory.CROSS_CONTRACT,
        severity="critical",
        description="Multiple protocol contracts share state but have independent reentrancy locks, allowing re-entry through a sibling contract during an external call.",
        code_indicators=["nonReentrant", "delegatecall", "external call", "shared storage", "IProtocol("],
        missing_protections=["Global cross-contract reentrancy lock", "shared ReentrancyGuard across protocol"],
        exploit_mechanism="Contract A makes external call → callback re-enters Contract B → B reads A's stale shared state → profit from inconsistency.",
        real_world_examples=["Fei Protocol cross-contract reentrancy", "Curve/Vyper reentrancy via multiple pools"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Do multiple contracts share state (balances, reserves, rates) but use independent reentrancy locks? Can a callback in one contract re-enter another?",
    ),
    ExploitPattern(
        id="CC-002",
        name="Read-Only Reentrancy via View Function Stale State",
        category=ExploitCategory.CROSS_CONTRACT,
        severity="high",
        description="View functions on a target contract return stale values during an external callback, and an integrating protocol reads those stale values to make decisions.",
        code_indicators=["view", "getReserves(", "totalAssets(", "getPrice(", "balanceOf(", "nonReentrant"],
        missing_protections=["Reentrancy guard on view functions", "state update before external calls", "reentrancy-aware oracle reads"],
        exploit_mechanism="Protocol A calls external → during callback, integrating Protocol B reads A's view functions → stale values → B misprices collateral → profit.",
        real_world_examples=["Curve read-only reentrancy (2023, $60M+ at risk)", "Sentiment Protocol ($1M)", "Balancer read-only reentrancy"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.ORACLE],
        detection_prompt="Does this contract expose view functions (getRate, totalAssets, getReserves) that other protocols depend on? Can those values be stale during a callback?",
    ),
    ExploitPattern(
        id="CC-003",
        name="Flash Loan Composability Attack",
        category=ExploitCategory.CROSS_CONTRACT,
        severity="critical",
        description="Flash loan from one protocol used to manipulate state in another protocol within the same transaction, exploiting cross-protocol assumptions.",
        code_indicators=["flashLoan(", "onFlashLoan(", "executeOperation(", "IERC3156", "balanceOf(address(this))"],
        missing_protections=["Flash loan resistant pricing (TWAP)", "same-block operation restrictions", "multi-block oracle"],
        exploit_mechanism="Flash borrow asset → deposit as collateral in Protocol B → borrow from B → manipulate price in Protocol C → liquidate in B → repay flash loan.",
        real_world_examples=["Cream Finance ($130M)", "Harvest Finance ($34M)", "Pancake Bunny ($45M)"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Can flash-loaned funds be used to manipulate collateral values or prices that this protocol depends on? Are spot balances used for pricing?",
    ),
    ExploitPattern(
        id="CC-004",
        name="Callback-Driven State Inconsistency (ERC-777/1155)",
        category=ExploitCategory.CROSS_CONTRACT,
        severity="high",
        description="Token standards with transfer callbacks (ERC-777 tokensReceived, ERC-1155 onERC1155Received) enable cross-contract state manipulation during transfers.",
        code_indicators=["ERC777", "tokensReceived", "ERC1155", "onERC1155Received", "safeTransferFrom(", "_callTokensReceived"],
        missing_protections=["nonReentrant on all token-receiving functions", "checks-effects-interactions pattern", "ERC-777/1155 callback awareness"],
        exploit_mechanism="Token transfer triggers callback → attacker's contract re-enters protocol or manipulates state in dependent protocol before transfer completes.",
        real_world_examples=["imBTC/Uniswap drain ($300K, 2020)", "Various ERC-777 integration exploits"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Does the protocol accept ERC-777 or ERC-1155 tokens? Are transfer callbacks accounted for with reentrancy guards on all state-modifying paths?",
    ),
    ExploitPattern(
        id="CC-005",
        name="Delegatecall to Untrusted Implementation",
        category=ExploitCategory.CROSS_CONTRACT,
        severity="critical",
        description="Contract delegatecalls to an address that can be influenced or controlled by an attacker, allowing arbitrary code execution in the caller's storage context.",
        code_indicators=["delegatecall(", "implementation", "target", "logic", "_delegate("],
        missing_protections=["Hardcoded or governance-controlled implementation address", "implementation whitelist", "immutable implementation slot"],
        exploit_mechanism="Attacker sets implementation to malicious contract → delegatecall executes attacker code in victim's context → drain funds or corrupt storage.",
        real_world_examples=["Poly Network ($611M, 2021)", "Parity Wallet ($150M freeze, 2017)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Does any function delegatecall to a non-hardcoded address? Can an attacker influence the delegatecall target through any code path?",
    ),

    # ===== SIGNATURE / AUTH (4) =====
    ExploitPattern(
        id="SA-001",
        name="EIP-712 Signature Replay (Missing Nonce)",
        category=ExploitCategory.SIGNATURE_AUTH,
        severity="critical",
        description="Signed messages lack a nonce or the nonce is not properly invalidated, allowing the same signature to be replayed multiple times.",
        code_indicators=["ecrecover(", "ECDSA.recover(", "EIP712", "hashTypedDataV4(", "permit(", "nonce"],
        missing_protections=["Per-signer incrementing nonce", "nonce invalidation after use", "deadline + nonce combination"],
        exploit_mechanism="Obtain valid signature → submit transaction → signature accepted → replay same signature again → double-spend or repeated action.",
        real_world_examples=["Various permit replay attacks", "Missing nonce in meta-transaction relayers"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Does the signed message struct include a nonce? Is the nonce incremented or invalidated after each use? Can the same signature be submitted twice?",
    ),
    ExploitPattern(
        id="SA-002",
        name="Cross-Chain Signature Replay (Missing chainId)",
        category=ExploitCategory.SIGNATURE_AUTH,
        severity="high",
        description="EIP-712 domain separator does not include chainId or uses a cached value, allowing signatures to be replayed across chains or after forks.",
        code_indicators=["DOMAIN_SEPARATOR", "block.chainid", "EIP712", "domainSeparator", "keccak256(abi.encode("],
        missing_protections=["Runtime block.chainid in domain separator", "dynamic DOMAIN_SEPARATOR recomputation on chainid change"],
        exploit_mechanism="Sign message on Chain A → replay on Chain B (same contract address) → signature validates because chainId not checked.",
        real_world_examples=["Post-Ethereum merge fork replay concerns", "Multi-chain token deployments"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.BRIDGE, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is DOMAIN_SEPARATOR computed at deploy time (cached) or does it check block.chainid at runtime? Cached = replay risk after chain fork.",
    ),
    ExploitPattern(
        id="SA-003",
        name="ecrecover Returns address(0) Without Check",
        category=ExploitCategory.SIGNATURE_AUTH,
        severity="critical",
        description="ecrecover returns address(0) for invalid signatures instead of reverting. Without a zero-address check, invalid signatures may authenticate as address(0).",
        code_indicators=["ecrecover(", "signer", "address(0)", "require(signer !="],
        missing_protections=["require(signer != address(0))", "use OpenZeppelin ECDSA.recover (reverts on 0)"],
        exploit_mechanism="Submit malformed signature → ecrecover returns address(0) → if protocol has address(0) as valid signer or doesn't check → unauthorized access.",
        real_world_examples=["Various smart contract signature validation bugs", "0x Protocol vulnerability disclosure"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Does the contract use raw ecrecover? Is the returned address checked against address(0)? OpenZeppelin's ECDSA.recover is safer.",
    ),
    ExploitPattern(
        id="SA-004",
        name="Permit Front-Running Griefing",
        category=ExploitCategory.SIGNATURE_AUTH,
        severity="high",
        description="Attacker front-runs a permit() call with the same signature, causing the original transaction to revert because the nonce was already consumed.",
        code_indicators=["permit(", "IERC20Permit", "nonces(", "DOMAIN_SEPARATOR"],
        missing_protections=["try/catch around permit call", "allowance check before permit", "permit + transferFrom in same call with fallback"],
        exploit_mechanism="See pending permit+transferFrom → extract permit signature → front-run permit() → original tx reverts on nonce mismatch → DoS.",
        real_world_examples=["OpenZeppelin permit front-running advisory", "USDC permit griefing incidents"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does the protocol call permit() then transferFrom() in separate steps? Can an attacker front-run the permit to grief the user's transaction?",
    ),

    # ===== TOKEN INTEGRATION (4) =====
    ExploitPattern(
        id="TI-001",
        name="Fee-on-Transfer Accounting Mismatch",
        category=ExploitCategory.TOKEN_INTEGRATION,
        severity="high",
        description="Protocol credits the full transfer amount to a user's balance, but fee-on-transfer tokens deliver less than the specified amount.",
        code_indicators=["transferFrom(", "safeTransferFrom(", "amount", "deposit(", "balanceOf("],
        missing_protections=["Balance delta check (balanceAfter - balanceBefore)", "fee-on-transfer token whitelist/blocklist"],
        exploit_mechanism="Deposit fee-on-transfer token → protocol credits full 'amount' → actual balance is amount - fee → withdraw credited amount → drain protocol.",
        real_world_examples=["SushiSwap fee-on-transfer issues", "Many DeFi protocols on audit findings"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="After transferFrom(), does the protocol use the 'amount' parameter or actual balance delta (balanceAfter - balanceBefore) for accounting?",
    ),
    ExploitPattern(
        id="TI-002",
        name="Rebasing Token Balance Corruption",
        category=ExploitCategory.TOKEN_INTEGRATION,
        severity="high",
        description="Protocol stores absolute balances for rebasing tokens (stETH, AMPL) whose balanceOf changes without transfers, causing accounting drift.",
        code_indicators=["balanceOf(", "totalAssets(", "storedBalance", "rebase", "stETH", "AMPL"],
        missing_protections=["Use wrapped non-rebasing version (wstETH)", "rebase-aware internal accounting", "share-based tracking"],
        exploit_mechanism="Positive rebase → protocol's tracked balance < actual → attacker deposits and gets credited extra shares. Negative rebase → users can't withdraw full amount.",
        real_world_examples=["stETH integration issues across Aave, Lido ecosystem", "AMPL rebasing integration failures"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.STAKING, ProtocolArchetype.YIELD_AGGREGATOR],
        detection_prompt="Does the protocol handle rebasing tokens? Does it store absolute balances that can drift from actual balanceOf after a rebase event?",
    ),
    ExploitPattern(
        id="TI-003",
        name="Missing Return Value on Non-Standard ERC-20 (USDT)",
        category=ExploitCategory.TOKEN_INTEGRATION,
        severity="high",
        description="Some ERC-20 tokens (notably USDT) do not return a boolean from transfer/approve. Solidity's interface expects a return value, causing reverts.",
        code_indicators=["IERC20(", ".transfer(", ".approve(", ".transferFrom(", "USDT"],
        missing_protections=["SafeERC20.safeTransfer", "SafeERC20.safeApprove", "low-level call with returndata check"],
        exploit_mechanism="Protocol calls IERC20(usdt).transfer() → USDT doesn't return bool → Solidity ABI decoder reverts → funds stuck, DoS.",
        real_world_examples=["USDT integration failures across DeFi", "Tether non-standard return value"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.BRIDGE, ProtocolArchetype.STAKING],
        detection_prompt="Does the protocol use SafeERC20 for all token interactions? Direct IERC20 calls will fail for non-standard tokens like USDT that don't return bool.",
    ),
    ExploitPattern(
        id="TI-004",
        name="Approval Race Condition (Front-Running approve)",
        category=ExploitCategory.TOKEN_INTEGRATION,
        severity="high",
        description="Changing an ERC-20 approval from N to M allows a spender to front-run and spend both N and M by seeing the pending approve transaction.",
        code_indicators=["approve(", "allowance", "increaseAllowance(", "decreaseAllowance("],
        missing_protections=["increaseAllowance/decreaseAllowance pattern", "approve to 0 first then to new value", "permit-based approvals"],
        exploit_mechanism="User approves spender for N → user sends tx to change to M → spender sees pending tx → spends N → approve goes through → spends M → total N+M.",
        real_world_examples=["Known ERC-20 approve race condition (documented in EIP-20)"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does the protocol change approvals directly, or use increaseAllowance/decreaseAllowance? Does it require setting to 0 before changing?",
    ),

    # ===== PROXY / UPGRADE (4) =====
    ExploitPattern(
        id="PU-001",
        name="Uninitialized Implementation Contract",
        category=ExploitCategory.PROXY_UPGRADE,
        severity="critical",
        description="Implementation contract behind a proxy is not initialized, allowing an attacker to call initialize() and take ownership or selfdestruct it.",
        code_indicators=["initialize(", "Initializable", "initializer", "proxy", "_disableInitializers"],
        missing_protections=["_disableInitializers() in implementation constructor", "initialized flag set in implementation"],
        exploit_mechanism="Call initialize() directly on implementation (not proxy) → become owner → selfdestruct implementation → proxy becomes non-functional (bricked).",
        real_world_examples=["Wormhole uninitialized implementation", "Audius ($6M, 2022)", "Harvest Finance implementation takeover"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Does the implementation contract's constructor call _disableInitializers()? Can initialize() be called directly on the implementation address?",
    ),
    ExploitPattern(
        id="PU-002",
        name="Storage Layout Collision Across Upgrades",
        category=ExploitCategory.PROXY_UPGRADE,
        severity="critical",
        description="New state variables in an upgraded implementation overwrite existing storage slots, corrupting balances, ownership, or other critical state.",
        code_indicators=["UUPSUpgradeable", "TransparentProxy", "__gap", "upgradeTo(", "StorageSlot", "ERC1967"],
        missing_protections=["__gap arrays in all base contracts", "append-only storage layout policy", "storage layout verification tool"],
        exploit_mechanism="Upgrade adds new variable before existing ones → storage slot shift → balances[user] now reads from wrong slot → state corruption → theft.",
        real_world_examples=["Various proxy upgrade storage collision bugs in audits", "OpenZeppelin storage gap pattern"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Do all inheritable base contracts include __gap arrays? Are new storage variables only appended at the end? Has storage layout been verified across versions?",
    ),
    ExploitPattern(
        id="PU-003",
        name="UUPS Missing _authorizeUpgrade Protection",
        category=ExploitCategory.PROXY_UPGRADE,
        severity="critical",
        description="UUPS proxy's _authorizeUpgrade function has no access control or weak access control, allowing anyone to upgrade the implementation to a malicious contract.",
        code_indicators=["UUPSUpgradeable", "_authorizeUpgrade(", "upgradeTo(", "upgradeToAndCall("],
        missing_protections=["onlyOwner or onlyRole on _authorizeUpgrade", "timelock on upgrades", "multi-sig required for upgrades"],
        exploit_mechanism="Call upgradeTo() with malicious implementation → _authorizeUpgrade has no check → implementation replaced → attacker controls all proxy state.",
        real_world_examples=["UUPS vulnerability in OpenZeppelin < 4.3.2", "Various UUPS misconfiguration findings"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.TOKEN],
        detection_prompt="Does _authorizeUpgrade() have access control (onlyOwner, onlyRole)? Can an arbitrary caller trigger an upgrade?",
    ),
    ExploitPattern(
        id="PU-004",
        name="selfdestruct in Implementation (Bricking Proxy)",
        category=ExploitCategory.PROXY_UPGRADE,
        severity="critical",
        description="Implementation contract contains selfdestruct or delegatecalls to a contract that selfdestructs, which destroys the implementation and bricks the proxy.",
        code_indicators=["selfdestruct(", "delegatecall(", "implementation", "SELFDESTRUCT"],
        missing_protections=["No selfdestruct in implementation", "no unguarded delegatecall in implementation", "_disableInitializers preventing attacker initialization"],
        exploit_mechanism="Attacker calls initialize() on implementation → becomes owner → calls selfdestruct → proxy's delegatecall now hits empty code → all funds frozen.",
        real_world_examples=["Parity Wallet freeze ($150M, 2017)", "Various proxy selfdestruct findings"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Does the implementation contract contain selfdestruct or unguarded delegatecall? Can an attacker reach selfdestruct through any execution path?",
        atomic=False,
    ),

    # ===== TYPE SAFETY (4) =====
    ExploitPattern(
        id="TS-001",
        name="Unsafe Downcast Truncation (uint256 to uint128)",
        category=ExploitCategory.TYPE_SAFETY,
        severity="high",
        description="Casting a uint256 to a smaller type (uint128, uint96, uint64, etc.) silently truncates the value in Solidity, causing loss of high-order bits.",
        code_indicators=["uint128(", "uint96(", "uint64(", "uint32(", "int128(", "SafeCast", "toUint128("],
        missing_protections=["SafeCast library usage", "explicit bounds check before cast", "require(value <= type(uint128).max)"],
        exploit_mechanism="Large value cast to smaller type → high bits lost → truncated value much smaller → attacker deposits large amount, credited for truncated amount.",
        real_world_examples=["Various audit findings on unsafe downcasts", "Uniswap V3 SafeCast usage"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.TOKEN, ProtocolArchetype.STAKING],
        detection_prompt="Are there any explicit type downcasts (uint256 to uint128, etc.) without SafeCast or bounds checks? Can the value exceed the target type's max?",
    ),
    ExploitPattern(
        id="TS-002",
        name="abi.encodePacked Collision with Dynamic Types",
        category=ExploitCategory.TYPE_SAFETY,
        severity="high",
        description="abi.encodePacked with multiple dynamic types (string, bytes) produces ambiguous encoding — different inputs can produce the same hash.",
        code_indicators=["abi.encodePacked(", "keccak256(abi.encodePacked(", "string", "bytes"],
        missing_protections=["Use abi.encode instead of abi.encodePacked", "fixed-length types only in encodePacked", "length-prefix dynamic types"],
        exploit_mechanism="Craft two different inputs that produce the same encodePacked output → hash collision → bypass uniqueness checks, forge signatures, or corrupt mappings.",
        real_world_examples=["Solidity documentation warning on encodePacked", "Various hash collision audit findings"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.GOVERNANCE, ProtocolArchetype.BRIDGE, ProtocolArchetype.NFT_MARKETPLACE, ProtocolArchetype.DEX_AMM],
        detection_prompt="Does abi.encodePacked() include two or more dynamic types (string, bytes, arrays)? These can produce hash collisions. Use abi.encode() instead.",
    ),
    ExploitPattern(
        id="TS-003",
        name="Assembly Arithmetic Bypassing Overflow Checks",
        category=ExploitCategory.TYPE_SAFETY,
        severity="high",
        description="Inline assembly (Yul) arithmetic does not have Solidity 0.8+ overflow/underflow checks, silently wrapping on overflow.",
        code_indicators=["assembly {", "add(", "sub(", "mul(", "div(", "mload(", "sload("],
        missing_protections=["Explicit overflow checks in assembly", "bounds validation before assembly block", "SafeMath-equivalent in Yul"],
        exploit_mechanism="Craft inputs that overflow in assembly arithmetic → value wraps to small number → bypass balance checks or extract excess funds.",
        real_world_examples=["Various assembly overflow bugs in optimized DeFi contracts", "Yul-based library vulnerabilities"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.TOKEN],
        detection_prompt="Does inline assembly perform arithmetic (add, sub, mul)? These operations wrap on overflow without Solidity's built-in checks. Are bounds verified?",
    ),
    ExploitPattern(
        id="TS-004",
        name="Dirty High Bits in Low-Level Calls",
        category=ExploitCategory.TYPE_SAFETY,
        severity="high",
        description="Low-level call/staticcall return data may have dirty high-order bits when decoded as smaller types (address, uint96, etc.), causing incorrect values.",
        code_indicators=["assembly {", "calldataload(", "mload(", "returndatacopy(", "shr(", "and("],
        missing_protections=["Proper masking of return values", "abi.decode for return data", "address(uint160(value)) masking"],
        exploit_mechanism="Low-level call returns dirty data → high bits not masked → type cast includes garbage bits → wrong address or amount used → unauthorized access or loss.",
        real_world_examples=["Dirty bits in Solidity assembly audit findings", "Incorrect address masking in proxy contracts"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.TOKEN],
        detection_prompt="Does inline assembly read returndata or calldata and cast to smaller types? Are high-order bits properly masked (e.g., and(value, 0xffffffffffffffffffffffffffffffffffffffff) for address)?",
    ),
]


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

class ExploitKnowledgeBase:
    """Queryable knowledge base of exploit patterns."""

    def __init__(self):
        self._patterns = list(_ALL_PATTERNS)
        self._by_id: Dict[str, ExploitPattern] = {p.id: p for p in self._patterns}
        self._by_category: Dict[ExploitCategory, List[ExploitPattern]] = {}
        for p in self._patterns:
            self._by_category.setdefault(p.category, []).append(p)

    @property
    def all_patterns(self) -> List[ExploitPattern]:
        return list(self._patterns)

    def get_by_id(self, pattern_id: str) -> Optional[ExploitPattern]:
        return self._by_id.get(pattern_id)

    def get_by_category(self, category: ExploitCategory) -> List[ExploitPattern]:
        return list(self._by_category.get(category, []))

    def get_for_archetype(self, archetype: ProtocolArchetype) -> List[ExploitPattern]:
        """Get all patterns applicable to a specific protocol archetype."""
        return [p for p in self._patterns if archetype in p.applicable_archetypes]

    def get_for_archetypes(self, archetypes: List[ProtocolArchetype]) -> List[ExploitPattern]:
        """Get patterns applicable to any of the given archetypes."""
        archetype_set = set(archetypes)
        return [p for p in self._patterns
                if any(a in archetype_set for a in p.applicable_archetypes)]

    def get_critical_patterns(self) -> List[ExploitPattern]:
        """Get all critical severity patterns."""
        return [p for p in self._patterns if p.severity == "critical"]

    def search(self, query: str) -> List[ExploitPattern]:
        """Search patterns by keyword in name, description, or exploit mechanism."""
        q = query.lower()
        return [p for p in self._patterns
                if q in p.name.lower()
                or q in p.description.lower()
                or q in p.exploit_mechanism.lower()]

    def format_for_prompt(self, patterns: Optional[List[ExploitPattern]] = None,
                          max_patterns: int = 25) -> str:
        """Format patterns as a prompt section for LLM consumption."""
        if patterns is None:
            patterns = self._patterns
        patterns = patterns[:max_patterns]

        lines = ["## Known Exploit Patterns (Real-World Precedents)", ""]
        for i, p in enumerate(patterns, 1):
            lines.append(f"### {i}. {p.name} [{p.severity.upper()}] ({p.id})")
            lines.append(f"**Pattern**: {p.description}")
            lines.append(f"**Code indicators**: {', '.join(p.code_indicators)}")
            lines.append(f"**Missing protections**: {', '.join(p.missing_protections)}")
            lines.append(f"**Exploit**: {p.exploit_mechanism}")
            lines.append(f"**Real-world**: {', '.join(p.real_world_examples)}")
            lines.append(f"**Check**: {p.detection_prompt}")
            lines.append("")
        return "\n".join(lines)

    def format_for_focus_areas(self, focus_areas: List[str]) -> str:
        """Get patterns relevant to focus areas and format for prompt.

        Maps focus area strings to categories/archetypes and returns formatted
        patterns. Falls back to all patterns if no mapping found.
        """
        # Map focus areas to categories
        _FOCUS_MAP: Dict[str, List[ExploitCategory]] = {
            'access_control': [ExploitCategory.ACCESS_CONTROL],
            'reentrancy': [ExploitCategory.REENTRANCY, ExploitCategory.CROSS_CONTRACT],
            'amm': [ExploitCategory.INFLATION_SHARE, ExploitCategory.ECONOMIC_DEFI],
            'lending': [ExploitCategory.ORACLE, ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE, ExploitCategory.TOKEN_INTEGRATION],
            'governance': [ExploitCategory.GOVERNANCE],
            'external_calls': [ExploitCategory.REENTRANCY, ExploitCategory.ECONOMIC_DEFI, ExploitCategory.CROSS_CONTRACT],
            'delegatecall': [ExploitCategory.ACCESS_CONTROL, ExploitCategory.CROSS_CONTRACT, ExploitCategory.PROXY_UPGRADE],
            'arithmetic': [ExploitCategory.PRECISION_ROUNDING, ExploitCategory.TYPE_SAFETY],
            'precision': [ExploitCategory.PRECISION_ROUNDING],
            'precision_loss': [ExploitCategory.PRECISION_ROUNDING],
            'logic_errors': [ExploitCategory.LOGIC, ExploitCategory.REENTRANCY],
            'privilege': [ExploitCategory.ACCESS_CONTROL],
            'complex_logic': [ExploitCategory.LOGIC, ExploitCategory.INFLATION_SHARE],
            'economic': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE],
            'economic_attacks': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE],
            'oracle_manipulation': [ExploitCategory.ORACLE],
            'overflow': [ExploitCategory.PRECISION_ROUNDING, ExploitCategory.TYPE_SAFETY],
            'underflow': [ExploitCategory.PRECISION_ROUNDING, ExploitCategory.TYPE_SAFETY],
            'cross_contract': [ExploitCategory.REENTRANCY, ExploitCategory.BRIDGE, ExploitCategory.CROSS_CONTRACT],
            'invariant_violations': [ExploitCategory.INFLATION_SHARE, ExploitCategory.LOGIC],
            'flash_loan': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE, ExploitCategory.ORACLE, ExploitCategory.CROSS_CONTRACT],
            'defi': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE, ExploitCategory.ORACLE, ExploitCategory.TOKEN_INTEGRATION],
            'bridge': [ExploitCategory.BRIDGE],
            'signature': [ExploitCategory.SIGNATURE_AUTH],
            'signature_replay': [ExploitCategory.SIGNATURE_AUTH],
            'permit': [ExploitCategory.SIGNATURE_AUTH],
            'token_integration': [ExploitCategory.TOKEN_INTEGRATION],
            'fee_on_transfer': [ExploitCategory.TOKEN_INTEGRATION],
            'rebasing': [ExploitCategory.TOKEN_INTEGRATION],
            'proxy': [ExploitCategory.PROXY_UPGRADE, ExploitCategory.ACCESS_CONTROL],
            'upgrade': [ExploitCategory.PROXY_UPGRADE],
            'upgradeable': [ExploitCategory.PROXY_UPGRADE],
            'type_safety': [ExploitCategory.TYPE_SAFETY],
            'assembly': [ExploitCategory.TYPE_SAFETY],
            'encoding': [ExploitCategory.TYPE_SAFETY],
            'downcast': [ExploitCategory.TYPE_SAFETY],
        }

        categories: Set[ExploitCategory] = set()
        for area in focus_areas:
            key = area.lower().replace(' ', '_').replace('-', '_')
            if key in _FOCUS_MAP:
                categories.update(_FOCUS_MAP[key])

        if not categories:
            return self.format_for_prompt()

        patterns = []
        seen: Set[str] = set()
        for cat in categories:
            for p in self.get_by_category(cat):
                if p.id not in seen:
                    patterns.append(p)
                    seen.add(p.id)
        return self.format_for_prompt(patterns)
