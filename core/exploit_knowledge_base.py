"""
Exploit Knowledge Base — Structured database of 50+ real-world exploit patterns.

Replaces the static 10-pattern ZERO_DAY_VULNERABILITY_PATTERNS with a
categorized, filterable collection. Each pattern includes code indicators,
missing protections, exploit mechanism, real-world examples, and archetype
applicability.
"""

from dataclasses import dataclass, field
from enum import Enum
from typing import Dict, List, Optional, Set

from core.protocol_archetypes import ProtocolArchetype


class ExploitCategory(Enum):
    INFLATION_SHARE = "inflation_share"
    REENTRANCY = "reentrancy"
    ORACLE = "oracle"
    GOVERNANCE = "governance"
    BRIDGE = "bridge"
    PRECISION_ROUNDING = "precision_rounding"
    ACCESS_CONTROL = "access_control"
    ECONOMIC_DEFI = "economic_defi"
    LOGIC = "logic"


@dataclass
class ExploitPattern:
    """A single real-world exploit pattern."""
    id: str
    name: str
    category: ExploitCategory
    severity: str  # critical / high / medium
    description: str
    code_indicators: List[str]
    missing_protections: List[str]
    exploit_mechanism: str
    real_world_examples: List[str]
    applicable_archetypes: List[ProtocolArchetype]
    detection_prompt: str
    # Optional extra fields
    capital_required: str = "flash loan (0)"
    atomic: bool = True


# ---------------------------------------------------------------------------
# Pattern definitions — 50+ patterns across 9 categories
# ---------------------------------------------------------------------------

_ALL_PATTERNS: List[ExploitPattern] = [
    # ===== INFLATION / SHARE ATTACKS (6) =====
    ExploitPattern(
        id="INF-001",
        name="ERC-4626 First Depositor Inflation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="Attacker deposits 1 wei, donates large amount directly to inflate share price. Subsequent depositors receive 0 shares due to rounding.",
        code_indicators=["ERC4626", "totalAssets()", "deposit(", "totalSupply == 0"],
        missing_protections=["_decimalsOffset()", "virtual shares/assets", "minimum initial deposit"],
        exploit_mechanism="Deposit 1 wei → donate 10^18 tokens directly → share price = 10^18. Next depositor with < 10^18 gets 0 shares.",
        real_world_examples=["Multiple ERC-4626 vault exploits (2022-2023)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Check for _decimalsOffset(), virtual shares, or minimum deposit. If absent and vault uses ERC-4626, this is exploitable.",
    ),
    ExploitPattern(
        id="INF-002",
        name="LP Token Inflation via First Mint",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="First liquidity provider manipulates initial LP token price, extracting value from subsequent providers.",
        code_indicators=["totalSupply == 0", "mint(", "sqrt(", "MINIMUM_LIQUIDITY"],
        missing_protections=["MINIMUM_LIQUIDITY burn", "dead shares"],
        exploit_mechanism="First LP provides tiny liquidity at manipulated ratio, then front-runs normal LPs to extract value.",
        real_world_examples=["Uniswap V2 mitigation (MINIMUM_LIQUIDITY)"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM],
        detection_prompt="Does pool burn MINIMUM_LIQUIDITY or equivalent on first mint? Without it, first LP can manipulate share price.",
    ),
    ExploitPattern(
        id="INF-003",
        name="Donation-Based Share Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Direct token transfer to vault/pool inflates totalAssets without minting shares, manipulating exchange rate.",
        code_indicators=["totalAssets()", "balanceOf(address(this))", "convertToShares"],
        missing_protections=["Internal accounting separate from balanceOf", "virtual balance"],
        exploit_mechanism="Transfer tokens directly → totalAssets increases → share price inflated → depositors get fewer shares.",
        real_world_examples=["Various vault implementations using balanceOf for accounting"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="Does totalAssets() or reserve calculation use balanceOf(address(this))? Direct transfers can manipulate it.",
    ),
    ExploitPattern(
        id="INF-004",
        name="Virtual Balance Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Protocol tracks virtual balances that can diverge from actual balances, creating accounting gaps.",
        code_indicators=["_totalAssets", "internalBalance", "virtualBalance"],
        missing_protections=["Reconciliation checks", "balance invariant assertions"],
        exploit_mechanism="Exploit divergence between virtual and actual balance through edge cases in deposit/withdraw paths.",
        real_world_examples=["Various DeFi accounting exploits"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does the protocol maintain virtual balances? Can they diverge from actual token balances through any code path?",
    ),
    ExploitPattern(
        id="INF-005",
        name="Exchange Rate Flash Manipulation",
        category=ExploitCategory.INFLATION_SHARE,
        severity="critical",
        description="Flash loan to temporarily manipulate exchange rate between deposit/withdrawal in same transaction.",
        code_indicators=["exchangeRate", "getRate()", "sharePrice"],
        missing_protections=["TWAP for exchange rate", "same-block manipulation checks"],
        exploit_mechanism="Flash loan → manipulate rate → deposit at low rate → restore rate → withdraw at high rate.",
        real_world_examples=["Multiple DeFi flash loan attacks"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM],
        detection_prompt="Can the exchange rate be manipulated within a single transaction? Is rate derived from spot values?",
    ),
    ExploitPattern(
        id="INF-006",
        name="Rebasing Token Integration Mismatch",
        category=ExploitCategory.INFLATION_SHARE,
        severity="high",
        description="Protocol doesn't handle rebasing tokens (like stETH) whose balance changes without transfers.",
        code_indicators=["balanceOf", "totalAssets", "rebase"],
        missing_protections=["Wrapped token usage (wstETH)", "rebase-aware accounting"],
        exploit_mechanism="Balance changes from rebase create accounting discrepancies between protocol's tracked amount and actual.",
        real_world_examples=["Multiple protocols affected by stETH rebasing"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.STAKING],
        detection_prompt="Does the protocol handle rebasing tokens? If it uses balanceOf for accounting, rebasing tokens will cause discrepancies.",
    ),

    # ===== REENTRANCY (7) =====
    ExploitPattern(
        id="RE-001",
        name="Classic ETH Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="critical",
        description="ETH transfer via call{value:} allows recipient to re-enter before state update.",
        code_indicators=[".call{value:", ".transfer(", ".send(", "withdraw("],
        missing_protections=["nonReentrant modifier", "checks-effects-interactions pattern"],
        exploit_mechanism="call{value: amount}('') triggers fallback → re-enters withdraw() → drains funds.",
        real_world_examples=["The DAO ($60M, 2016)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="Does any function send ETH before updating state? Check for call{value:} or transfer() before balance/state updates.",
    ),
    ExploitPattern(
        id="RE-002",
        name="Read-Only Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="View functions return stale state during external callback, exploited by other protocols reading the state.",
        code_indicators=["balanceOf(", "totalSupply(", "getReserves(", "view", "nonReentrant"],
        missing_protections=["Reentrancy guard on view functions", "state update before external calls"],
        exploit_mechanism="During callback, view function returns pre-update state → external protocol uses stale price → profit.",
        real_world_examples=["Curve/Vyper read-only reentrancy (2023)", "Sentiment Protocol"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Can view functions return stale state during a callback? Are external protocols reading this contract's state during its operations?",
    ),
    ExploitPattern(
        id="RE-003",
        name="Cross-Function Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Function A has reentrancy guard but Function B modifies same state without it.",
        code_indicators=["nonReentrant", "ReentrancyGuard"],
        missing_protections=["Consistent nonReentrant across all state-modifying functions"],
        exploit_mechanism="During Function A callback, call unprotected Function B to manipulate shared state.",
        real_world_examples=["Lendf.Me ($25M)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM],
        detection_prompt="Do ALL functions that modify shared state have nonReentrant? Check for inconsistent guard application.",
    ),
    ExploitPattern(
        id="RE-004",
        name="Cross-Contract Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Reentrancy guard is per-contract, not cross-contract. Attacker re-enters a different contract in the protocol.",
        code_indicators=["nonReentrant", "external call", "cross-contract"],
        missing_protections=["Global reentrancy lock across protocol contracts", "shared lock"],
        exploit_mechanism="Contract A calls external → callback re-enters Contract B → B reads A's stale state.",
        real_world_examples=["Fei Protocol cross-contract reentrancy"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.BRIDGE],
        detection_prompt="Does the protocol use a shared reentrancy lock across contracts, or per-contract? Can reentrancy in one contract affect another?",
    ),
    ExploitPattern(
        id="RE-005",
        name="ERC-777 Token Hook Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="ERC-777 tokens trigger tokensReceived/tokensToSend hooks during transfers, enabling reentrancy.",
        code_indicators=["ERC777", "tokensReceived", "tokensToSend", "IERC1820"],
        missing_protections=["nonReentrant on all token-receiving functions", "ERC-777 awareness"],
        exploit_mechanism="Token transfer triggers hook → re-enter protocol before state update.",
        real_world_examples=["imBTC Uniswap pool drain (2020)"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Does the protocol accept arbitrary ERC-20 tokens? ERC-777 tokens have transfer hooks that enable reentrancy.",
    ),
    ExploitPattern(
        id="RE-006",
        name="ERC-1155 Callback Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="ERC-1155 safeTransferFrom triggers onERC1155Received callback before completing.",
        code_indicators=["ERC1155", "safeTransferFrom", "onERC1155Received", "safeBatchTransferFrom"],
        missing_protections=["nonReentrant on NFT operations", "callback guard"],
        exploit_mechanism="safeTransferFrom triggers callback → re-enter before state update.",
        real_world_examples=["Various NFT marketplace exploits"],
        applicable_archetypes=[ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Does the protocol handle ERC-1155 tokens? safeTransferFrom has a callback that can enable reentrancy.",
    ),
    ExploitPattern(
        id="RE-007",
        name="Flash Loan Callback Reentrancy",
        category=ExploitCategory.REENTRANCY,
        severity="high",
        description="Flash loan callback allows re-entering the lending protocol before loan state is finalized.",
        code_indicators=["flashLoan(", "onFlashLoan(", "executeOperation(", "IERC3156"],
        missing_protections=["State finalization before callback", "reentrancy guard on flash loan"],
        exploit_mechanism="During flash loan callback, re-enter borrow/deposit to manipulate collateral state.",
        real_world_examples=["Multiple flash loan reentrancy exploits"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM],
        detection_prompt="Is flash loan state finalized before the callback? Can the callback re-enter protocol functions?",
    ),

    # ===== ORACLE (5) =====
    ExploitPattern(
        id="ORC-001",
        name="Spot Price Manipulation",
        category=ExploitCategory.ORACLE,
        severity="critical",
        description="Using spot AMM reserves as price oracle allows flash loan manipulation.",
        code_indicators=["getReserves(", "reserve0", "reserve1", "balanceOf", "price ="],
        missing_protections=["TWAP oracle", "Chainlink price feed", "multi-source oracle"],
        exploit_mechanism="Flash loan → swap to manipulate reserves → read manipulated price → profit → repay.",
        real_world_examples=["Cream Finance ($130M)", "Harvest Finance ($34M)", "Warp Finance"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Is the price derived from spot AMM reserves or balanceOf? These are manipulable via flash loans.",
    ),
    ExploitPattern(
        id="ORC-002",
        name="TWAP Manipulation",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="Short-window TWAP can be manipulated by sustained trading pressure across multiple blocks.",
        code_indicators=["TWAP", "observe(", "consult(", "twapInterval", "cumulativePrice"],
        missing_protections=["Sufficiently long TWAP window", "price deviation circuit breaker"],
        exploit_mechanism="Sustained trading pressure across TWAP window to shift average price.",
        real_world_examples=["Inverse Finance ($15M TWAP manipulation)"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.ORACLE],
        detection_prompt="What is the TWAP window duration? Short windows (< 30 min) are manipulable with sufficient capital.",
        capital_required="substantial (multi-block)",
        atomic=False,
    ),
    ExploitPattern(
        id="ORC-003",
        name="Oracle Staleness Exploitation",
        category=ExploitCategory.ORACLE,
        severity="critical",
        description="Stale price data from oracle allows actions at outdated prices.",
        code_indicators=["latestRoundData(", "updatedAt", "answeredInRound", "roundId"],
        missing_protections=["Staleness check", "heartbeat validation", "require(updatedAt > block.timestamp - MAX_DELAY)"],
        exploit_mechanism="Wait for oracle to go stale → execute trades/liquidations at outdated prices.",
        real_world_examples=["Synthetix oracle delay exploit", "Various protocols during Chainlink delays"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.ORACLE],
        detection_prompt="Is latestRoundData() return value checked for staleness? Is updatedAt compared against a maximum age?",
    ),
    ExploitPattern(
        id="ORC-004",
        name="Oracle Decimals Mismatch",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="Different oracle feeds return prices with different decimal scales, causing valuation errors.",
        code_indicators=["decimals()", "priceFeed", "latestRoundData", "10 **"],
        missing_protections=["Explicit decimal normalization", "feed-specific decimal handling"],
        exploit_mechanism="Mismatched decimals cause collateral to be over/under-valued by orders of magnitude.",
        real_world_examples=["Various multi-oracle protocols"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.ORACLE],
        detection_prompt="Does the protocol normalize oracle decimals? Are different feeds assumed to have the same precision?",
    ),
    ExploitPattern(
        id="ORC-005",
        name="L2 Sequencer Downtime Exploitation",
        category=ExploitCategory.ORACLE,
        severity="high",
        description="On L2, sequencer downtime causes stale prices; unfair liquidations when it restarts.",
        code_indicators=["sequencerUptimeFeed", "isSequencerUp", "GRACE_PERIOD"],
        missing_protections=["Sequencer uptime feed check", "grace period after restart"],
        exploit_mechanism="Prices go stale during downtime → sequencer restarts → liquidate positions at stale prices.",
        real_world_examples=["Arbitrum/Optimism sequencer downtime incidents"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL, ProtocolArchetype.ORACLE],
        detection_prompt="On L2: is sequencer uptime checked? Is there a grace period after restart before allowing liquidations?",
    ),

    # ===== GOVERNANCE (4) =====
    ExploitPattern(
        id="GOV-001",
        name="Flash Loan Governance Attack",
        category=ExploitCategory.GOVERNANCE,
        severity="critical",
        description="Flash loan tokens to gain voting power, create+vote+execute proposal in same transaction.",
        code_indicators=["castVote(", "propose(", "balanceOf", "votingPower", "delegate("],
        missing_protections=["Snapshot-based voting (past block)", "timelock between vote and execution"],
        exploit_mechanism="Flash loan gov tokens → delegate → propose → vote → execute → return tokens.",
        real_world_examples=["Beanstalk Governance ($182M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is voting power snapshot-based (historical block) or current balance? Current balance allows flash loan voting.",
    ),
    ExploitPattern(
        id="GOV-002",
        name="Timelock Bypass",
        category=ExploitCategory.GOVERNANCE,
        severity="critical",
        description="Emergency functions or admin roles bypass timelock, allowing immediate execution.",
        code_indicators=["timelock", "emergency", "bypass", "admin", "owner"],
        missing_protections=["No emergency bypass exists", "multi-sig for emergency", "community veto"],
        exploit_mechanism="Compromised admin uses emergency function to bypass timelock and execute malicious proposal.",
        real_world_examples=["Various DAO governance bypasses"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Are there any functions that bypass the timelock? Can admin/owner execute proposals without delay?",
    ),
    ExploitPattern(
        id="GOV-003",
        name="Quorum Manipulation",
        category=ExploitCategory.GOVERNANCE,
        severity="high",
        description="Low quorum allows minority to pass proposals when participation is low.",
        code_indicators=["quorum", "proposalThreshold", "quorumNumerator"],
        missing_protections=["Dynamic quorum based on participation", "sufficient minimum quorum"],
        exploit_mechanism="Wait for low participation period → propose and vote with minority stake → pass proposal.",
        real_world_examples=["Various DAO low-quorum attacks"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="What is the quorum threshold? Is it dynamic or fixed? Can proposals pass with very low participation?",
        capital_required="governance tokens",
        atomic=False,
    ),
    ExploitPattern(
        id="GOV-004",
        name="Proposal Front-Running",
        category=ExploitCategory.GOVERNANCE,
        severity="medium",
        description="Seeing a proposal in mempool, front-run to gain position before it executes.",
        code_indicators=["execute(", "proposal", "queue("],
        missing_protections=["Private mempool", "commit-reveal voting", "anti-frontrunning delay"],
        exploit_mechanism="See profitable proposal pending → front-run to position before execution → profit from expected state change.",
        real_world_examples=["Various governance proposal front-running"],
        applicable_archetypes=[ProtocolArchetype.GOVERNANCE],
        detection_prompt="Can pending governance proposals be front-run? Is there a way to profit from knowing a proposal will execute?",
    ),

    # ===== BRIDGE (5) =====
    ExploitPattern(
        id="BRG-001",
        name="Cross-Chain Message Replay",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Cross-chain messages can be replayed, causing double-spending.",
        code_indicators=["relayMessage(", "executeMessage(", "messageHash", "nonce"],
        missing_protections=["Nonce tracking per message", "executed message bitmap", "unique hash per message"],
        exploit_mechanism="Replay valid message → claim tokens again → drain bridge.",
        real_world_examples=["Nomad Bridge ($190M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="Is each cross-chain message uniquely identified and tracked as executed? Can a valid message be submitted twice?",
    ),
    ExploitPattern(
        id="BRG-002",
        name="Validator Compromise / Insufficient Threshold",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Bridge validator set has insufficient threshold or single points of failure.",
        code_indicators=["verifySignatures(", "threshold", "validator", "multisig"],
        missing_protections=["Sufficient threshold (2/3+)", "validator diversity", "key rotation"],
        exploit_mechanism="Compromise threshold-many validators → forge cross-chain messages → drain bridge.",
        real_world_examples=["Ronin Bridge ($625M, 2022)", "Harmony Horizon ($100M)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="What is the validator threshold? How many validators need to be compromised to forge messages?",
        capital_required="validator compromise",
        atomic=False,
    ),
    ExploitPattern(
        id="BRG-003",
        name="Token Mapping Mismatch",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Token mapping between chains is incorrect or exploitable, allowing minting of unbacked tokens.",
        code_indicators=["tokenMapping", "wrappedToken", "bridgeToken", "canonicalToken"],
        missing_protections=["Verified bidirectional token mapping", "supply consistency"],
        exploit_mechanism="Exploit incorrect mapping to bridge non-existent token → receive real tokens on destination.",
        real_world_examples=["Wormhole Bridge ($320M, 2022)"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="How is the token mapping verified? Can an attacker register a fake token mapping?",
    ),
    ExploitPattern(
        id="BRG-004",
        name="Withdrawal Proof Forgery",
        category=ExploitCategory.BRIDGE,
        severity="critical",
        description="Insufficient proof verification allows forged proofs to claim bridge funds.",
        code_indicators=["proveWithdrawal(", "verifyProof(", "merkleProof", "stateRoot"],
        missing_protections=["Complete merkle proof verification", "trusted state root source"],
        exploit_mechanism="Forge merkle proof → submit to bridge → claim tokens never deposited.",
        real_world_examples=["Various optimistic bridge exploits"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="How are withdrawal proofs verified? Is the merkle root from a trusted source? Can proofs be forged?",
    ),
    ExploitPattern(
        id="BRG-005",
        name="Relay Race Condition",
        category=ExploitCategory.BRIDGE,
        severity="high",
        description="Race condition between relayers allows message to be processed with outdated state.",
        code_indicators=["relayer", "processMessage(", "relayMessage(", "latestBlock"],
        missing_protections=["Sequential message processing", "state root finality check"],
        exploit_mechanism="Submit message with stale state root during relay delay → execute before state updates.",
        real_world_examples=["Various bridge timing attacks"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE],
        detection_prompt="Can messages be processed out of order or with stale state? Is there a finality check?",
    ),

    # ===== PRECISION / ROUNDING (4) =====
    ExploitPattern(
        id="PREC-001",
        name="Rounding Direction Exploitation",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Consistent favorable rounding allows value extraction through repeated operations.",
        code_indicators=["mulDiv", "Math.Rounding", "/ ", "convertToShares", "convertToAssets"],
        missing_protections=["Round against user (deposits DOWN, withdrawals UP)", "minimum amounts"],
        exploit_mechanism="Repeated deposit/withdraw with amounts that consistently round in attacker's favor.",
        real_world_examples=["Multiple vault rounding exploits"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL],
        detection_prompt="In deposit/mint, does division round DOWN (against depositor)? In withdraw/redeem, does it round UP (against withdrawer)?",
    ),
    ExploitPattern(
        id="PREC-002",
        name="Phantom Overflow in Unchecked Blocks",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="critical",
        description="Arithmetic inside unchecked{} blocks silently overflows/underflows.",
        code_indicators=["unchecked {", "unchecked{"],
        missing_protections=["Explicit bounds checking inside unchecked", "input validation before unchecked"],
        exploit_mechanism="Craft input that causes overflow inside unchecked → wrap around to unexpected value.",
        real_world_examples=["Various Solidity 0.8+ unchecked block bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.TOKEN],
        detection_prompt="What arithmetic operations are inside unchecked{} blocks? Can any of them overflow/underflow with attacker-controlled inputs?",
    ),
    ExploitPattern(
        id="PREC-003",
        name="Fee-on-Transfer Token Accounting",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Protocol uses transfer amount for accounting instead of actual received amount.",
        code_indicators=["transferFrom(", "amount", "balanceOf"],
        missing_protections=["Pre/post balance delta check", "fee-on-transfer token handling"],
        exploit_mechanism="Deposit fee-on-transfer token → protocol credits full amount → withdraw more than deposited.",
        real_world_examples=["SushiSwap fee-on-transfer issues", "Various DeFi protocols"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="After transferFrom, does the protocol use 'amount' or the actual balance delta for accounting?",
    ),
    ExploitPattern(
        id="PREC-004",
        name="Rebasing Token Balance Drift",
        category=ExploitCategory.PRECISION_ROUNDING,
        severity="high",
        description="Rebasing token balance changes without transfers, causing accounting drift.",
        code_indicators=["balanceOf", "totalAssets", "shares", "rebase"],
        missing_protections=["Wrapped token usage", "rebase-aware internal accounting"],
        exploit_mechanism="Rebase changes actual balance → protocol's tracked balance diverges → exploitable gap.",
        real_world_examples=["stETH integration issues across multiple protocols"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.STAKING],
        detection_prompt="Does the protocol handle rebasing tokens? Does it track balances internally or rely on balanceOf?",
    ),

    # ===== ACCESS CONTROL (5) =====
    ExploitPattern(
        id="AC-001",
        name="Uninitialized Proxy",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Implementation contract is not initialized, allowing attacker to call initialize() and take ownership.",
        code_indicators=["initialize(", "Initializable", "initializer", "proxy"],
        missing_protections=["_disableInitializers() in constructor", "initialized check"],
        exploit_mechanism="Call initialize() on implementation contract → become owner → selfdestruct or manipulate.",
        real_world_examples=["Wormhole uninitialized proxy", "Audius ($6M)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is the implementation contract initialized? Does the constructor call _disableInitializers()?",
    ),
    ExploitPattern(
        id="AC-002",
        name="Storage Collision in Proxy Upgrade",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="New variables in upgraded implementation collide with existing storage layout.",
        code_indicators=["UUPSUpgradeable", "TransparentProxy", "__gap", "upgradeTo("],
        missing_protections=["Storage gap arrays (__gap)", "append-only storage layout"],
        exploit_mechanism="Upgrade adds new variable → overwrites existing storage → corrupts state (balances, ownership).",
        real_world_examples=["Various proxy upgrade storage collision bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE],
        detection_prompt="Do all base contracts have __gap storage arrays? Is the storage layout append-only across upgrades?",
    ),
    ExploitPattern(
        id="AC-003",
        name="Phantom Function / Selector Collision",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Two functions have the same 4-byte selector, causing proxy to route to wrong implementation.",
        code_indicators=["fallback()", "delegatecall", "selector", "proxy"],
        missing_protections=["Selector collision check", "transparent proxy pattern"],
        exploit_mechanism="Attacker calls function with colliding selector → proxy routes to unintended function.",
        real_world_examples=["Poly Network ($611M) — function selector issues"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Are there any function selector collisions? Does the proxy properly separate admin and user function spaces?",
    ),
    ExploitPattern(
        id="AC-004",
        name="Delegatecall to User-Controlled Target",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="Contract delegatecalls to an address controlled by the user.",
        code_indicators=["delegatecall(", "target", "implementation"],
        missing_protections=["Whitelist of valid delegatecall targets", "hardcoded implementation"],
        exploit_mechanism="Pass malicious contract as target → delegatecall executes attacker's code in protocol's context.",
        real_world_examples=["Poly Network ($611M)", "Various proxy exploits"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL],
        detection_prompt="Does any function delegatecall to a user-provided address? Is the target hardcoded or validated?",
    ),
    ExploitPattern(
        id="AC-005",
        name="Missing initialize() Access Control",
        category=ExploitCategory.ACCESS_CONTROL,
        severity="critical",
        description="initialize() function lacks access control, allowing anyone to re-initialize after deployment.",
        code_indicators=["initialize(", "initializer", "onlyInitializing"],
        missing_protections=["initializer modifier", "initialized state variable check"],
        exploit_mechanism="Call initialize() again → reset ownership/state → take control.",
        real_world_examples=["Audius ($6M re-initialization)"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Can initialize() be called more than once? Does it have the initializer modifier?",
    ),

    # ===== ECONOMIC / DEFI (8) =====
    ExploitPattern(
        id="ECON-001",
        name="Sandwich Attack",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="MEV bot front-runs and back-runs a swap transaction to extract value.",
        code_indicators=["swap(", "amountOutMin", "deadline", "slippage"],
        missing_protections=["Slippage protection (amountOutMin)", "transaction deadline", "private mempool"],
        exploit_mechanism="See pending swap → front-run buy → user swaps at worse price → back-run sell → profit.",
        real_world_examples=["Extremely common MEV attack on all DEXes"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.DEX_ORDERBOOK],
        detection_prompt="Does swap() enforce minimum output amount and deadline? Without both, swaps are vulnerable to sandwich attacks.",
    ),
    ExploitPattern(
        id="ECON-002",
        name="JIT Liquidity Attack",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="medium",
        description="Just-in-time liquidity provision to capture fees from pending large swap.",
        code_indicators=["addLiquidity(", "removeLiquidity(", "mint(", "burn("],
        missing_protections=["Minimum liquidity duration", "fee vesting"],
        exploit_mechanism="See pending large swap → add concentrated liquidity → swap executes → remove liquidity with fees.",
        real_world_examples=["Common on Uniswap V3 concentrated liquidity"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM],
        detection_prompt="Can liquidity be added and removed in the same block? Is there a minimum duration for fee accrual?",
    ),
    ExploitPattern(
        id="ECON-003",
        name="Bad Debt Cascade",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="critical",
        description="Underwater position creates cascading liquidations and socialized bad debt.",
        code_indicators=["liquidat", "healthFactor", "collateral", "borrow(", "shortfall"],
        missing_protections=["Bad debt socialization mechanism", "reserve fund", "position limits"],
        exploit_mechanism="Create leveraged position → price drops fast → liquidation unprofitable → bad debt cascades.",
        real_world_examples=["Euler Finance ($197M)", "Venus Protocol bad debt"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="What happens when liquidation doesn't cover debt? Is there a bad debt handling or socialization mechanism?",
    ),
    ExploitPattern(
        id="ECON-004",
        name="Interest Rate Manipulation",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Flash loan manipulates utilization rate to spike interest for existing borrowers.",
        code_indicators=["interestRate", "utilization", "borrowRate", "totalBorrows", "totalDeposits"],
        missing_protections=["Rate smoothing", "utilization caps", "flash loan detection in rate calc"],
        exploit_mechanism="Flash loan borrow → spike utilization → interest accrues at inflated rate → repay flash loan.",
        real_world_examples=["Various lending protocol rate manipulation"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="Is interest rate based on current utilization? Can a flash loan temporarily spike it?",
    ),
    ExploitPattern(
        id="ECON-005",
        name="Liquidation Front-Running",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="MEV bots front-run liquidation transactions to extract liquidation bonuses.",
        code_indicators=["liquidat", "liquidationBonus", "liquidationIncentive"],
        missing_protections=["Private liquidation period", "Dutch auction liquidation"],
        exploit_mechanism="Monitor mempool → front-run liquidation call → claim liquidation bonus.",
        real_world_examples=["Common on all lending protocols"],
        applicable_archetypes=[ProtocolArchetype.LENDING_POOL],
        detection_prompt="Can liquidations be front-run? Is there a mechanism to prevent MEV extraction from liquidation bonuses?",
    ),
    ExploitPattern(
        id="ECON-006",
        name="MEV Extraction via Transaction Ordering",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="medium",
        description="Protocol operations are sensitive to transaction ordering in the block.",
        code_indicators=["block.timestamp", "block.number", "oracle update", "price update"],
        missing_protections=["Commit-reveal scheme", "batch auction", "order-independent pricing"],
        exploit_mechanism="Reorder transactions within block to extract maximum value from protocol operations.",
        real_world_examples=["Common across all DeFi protocols"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Are any protocol operations sensitive to transaction ordering? Can reordering provide an advantage?",
    ),
    ExploitPattern(
        id="ECON-007",
        name="Returndata Bomb",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Malicious contract returns massive returndata, consuming all gas in memory expansion.",
        code_indicators=[".call(", "abi.decode", "returndatasize", "returndata"],
        missing_protections=["Gas limit on external calls", "returndata size check", "assembly-level protection"],
        exploit_mechanism="Target makes low-level call → malicious contract returns huge data → gas consumed by memory expansion → DoS.",
        real_world_examples=["Various returndata bomb DoS attacks"],
        applicable_archetypes=[ProtocolArchetype.BRIDGE, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Does any function make a low-level call without limiting gas or checking returndata size?",
    ),
    ExploitPattern(
        id="ECON-008",
        name="Signature Replay Across Forks",
        category=ExploitCategory.ECONOMIC_DEFI,
        severity="high",
        description="Cached DOMAIN_SEPARATOR allows signature replay after chain fork.",
        code_indicators=["DOMAIN_SEPARATOR", "ecrecover", "block.chainid", "EIP712"],
        missing_protections=["Runtime chainid check", "DOMAIN_SEPARATOR recomputation"],
        exploit_mechanism="After chain fork, replay signatures from original chain on forked chain.",
        real_world_examples=["Post-merge Ethereum fork replay concerns"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Is DOMAIN_SEPARATOR computed at runtime with block.chainid, or cached in constructor? Cached = replay risk.",
    ),

    # ===== LOGIC (6) =====
    ExploitPattern(
        id="LOG-001",
        name="Off-by-One Bounds Error",
        category=ExploitCategory.LOGIC,
        severity="medium",
        description="Loop or array bounds off by one, causing missed elements or out-of-bounds access.",
        code_indicators=["for (", "< length", "<= length", "i++", "array[i]"],
        missing_protections=["Correct bounds checking (< vs <=)", "array length validation"],
        exploit_mechanism="Off-by-one allows processing one extra/fewer element, causing state inconsistency.",
        real_world_examples=["Various smart contract off-by-one bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.GOVERNANCE],
        detection_prompt="Check all loop bounds: should it be < or <=? Does the loop process all elements or miss the last one?",
    ),
    ExploitPattern(
        id="LOG-002",
        name="Incorrect Comparison Operator",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Wrong comparison operator (> vs >=, < vs <=) causes boundary condition failures.",
        code_indicators=["require(", "if (", ">", "<", ">=", "<=", "=="],
        missing_protections=["Correct operator for boundary condition"],
        exploit_mechanism="Boundary value passes/fails check incorrectly, allowing unauthorized action or blocking valid action.",
        real_world_examples=["Various smart contract logic bugs"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.DEX_AMM, ProtocolArchetype.STAKING],
        detection_prompt="Check all comparison operators in require/if statements. Should it be > or >=? Are boundary values handled correctly?",
    ),
    ExploitPattern(
        id="LOG-003",
        name="Missing Deadline Check",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Transaction has no expiration, allowing it to be held in mempool and executed at unfavorable time.",
        code_indicators=["deadline", "block.timestamp", "expiry", "validUntil"],
        missing_protections=["require(block.timestamp <= deadline)", "transaction expiration"],
        exploit_mechanism="Hold transaction in mempool → execute when market conditions are unfavorable for user.",
        real_world_examples=["Common DEX transaction replay/delay attacks"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.DEX_ORDERBOOK, ProtocolArchetype.NFT_MARKETPLACE],
        detection_prompt="Do time-sensitive operations (swaps, orders) have a deadline parameter that's checked?",
    ),
    ExploitPattern(
        id="LOG-004",
        name="Missing Slippage Protection",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="No minimum output amount check allows unlimited slippage.",
        code_indicators=["swap(", "amountOut", "minAmount", "slippage"],
        missing_protections=["minAmountOut parameter", "require(amountOut >= minAmountOut)"],
        exploit_mechanism="Without minimum output check, sandwich attacks can extract unlimited value.",
        real_world_examples=["Extremely common vulnerability in DEX integrations"],
        applicable_archetypes=[ProtocolArchetype.DEX_AMM, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="Is there a minimum output amount check? Can a user lose all value through slippage?",
    ),
    ExploitPattern(
        id="LOG-005",
        name="Unchecked Low-Level Call Return",
        category=ExploitCategory.LOGIC,
        severity="high",
        description="Return value from low-level call/send not checked, silently failing.",
        code_indicators=[".call(", ".send(", "(bool success", "success"],
        missing_protections=["require(success)", "if (!success) revert"],
        exploit_mechanism="Call fails silently → state assumes success → inconsistent state.",
        real_world_examples=["Various protocols with unchecked calls"],
        applicable_archetypes=[ProtocolArchetype.VAULT_ERC4626, ProtocolArchetype.LENDING_POOL, ProtocolArchetype.BRIDGE, ProtocolArchetype.DEX_AMM],
        detection_prompt="Are all low-level call return values checked? Is the success boolean verified?",
    ),
    ExploitPattern(
        id="LOG-006",
        name="Self-Transfer Accounting Error",
        category=ExploitCategory.LOGIC,
        severity="medium",
        description="Transfer to self causes double-counting or balance corruption.",
        code_indicators=["transfer(", "from", "to", "balances["],
        missing_protections=["require(from != to)", "self-transfer handling"],
        exploit_mechanism="Transfer to self → balance deducted then added → potential overflow or state corruption.",
        real_world_examples=["Various token self-transfer bugs"],
        applicable_archetypes=[ProtocolArchetype.TOKEN, ProtocolArchetype.VAULT_ERC4626],
        detection_prompt="What happens when from == to in a transfer? Does the accounting handle self-transfers correctly?",
    ),
]


# ---------------------------------------------------------------------------
# Public API
# ---------------------------------------------------------------------------

class ExploitKnowledgeBase:
    """Queryable knowledge base of exploit patterns."""

    def __init__(self):
        self._patterns = list(_ALL_PATTERNS)
        self._by_id: Dict[str, ExploitPattern] = {p.id: p for p in self._patterns}
        self._by_category: Dict[ExploitCategory, List[ExploitPattern]] = {}
        for p in self._patterns:
            self._by_category.setdefault(p.category, []).append(p)

    @property
    def all_patterns(self) -> List[ExploitPattern]:
        return list(self._patterns)

    def get_by_id(self, pattern_id: str) -> Optional[ExploitPattern]:
        return self._by_id.get(pattern_id)

    def get_by_category(self, category: ExploitCategory) -> List[ExploitPattern]:
        return list(self._by_category.get(category, []))

    def get_for_archetype(self, archetype: ProtocolArchetype) -> List[ExploitPattern]:
        """Get all patterns applicable to a specific protocol archetype."""
        return [p for p in self._patterns if archetype in p.applicable_archetypes]

    def get_for_archetypes(self, archetypes: List[ProtocolArchetype]) -> List[ExploitPattern]:
        """Get patterns applicable to any of the given archetypes."""
        archetype_set = set(archetypes)
        return [p for p in self._patterns
                if any(a in archetype_set for a in p.applicable_archetypes)]

    def get_critical_patterns(self) -> List[ExploitPattern]:
        """Get all critical severity patterns."""
        return [p for p in self._patterns if p.severity == "critical"]

    def search(self, query: str) -> List[ExploitPattern]:
        """Search patterns by keyword in name, description, or exploit mechanism."""
        q = query.lower()
        return [p for p in self._patterns
                if q in p.name.lower()
                or q in p.description.lower()
                or q in p.exploit_mechanism.lower()]

    def format_for_prompt(self, patterns: Optional[List[ExploitPattern]] = None,
                          max_patterns: int = 25) -> str:
        """Format patterns as a prompt section for LLM consumption."""
        if patterns is None:
            patterns = self._patterns
        patterns = patterns[:max_patterns]

        lines = ["## Known Exploit Patterns (Real-World Precedents)", ""]
        for i, p in enumerate(patterns, 1):
            lines.append(f"### {i}. {p.name} [{p.severity.upper()}] ({p.id})")
            lines.append(f"**Pattern**: {p.description}")
            lines.append(f"**Code indicators**: {', '.join(p.code_indicators)}")
            lines.append(f"**Missing protections**: {', '.join(p.missing_protections)}")
            lines.append(f"**Exploit**: {p.exploit_mechanism}")
            lines.append(f"**Real-world**: {', '.join(p.real_world_examples)}")
            lines.append(f"**Check**: {p.detection_prompt}")
            lines.append("")
        return "\n".join(lines)

    def format_for_focus_areas(self, focus_areas: List[str]) -> str:
        """Get patterns relevant to focus areas and format for prompt.

        Maps focus area strings to categories/archetypes and returns formatted
        patterns. Falls back to all patterns if no mapping found.
        """
        # Map focus areas to categories
        _FOCUS_MAP: Dict[str, List[ExploitCategory]] = {
            'access_control': [ExploitCategory.ACCESS_CONTROL],
            'reentrancy': [ExploitCategory.REENTRANCY],
            'amm': [ExploitCategory.INFLATION_SHARE, ExploitCategory.ECONOMIC_DEFI],
            'lending': [ExploitCategory.ORACLE, ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE],
            'governance': [ExploitCategory.GOVERNANCE],
            'external_calls': [ExploitCategory.REENTRANCY, ExploitCategory.ECONOMIC_DEFI],
            'delegatecall': [ExploitCategory.ACCESS_CONTROL],
            'arithmetic': [ExploitCategory.PRECISION_ROUNDING],
            'precision': [ExploitCategory.PRECISION_ROUNDING],
            'precision_loss': [ExploitCategory.PRECISION_ROUNDING],
            'logic_errors': [ExploitCategory.LOGIC, ExploitCategory.REENTRANCY],
            'privilege': [ExploitCategory.ACCESS_CONTROL],
            'complex_logic': [ExploitCategory.LOGIC, ExploitCategory.INFLATION_SHARE],
            'economic': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE],
            'economic_attacks': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE],
            'oracle_manipulation': [ExploitCategory.ORACLE],
            'overflow': [ExploitCategory.PRECISION_ROUNDING],
            'underflow': [ExploitCategory.PRECISION_ROUNDING],
            'cross_contract': [ExploitCategory.REENTRANCY, ExploitCategory.BRIDGE],
            'invariant_violations': [ExploitCategory.INFLATION_SHARE, ExploitCategory.LOGIC],
            'flash_loan': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE, ExploitCategory.ORACLE],
            'defi': [ExploitCategory.ECONOMIC_DEFI, ExploitCategory.INFLATION_SHARE, ExploitCategory.ORACLE],
            'bridge': [ExploitCategory.BRIDGE],
        }

        categories: Set[ExploitCategory] = set()
        for area in focus_areas:
            key = area.lower().replace(' ', '_').replace('-', '_')
            if key in _FOCUS_MAP:
                categories.update(_FOCUS_MAP[key])

        if not categories:
            return self.format_for_prompt()

        patterns = []
        seen: Set[str] = set()
        for cat in categories:
            for p in self.get_by_category(cat):
                if p.id not in seen:
                    patterns.append(p)
                    seen.add(p.id)
        return self.format_for_prompt(patterns)
