#!/usr/bin/env python3
"""
DeFi-Specific Vulnerability Detector

Specialized detector for DeFi protocol vulnerabilities including:
- Liquidation logic vulnerabilities
- Governance attacks
- MEV extraction patterns

Note: Oracle manipulation is handled by oracle_manipulation_detector.py (8 oracle types).
Flash loan detection is handled by mev_detector.py.
"""

import re
from typing import Dict, List, Any
from dataclasses import dataclass
from enum import Enum


class VulnerabilityType(Enum):
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN_ATTACK = "flash_loan_attack"
    LIQUIDATION_MANIPULATION = "liquidation_manipulation"
    GOVERNANCE_ATTACK = "governance_attack"
    MEV_EXTRACTION = "mev_extraction"
    REENTRANCY = "reentrancy"
    ACCESS_CONTROL = "access_control"
    ARITHMETIC_ERROR = "arithmetic_error"


@dataclass
class DeFiVulnerability:
    """DeFi-specific vulnerability representation."""
    vuln_type: VulnerabilityType
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    attack_vector: str
    financial_impact: str
    exploit_complexity: str
    immunefi_bounty_potential: str
    poc_suggestion: str
    fix_suggestion: str
    context: Dict[str, Any]


class DeFiVulnerabilityDetector:
    """Advanced DeFi vulnerability detector with specialized patterns."""

    def __init__(self):
        self.patterns = self._initialize_defi_patterns()
        self.governance_patterns = self._initialize_governance_patterns()

    def _initialize_defi_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize DeFi-specific vulnerability patterns.

        Two-stage detection: identify DeFi primitive, then check for MISSING protections.
        Only flags when required protection is absent.
        """
        return {
            "liquidation_manipulation": [
                {
                    "pattern": r"liquidate\(|liquidationCall\(",
                    "severity": "medium",
                    "confidence": 0.5,
                    "description": "Liquidation function - check for proper health factor validation and bounds",
                    "attack_vector": "Liquidation manipulation through missing bounds checks",
                    "financial_impact": "Medium - Unfair liquidation parameters",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate liquidation with manipulated parameters",
                    "fix_suggestion": "Add health factor validation, liquidation discount bounds, and close factor limits",
                    "required_protections": [
                        r"healthFactor|health_factor|isHealthy",
                        r"liquidationBonus|liquidationDiscount|closeFactor|maxLiquidation",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "governance_attack": [
                {
                    "pattern": r"execute\([^)]*proposal",
                    "severity": "high",
                    "confidence": 0.6,
                    "description": "Governance execution without sufficient protection mechanisms",
                    "attack_vector": "Governance proposal manipulation or flash-loan voting",
                    "financial_impact": "High - Protocol control takeover",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate governance attack via flash loan voting",
                    "fix_suggestion": "Add timelock, quorum validation, and snapshot-based voting power",
                    "required_protections": [
                        r"timelock|TimelockController|delay|executionDelay",
                        r"quorum|minQuorum|quorumReached",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "mev_extraction": [
                {
                    "pattern": r"swap\([^)]*\)|swapExact",
                    "severity": "medium",
                    "confidence": 0.5,
                    "description": "Swap function without slippage protection or deadline",
                    "attack_vector": "Sandwich attack / MEV extraction due to missing slippage control",
                    "financial_impact": "Medium - MEV extraction from users",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Demonstrate sandwich attack on unprotected swap",
                    "fix_suggestion": "Add minAmountOut/amountOutMin slippage parameter and deadline check",
                    "required_protections": [
                        r"amountOutMin|minAmountOut|minAmount|slippage",
                        r"deadline|block\.timestamp\s*<=|expiry",
                    ],
                    "min_protections_required": 1,
                }
            ]
        }

    def _initialize_governance_patterns(self) -> Dict[str, List[str]]:
        """Initialize governance-specific patterns."""
        return {
            "proposal": [
                r"propose\(|createProposal\(",
                r"proposalId|proposalHash"
            ],
            "voting": [
                r"vote\(|castVote\(",
                r"votingPower|voteWeight"
            ],
            "execution": [
                r"execute\(|executeProposal\(",
                r"executionDelay|timelock"
            ]
        }

    def analyze_contract(self, contract_path: str, content: str) -> List[DeFiVulnerability]:
        """Analyze contract for DeFi-specific vulnerabilities."""
        vulnerabilities = []
        lines = content.split('\n')
        
        # Analyze each vulnerability type (two-stage detection)
        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info["pattern"]
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)

                for match in regex.finditer(content):
                    line_number = content[:match.start()].count('\n') + 1

                    # Stage 2: Check for required protections
                    required_protections = pattern_info.get("required_protections", [])
                    min_required = pattern_info.get("min_protections_required", 1)

                    protections_found = 0
                    protections_present = []
                    for protection_pattern in required_protections:
                        if re.search(protection_pattern, content, re.IGNORECASE):
                            protections_found += 1
                            protections_present.append(protection_pattern)

                    # Skip if sufficient protections are present
                    if protections_found >= min_required:
                        continue

                    # Extract code snippet with context
                    start_line = max(0, line_number - 3)
                    end_line = min(len(lines), line_number + 3)
                    code_snippet = '\n'.join(lines[start_line:end_line])

                    # Adjust confidence based on how many protections are missing
                    missing_count = len(required_protections) - protections_found
                    confidence_boost = min(0.2, missing_count * 0.1)
                    adjusted_confidence = min(1.0, pattern_info["confidence"] + confidence_boost)

                    vulnerability = DeFiVulnerability(
                        vuln_type=VulnerabilityType(vuln_type),
                        severity=pattern_info["severity"],
                        confidence=adjusted_confidence,
                        line_number=line_number,
                        description=pattern_info["description"],
                        code_snippet=code_snippet,
                        attack_vector=pattern_info["attack_vector"],
                        financial_impact=pattern_info["financial_impact"],
                        exploit_complexity=pattern_info["exploit_complexity"],
                        immunefi_bounty_potential=pattern_info["immunefi_bounty_potential"],
                        poc_suggestion=pattern_info["poc_suggestion"],
                        fix_suggestion=pattern_info["fix_suggestion"],
                        context={
                            "pattern_match": match.group(),
                            "contract_path": contract_path,
                            "vulnerability_type": vuln_type,
                            "protections_found": protections_present,
                            "protections_missing": [p for p in required_protections if p not in protections_present],
                        }
                    )

                    # Apply additional validation
                    if self._validate_defi_vulnerability(vulnerability, content):
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    def _validate_defi_vulnerability(self, vulnerability: DeFiVulnerability, content: str) -> bool:
        """Validate DeFi vulnerability with additional context checks."""
        
        # Check for mitigation patterns
        mitigation_patterns = {
            "liquidation_manipulation": [
                r"liquidation.*protection|antiLiquidation",
                r"healthFactor.*validation",
                r"liquidation.*threshold"
            ],
            "governance_attack": [
                r"governance.*protection|antiGovernance",
                r"timelock|executionDelay",
                r"quorum.*validation"
            ]
        }
        
        vuln_type = vulnerability.vuln_type.value
        if vuln_type in mitigation_patterns:
            for pattern in mitigation_patterns[vuln_type]:
                if re.search(pattern, content, re.IGNORECASE):
                    # Mitigation found, reduce confidence
                    vulnerability.confidence *= 0.5
                    vulnerability.context["mitigation_found"] = pattern
        
        # Only report vulnerabilities with sufficient confidence
        return vulnerability.confidence > 0.6

    def generate_poc_suggestion(self, vulnerability: DeFiVulnerability) -> str:
        """Generate proof-of-concept suggestion for vulnerability."""
        
        poc_templates = {
            "liquidation_manipulation": """
// Liquidation Manipulation PoC
contract LiquidationAttack {
    function exploitLiquidation() external {
        // 1. Manipulate health factor
        // 2. Trigger unfair liquidation
        // 3. Profit from liquidation
    }
}
            """,
            "governance_attack": """
// Governance Attack PoC
contract GovernanceAttack {
    function exploitGovernance() external {
        // 1. Manipulate voting power
        // 2. Execute malicious proposal
        // 3. Take control of protocol
    }
}
            """
        }
        
        vuln_type = vulnerability.vuln_type.value
        return poc_templates.get(vuln_type, "// PoC template not available")

    def get_immunefi_bounty_estimate(self, vulnerability: DeFiVulnerability) -> str:
        """Estimate Immunefi bounty potential for vulnerability."""
        
        bounty_ranges = {
            "critical": "$50,000 - $2,000,000",
            "high": "$10,000 - $250,000", 
            "medium": "$1,000 - $50,000",
            "low": "$500 - $5,000"
        }
        
        return bounty_ranges.get(vulnerability.severity, "Unknown")

    def generate_comprehensive_report(self, vulnerabilities: List[DeFiVulnerability]) -> Dict[str, Any]:
        """Generate comprehensive DeFi vulnerability report."""
        
        report = {
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len([v for v in vulnerabilities if v.severity == "critical"]),
                "high_count": len([v for v in vulnerabilities if v.severity == "high"]),
                "medium_count": len([v for v in vulnerabilities if v.severity == "medium"]),
                "low_count": len([v for v in vulnerabilities if v.severity == "low"])
            },
            "vulnerabilities": [],
            "recommendations": [],
            "bounty_potential": {
                "estimated_total": "$0",
                "breakdown": {}
            }
        }
        
        # Process vulnerabilities
        for vuln in vulnerabilities:
            vuln_data = {
                "type": vuln.vuln_type.value,
                "severity": vuln.severity,
                "confidence": vuln.confidence,
                "line_number": vuln.line_number,
                "description": vuln.description,
                "attack_vector": vuln.attack_vector,
                "financial_impact": vuln.financial_impact,
                "exploit_complexity": vuln.exploit_complexity,
                "immunefi_bounty_potential": vuln.immunefi_bounty_potential,
                "poc_suggestion": vuln.poc_suggestion,
                "fix_suggestion": vuln.fix_suggestion,
                "code_snippet": vuln.code_snippet
            }
            report["vulnerabilities"].append(vuln_data)
        
        # Generate recommendations
        unique_fixes = set(v.fix_suggestion for v in vulnerabilities)
        report["recommendations"] = list(unique_fixes)
        
        # Calculate bounty potential
        bounty_total = 0
        for vuln in vulnerabilities:
            bounty_range = vuln.immunefi_bounty_potential
            # Extract minimum bounty value
            min_bounty = re.search(r'\$([0-9,]+)', bounty_range)
            if min_bounty:
                min_value = int(min_bounty.group(1).replace(',', ''))
                bounty_total += min_value
        
        report["bounty_potential"]["estimated_total"] = f"${bounty_total:,}"
        
        return report
