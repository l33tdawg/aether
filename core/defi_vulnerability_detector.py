#!/usr/bin/env python3
"""
DeFi-Specific Vulnerability Detector

Specialized detector for DeFi protocol vulnerabilities including:
- Oracle manipulation attacks
- Flash loan exploits
- Liquidation logic vulnerabilities
- Governance attacks
- MEV extraction patterns
"""

import re
import json
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class VulnerabilityType(Enum):
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN_ATTACK = "flash_loan_attack"
    LIQUIDATION_MANIPULATION = "liquidation_manipulation"
    GOVERNANCE_ATTACK = "governance_attack"
    MEV_EXTRACTION = "mev_extraction"
    REENTRANCY = "reentrancy"
    ACCESS_CONTROL = "access_control"
    ARITHMETIC_ERROR = "arithmetic_error"


@dataclass
class DeFiVulnerability:
    """DeFi-specific vulnerability representation."""
    vuln_type: VulnerabilityType
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    attack_vector: str
    financial_impact: str
    exploit_complexity: str
    immunefi_bounty_potential: str
    poc_suggestion: str
    fix_suggestion: str
    context: Dict[str, Any]


class DeFiVulnerabilityDetector:
    """Advanced DeFi vulnerability detector with specialized patterns."""

    def __init__(self):
        self.patterns = self._initialize_defi_patterns()
        self.oracle_patterns = self._initialize_oracle_patterns()
        self.flash_loan_patterns = self._initialize_flash_loan_patterns()
        self.governance_patterns = self._initialize_governance_patterns()

    def _initialize_defi_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize DeFi-specific vulnerability patterns.

        Two-stage detection: identify DeFi primitive, then check for MISSING protections.
        Only flags when required protection is absent.
        """
        return {
            "oracle_manipulation": [
                {
                    "pattern": r"latestRoundData\(\)",
                    "severity": "high",
                    "confidence": 0.7,
                    "description": "Chainlink oracle usage without complete validation",
                    "attack_vector": "Stale/invalid price exploitation",
                    "financial_impact": "High - Incorrect pricing leads to fund loss",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate stale price exploitation",
                    "fix_suggestion": "Add complete validation: updatedAt freshness, answeredInRound >= roundId, answer > 0",
                    "required_protections": [
                        r"updatedAt.*block\.timestamp|block\.timestamp.*updatedAt",
                        r"answeredInRound\s*>=\s*roundId|roundId\s*<=\s*answeredInRound",
                        r"answer\s*>\s*0|price\s*>\s*0",
                    ],
                    "min_protections_required": 2,
                },
                {
                    "pattern": r"getPrice\(\)|getLatestPrice\(\)|latestAnswer\(\)",
                    "severity": "medium",
                    "confidence": 0.6,
                    "description": "Price oracle access - check for staleness and validity protections",
                    "attack_vector": "Stale or manipulated price exploitation",
                    "financial_impact": "Medium - Stale price attacks",
                    "exploit_complexity": "Low",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Show stale price attack",
                    "fix_suggestion": "Add timestamp validation and price bounds checks",
                    "required_protections": [
                        r"updatedAt|timestamp.*check|freshness|maxAge|staleness",
                        r"price\s*>\s*0|answer\s*>\s*0",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "flash_loan_attack": [
                {
                    "pattern": r"flashLoan\(|flashBorrow\(",
                    "severity": "high",
                    "confidence": 0.6,
                    "description": "Flash loan initiation without proper callback validation",
                    "attack_vector": "Flash loan callback manipulation",
                    "financial_impact": "High - Potential protocol drain via callback exploit",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$50,000-$2,000,000",
                    "poc_suggestion": "Demonstrate flash loan callback exploitation",
                    "fix_suggestion": "Validate flash loan initiator, enforce repayment, use callback whitelist",
                    "required_protections": [
                        r"msg\.sender\s*==\s*(pool|lender|flashLoan)|onlyPool|onlyLender",
                        r"nonReentrant|reentrancyGuard|ReentrancyGuard",
                    ],
                    "min_protections_required": 1,
                },
                {
                    "pattern": r"receiveFlashLoan\(|onFlashLoan\(|executeOperation\(",
                    "severity": "high",
                    "confidence": 0.6,
                    "description": "Flash loan callback without initiator validation",
                    "attack_vector": "Unauthorized flash loan callback invocation",
                    "financial_impact": "High - Callback exploitation",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Show unauthorized callback invocation",
                    "fix_suggestion": "Validate callback caller is the expected lending pool",
                    "required_protections": [
                        r"msg\.sender\s*==\s*(pool|lender|POOL|LENDING_POOL)",
                        r"initiator\s*==\s*address\(this\)|msg\.sender\s*==\s*address\(this\)",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "liquidation_manipulation": [
                {
                    "pattern": r"liquidate\(|liquidationCall\(",
                    "severity": "medium",
                    "confidence": 0.5,
                    "description": "Liquidation function - check for proper health factor validation and bounds",
                    "attack_vector": "Liquidation manipulation through missing bounds checks",
                    "financial_impact": "Medium - Unfair liquidation parameters",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate liquidation with manipulated parameters",
                    "fix_suggestion": "Add health factor validation, liquidation discount bounds, and close factor limits",
                    "required_protections": [
                        r"healthFactor|health_factor|isHealthy",
                        r"liquidationBonus|liquidationDiscount|closeFactor|maxLiquidation",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "governance_attack": [
                {
                    "pattern": r"execute\([^)]*proposal",
                    "severity": "high",
                    "confidence": 0.6,
                    "description": "Governance execution without sufficient protection mechanisms",
                    "attack_vector": "Governance proposal manipulation or flash-loan voting",
                    "financial_impact": "High - Protocol control takeover",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate governance attack via flash loan voting",
                    "fix_suggestion": "Add timelock, quorum validation, and snapshot-based voting power",
                    "required_protections": [
                        r"timelock|TimelockController|delay|executionDelay",
                        r"quorum|minQuorum|quorumReached",
                    ],
                    "min_protections_required": 1,
                }
            ],
            "mev_extraction": [
                {
                    "pattern": r"swap\([^)]*\)|swapExact",
                    "severity": "medium",
                    "confidence": 0.5,
                    "description": "Swap function without slippage protection or deadline",
                    "attack_vector": "Sandwich attack / MEV extraction due to missing slippage control",
                    "financial_impact": "Medium - MEV extraction from users",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Demonstrate sandwich attack on unprotected swap",
                    "fix_suggestion": "Add minAmountOut/amountOutMin slippage parameter and deadline check",
                    "required_protections": [
                        r"amountOutMin|minAmountOut|minAmount|slippage",
                        r"deadline|block\.timestamp\s*<=|expiry",
                    ],
                    "min_protections_required": 1,
                }
            ]
        }

    def _initialize_oracle_patterns(self) -> Dict[str, List[str]]:
        """Initialize oracle-specific patterns."""
        return {
            "price_feeds": [
                r"Chainlink|PriceFeed|AggregatorV3",
                r"latestRoundData|getRoundData",
                r"decimals\(\)|description\(\)"
            ],
            "validation": [
                r"require\(.*price.*>.*0\)",
                r"require\(.*timestamp.*>.*0\)",
                r"require\(.*roundId.*>.*0\)"
            ],
            "manipulation": [
                r"price.*=.*oracle\.getPrice\(\)",
                r"price.*=.*feed\.latestRoundData\(\)",
                r"price.*=.*aggregator\.latestAnswer\(\)"
            ]
        }

    def _initialize_flash_loan_patterns(self) -> Dict[str, List[str]]:
        """Initialize flash loan specific patterns."""
        return {
            "initiation": [
                r"flashLoan\(|borrow\(.*amount.*\)",
                r"initiateFlashLoan|startFlashLoan"
            ],
            "callback": [
                r"receiveFlashLoan\(|onFlashLoan\(",
                r"flashLoanCallback|flashLoanReceiver"
            ],
            "validation": [
                r"require\(.*flashLoan.*success\)",
                r"require\(.*borrow.*amount.*>.*0\)"
            ]
        }

    def _initialize_governance_patterns(self) -> Dict[str, List[str]]:
        """Initialize governance-specific patterns."""
        return {
            "proposal": [
                r"propose\(|createProposal\(",
                r"proposalId|proposalHash"
            ],
            "voting": [
                r"vote\(|castVote\(",
                r"votingPower|voteWeight"
            ],
            "execution": [
                r"execute\(|executeProposal\(",
                r"executionDelay|timelock"
            ]
        }

    def analyze_contract(self, contract_path: str, content: str) -> List[DeFiVulnerability]:
        """Analyze contract for DeFi-specific vulnerabilities."""
        vulnerabilities = []
        lines = content.split('\n')
        
        # Analyze each vulnerability type (two-stage detection)
        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info["pattern"]
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)

                for match in regex.finditer(content):
                    line_number = content[:match.start()].count('\n') + 1

                    # Stage 2: Check for required protections
                    required_protections = pattern_info.get("required_protections", [])
                    min_required = pattern_info.get("min_protections_required", 1)

                    protections_found = 0
                    protections_present = []
                    for protection_pattern in required_protections:
                        if re.search(protection_pattern, content, re.IGNORECASE):
                            protections_found += 1
                            protections_present.append(protection_pattern)

                    # Skip if sufficient protections are present
                    if protections_found >= min_required:
                        continue

                    # Extract code snippet with context
                    start_line = max(0, line_number - 3)
                    end_line = min(len(lines), line_number + 3)
                    code_snippet = '\n'.join(lines[start_line:end_line])

                    # Adjust confidence based on how many protections are missing
                    missing_count = len(required_protections) - protections_found
                    confidence_boost = min(0.2, missing_count * 0.1)
                    adjusted_confidence = min(1.0, pattern_info["confidence"] + confidence_boost)

                    vulnerability = DeFiVulnerability(
                        vuln_type=VulnerabilityType(vuln_type),
                        severity=pattern_info["severity"],
                        confidence=adjusted_confidence,
                        line_number=line_number,
                        description=pattern_info["description"],
                        code_snippet=code_snippet,
                        attack_vector=pattern_info["attack_vector"],
                        financial_impact=pattern_info["financial_impact"],
                        exploit_complexity=pattern_info["exploit_complexity"],
                        immunefi_bounty_potential=pattern_info["immunefi_bounty_potential"],
                        poc_suggestion=pattern_info["poc_suggestion"],
                        fix_suggestion=pattern_info["fix_suggestion"],
                        context={
                            "pattern_match": match.group(),
                            "contract_path": contract_path,
                            "vulnerability_type": vuln_type,
                            "protections_found": protections_present,
                            "protections_missing": [p for p in required_protections if p not in protections_present],
                        }
                    )

                    # Apply additional validation
                    if self._validate_defi_vulnerability(vulnerability, content):
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    def _validate_defi_vulnerability(self, vulnerability: DeFiVulnerability, content: str) -> bool:
        """Validate DeFi vulnerability with additional context checks."""
        
        # Check for mitigation patterns
        mitigation_patterns = {
            "oracle_manipulation": [
                r"circuitBreaker|emergencyStop",
                r"priceValidation|priceCheck",
                r"timestamp.*validation|freshness.*check"
            ],
            "flash_loan_attack": [
                r"flashLoan.*protection|antiFlashLoan",
                r"reentrancyGuard|nonReentrant",
                r"flashLoan.*validation"
            ],
            "liquidation_manipulation": [
                r"liquidation.*protection|antiLiquidation",
                r"healthFactor.*validation",
                r"liquidation.*threshold"
            ],
            "governance_attack": [
                r"governance.*protection|antiGovernance",
                r"timelock|executionDelay",
                r"quorum.*validation"
            ]
        }
        
        vuln_type = vulnerability.vuln_type.value
        if vuln_type in mitigation_patterns:
            for pattern in mitigation_patterns[vuln_type]:
                if re.search(pattern, content, re.IGNORECASE):
                    # Mitigation found, reduce confidence
                    vulnerability.confidence *= 0.5
                    vulnerability.context["mitigation_found"] = pattern
        
        # Only report vulnerabilities with sufficient confidence
        return vulnerability.confidence > 0.6

    def generate_poc_suggestion(self, vulnerability: DeFiVulnerability) -> str:
        """Generate proof-of-concept suggestion for vulnerability."""
        
        poc_templates = {
            "oracle_manipulation": """
// Oracle Manipulation PoC
contract OracleAttack {
    function exploitOracle() external {
        // 1. Manipulate oracle price
        // 2. Execute trade at manipulated price
        // 3. Profit from price difference
    }
}
            """,
            "flash_loan_attack": """
// Flash Loan Attack PoC
contract FlashLoanAttack {
    function exploitFlashLoan() external {
        // 1. Initiate flash loan
        // 2. Manipulate protocol state
        // 3. Execute profitable trade
        // 4. Repay flash loan
        // 5. Keep profit
    }
}
            """,
            "liquidation_manipulation": """
// Liquidation Manipulation PoC
contract LiquidationAttack {
    function exploitLiquidation() external {
        // 1. Manipulate health factor
        // 2. Trigger unfair liquidation
        // 3. Profit from liquidation
    }
}
            """,
            "governance_attack": """
// Governance Attack PoC
contract GovernanceAttack {
    function exploitGovernance() external {
        // 1. Manipulate voting power
        // 2. Execute malicious proposal
        // 3. Take control of protocol
    }
}
            """
        }
        
        vuln_type = vulnerability.vuln_type.value
        return poc_templates.get(vuln_type, "// PoC template not available")

    def get_immunefi_bounty_estimate(self, vulnerability: DeFiVulnerability) -> str:
        """Estimate Immunefi bounty potential for vulnerability."""
        
        bounty_ranges = {
            "critical": "$50,000 - $2,000,000",
            "high": "$10,000 - $250,000", 
            "medium": "$1,000 - $50,000",
            "low": "$500 - $5,000"
        }
        
        return bounty_ranges.get(vulnerability.severity, "Unknown")

    def analyze_oracle_dependencies(self, content: str) -> List[Dict[str, Any]]:
        """Analyze oracle dependencies and potential manipulation vectors."""
        oracle_issues = []
        
        # Check for direct oracle calls without validation
        direct_calls = re.findall(r'(\w+)\.latestRoundData\(\)|(\w+)\.getPrice\(\)', content)
        for match in direct_calls:
            oracle_issues.append({
                "type": "direct_oracle_call",
                "severity": "high",
                "description": f"Direct oracle call: {match[0] or match[1]}",
                "recommendation": "Add price validation and circuit breakers"
            })
        
        # Check for stale price usage
        stale_patterns = [
            r'price.*=.*oracle\.getPrice\(\)',
            r'price.*=.*feed\.latestRoundData\(\)'
        ]
        
        for pattern in stale_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                oracle_issues.append({
                    "type": "stale_price_usage",
                    "severity": "medium",
                    "description": "Potential stale price usage",
                    "recommendation": "Add timestamp validation"
                })
        
        return oracle_issues

    def analyze_flash_loan_risks(self, content: str) -> List[Dict[str, Any]]:
        """Analyze flash loan risks and attack vectors."""
        flash_loan_issues = []
        
        # Check for flash loan initiation
        if re.search(r'flashLoan\(|borrow\(.*amount.*\)', content, re.IGNORECASE):
            flash_loan_issues.append({
                "type": "flash_loan_detected",
                "severity": "critical",
                "description": "Flash loan functionality detected",
                "recommendation": "Implement flash loan protection mechanisms"
            })
        
        # Check for flash loan callbacks
        if re.search(r'receiveFlashLoan\(|onFlashLoan\(', content, re.IGNORECASE):
            flash_loan_issues.append({
                "type": "flash_loan_callback",
                "severity": "high",
                "description": "Flash loan callback function detected",
                "recommendation": "Validate flash loan callbacks and implement reentrancy protection"
            })
        
        return flash_loan_issues

    def generate_comprehensive_report(self, vulnerabilities: List[DeFiVulnerability]) -> Dict[str, Any]:
        """Generate comprehensive DeFi vulnerability report."""
        
        report = {
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len([v for v in vulnerabilities if v.severity == "critical"]),
                "high_count": len([v for v in vulnerabilities if v.severity == "high"]),
                "medium_count": len([v for v in vulnerabilities if v.severity == "medium"]),
                "low_count": len([v for v in vulnerabilities if v.severity == "low"])
            },
            "vulnerabilities": [],
            "recommendations": [],
            "bounty_potential": {
                "estimated_total": "$0",
                "breakdown": {}
            }
        }
        
        # Process vulnerabilities
        for vuln in vulnerabilities:
            vuln_data = {
                "type": vuln.vuln_type.value,
                "severity": vuln.severity,
                "confidence": vuln.confidence,
                "line_number": vuln.line_number,
                "description": vuln.description,
                "attack_vector": vuln.attack_vector,
                "financial_impact": vuln.financial_impact,
                "exploit_complexity": vuln.exploit_complexity,
                "immunefi_bounty_potential": vuln.immunefi_bounty_potential,
                "poc_suggestion": vuln.poc_suggestion,
                "fix_suggestion": vuln.fix_suggestion,
                "code_snippet": vuln.code_snippet
            }
            report["vulnerabilities"].append(vuln_data)
        
        # Generate recommendations
        unique_fixes = set(v.fix_suggestion for v in vulnerabilities)
        report["recommendations"] = list(unique_fixes)
        
        # Calculate bounty potential
        bounty_total = 0
        for vuln in vulnerabilities:
            bounty_range = vuln.immunefi_bounty_potential
            # Extract minimum bounty value
            min_bounty = re.search(r'\$([0-9,]+)', bounty_range)
            if min_bounty:
                min_value = int(min_bounty.group(1).replace(',', ''))
                bounty_total += min_value
        
        report["bounty_potential"]["estimated_total"] = f"${bounty_total:,}"
        
        return report
