#!/usr/bin/env python3
"""
DeFi-Specific Vulnerability Detector

Specialized detector for DeFi protocol vulnerabilities including:
- Oracle manipulation attacks
- Flash loan exploits
- Liquidation logic vulnerabilities
- Governance attacks
- MEV extraction patterns
"""

import re
import json
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum


class VulnerabilityType(Enum):
    ORACLE_MANIPULATION = "oracle_manipulation"
    FLASH_LOAN_ATTACK = "flash_loan_attack"
    LIQUIDATION_MANIPULATION = "liquidation_manipulation"
    GOVERNANCE_ATTACK = "governance_attack"
    MEV_EXTRACTION = "mev_extraction"
    REENTRANCY = "reentrancy"
    ACCESS_CONTROL = "access_control"
    ARITHMETIC_ERROR = "arithmetic_error"


@dataclass
class DeFiVulnerability:
    """DeFi-specific vulnerability representation."""
    vuln_type: VulnerabilityType
    severity: str
    confidence: float
    line_number: int
    description: str
    code_snippet: str
    attack_vector: str
    financial_impact: str
    exploit_complexity: str
    immunefi_bounty_potential: str
    poc_suggestion: str
    fix_suggestion: str
    context: Dict[str, Any]


class DeFiVulnerabilityDetector:
    """Advanced DeFi vulnerability detector with specialized patterns."""

    def __init__(self):
        self.patterns = self._initialize_defi_patterns()
        self.oracle_patterns = self._initialize_oracle_patterns()
        self.flash_loan_patterns = self._initialize_flash_loan_patterns()
        self.governance_patterns = self._initialize_governance_patterns()

    def _initialize_defi_patterns(self) -> Dict[str, List[Dict[str, Any]]]:
        """Initialize DeFi-specific vulnerability patterns."""
        return {
            "oracle_manipulation": [
                {
                    "pattern": r"latestRoundData\(\)|getPrice\(\)|getLatestPrice\(\)",
                    "severity": "high",
                    "confidence": 0.8,
                    "description": "Direct oracle price access without validation",
                    "attack_vector": "Price manipulation via oracle dependency",
                    "financial_impact": "High - Can lead to incorrect pricing",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate price manipulation attack",
                    "fix_suggestion": "Add price validation and circuit breakers"
                },
                {
                    "pattern": r"require\(.*price.*>.*0\)",
                    "severity": "medium",
                    "confidence": 0.6,
                    "description": "Basic price validation only",
                    "attack_vector": "Stale price exploitation",
                    "financial_impact": "Medium - Stale price attacks",
                    "exploit_complexity": "Low",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Show stale price attack",
                    "fix_suggestion": "Add timestamp validation"
                }
            ],
            "flash_loan_attack": [
                {
                    "pattern": r"flashLoan\(|borrow\(.*amount.*\)",
                    "severity": "critical",
                    "confidence": 0.9,
                    "description": "Flash loan functionality detected",
                    "attack_vector": "Flash loan manipulation attack",
                    "financial_impact": "Critical - Can drain protocol",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$50,000-$2,000,000",
                    "poc_suggestion": "Demonstrate flash loan exploit",
                    "fix_suggestion": "Add flash loan protection mechanisms"
                },
                {
                    "pattern": r"receiveFlashLoan\(|onFlashLoan\(",
                    "severity": "high",
                    "confidence": 0.8,
                    "description": "Flash loan callback function",
                    "attack_vector": "Callback manipulation",
                    "financial_impact": "High - Callback exploitation",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Show callback manipulation",
                    "fix_suggestion": "Validate flash loan callbacks"
                }
            ],
            "liquidation_manipulation": [
                {
                    "pattern": r"liquidate\(|liquidationCall\(",
                    "severity": "high",
                    "confidence": 0.8,
                    "description": "Liquidation function detected",
                    "attack_vector": "Liquidation manipulation",
                    "financial_impact": "High - Unfair liquidations",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate liquidation manipulation",
                    "fix_suggestion": "Add liquidation protection"
                },
                {
                    "pattern": r"healthFactor.*<.*1",
                    "severity": "medium",
                    "confidence": 0.7,
                    "description": "Health factor check",
                    "attack_vector": "Health factor manipulation",
                    "financial_impact": "Medium - Liquidation timing",
                    "exploit_complexity": "Low",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Show health factor attack",
                    "fix_suggestion": "Add health factor validation"
                }
            ],
            "governance_attack": [
                {
                    "pattern": r"propose\(|execute\(|vote\(",
                    "severity": "high",
                    "confidence": 0.8,
                    "description": "Governance function detected",
                    "attack_vector": "Governance manipulation",
                    "financial_impact": "High - Protocol control",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$10,000-$250,000",
                    "poc_suggestion": "Demonstrate governance attack",
                    "fix_suggestion": "Add governance protection"
                },
                {
                    "pattern": r"quorum|majority|threshold",
                    "severity": "medium",
                    "confidence": 0.6,
                    "description": "Governance threshold logic",
                    "attack_vector": "Threshold manipulation",
                    "financial_impact": "Medium - Voting manipulation",
                    "exploit_complexity": "Medium",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Show threshold attack",
                    "fix_suggestion": "Validate governance thresholds"
                }
            ],
            "mev_extraction": [
                {
                    "pattern": r"swap\(|exchange\(|trade\(",
                    "severity": "medium",
                    "confidence": 0.7,
                    "description": "Trading function detected",
                    "attack_vector": "MEV extraction",
                    "financial_impact": "Medium - MEV extraction",
                    "exploit_complexity": "High",
                    "immunefi_bounty_potential": "$1,000-$50,000",
                    "poc_suggestion": "Demonstrate MEV attack",
                    "fix_suggestion": "Add MEV protection"
                },
                {
                    "pattern": r"slippage|priceImpact",
                    "severity": "low",
                    "confidence": 0.5,
                    "description": "Slippage protection",
                    "attack_vector": "Slippage manipulation",
                    "financial_impact": "Low - Slippage attacks",
                    "exploit_complexity": "Low",
                    "immunefi_bounty_potential": "$500-$5,000",
                    "poc_suggestion": "Show slippage attack",
                    "fix_suggestion": "Improve slippage protection"
                }
            ]
        }

    def _initialize_oracle_patterns(self) -> Dict[str, List[str]]:
        """Initialize oracle-specific patterns."""
        return {
            "price_feeds": [
                r"Chainlink|PriceFeed|AggregatorV3",
                r"latestRoundData|getRoundData",
                r"decimals\(\)|description\(\)"
            ],
            "validation": [
                r"require\(.*price.*>.*0\)",
                r"require\(.*timestamp.*>.*0\)",
                r"require\(.*roundId.*>.*0\)"
            ],
            "manipulation": [
                r"price.*=.*oracle\.getPrice\(\)",
                r"price.*=.*feed\.latestRoundData\(\)",
                r"price.*=.*aggregator\.latestAnswer\(\)"
            ]
        }

    def _initialize_flash_loan_patterns(self) -> Dict[str, List[str]]:
        """Initialize flash loan specific patterns."""
        return {
            "initiation": [
                r"flashLoan\(|borrow\(.*amount.*\)",
                r"initiateFlashLoan|startFlashLoan"
            ],
            "callback": [
                r"receiveFlashLoan\(|onFlashLoan\(",
                r"flashLoanCallback|flashLoanReceiver"
            ],
            "validation": [
                r"require\(.*flashLoan.*success\)",
                r"require\(.*borrow.*amount.*>.*0\)"
            ]
        }

    def _initialize_governance_patterns(self) -> Dict[str, List[str]]:
        """Initialize governance-specific patterns."""
        return {
            "proposal": [
                r"propose\(|createProposal\(",
                r"proposalId|proposalHash"
            ],
            "voting": [
                r"vote\(|castVote\(",
                r"votingPower|voteWeight"
            ],
            "execution": [
                r"execute\(|executeProposal\(",
                r"executionDelay|timelock"
            ]
        }

    def analyze_contract(self, contract_path: str, content: str) -> List[DeFiVulnerability]:
        """Analyze contract for DeFi-specific vulnerabilities."""
        vulnerabilities = []
        lines = content.split('\n')
        
        # Analyze each vulnerability type
        for vuln_type, patterns in self.patterns.items():
            for pattern_info in patterns:
                pattern = pattern_info["pattern"]
                regex = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                
                for match in regex.finditer(content):
                    line_number = content[:match.start()].count('\n') + 1
                    
                    # Extract code snippet with context
                    start_line = max(0, line_number - 3)
                    end_line = min(len(lines), line_number + 3)
                    code_snippet = '\n'.join(lines[start_line:end_line])
                    
                    vulnerability = DeFiVulnerability(
                        vuln_type=VulnerabilityType(vuln_type),
                        severity=pattern_info["severity"],
                        confidence=pattern_info["confidence"],
                        line_number=line_number,
                        description=pattern_info["description"],
                        code_snippet=code_snippet,
                        attack_vector=pattern_info["attack_vector"],
                        financial_impact=pattern_info["financial_impact"],
                        exploit_complexity=pattern_info["exploit_complexity"],
                        immunefi_bounty_potential=pattern_info["immunefi_bounty_potential"],
                        poc_suggestion=pattern_info["poc_suggestion"],
                        fix_suggestion=pattern_info["fix_suggestion"],
                        context={
                            "pattern_match": match.group(),
                            "contract_path": contract_path,
                            "vulnerability_type": vuln_type
                        }
                    )
                    
                    # Apply additional validation
                    if self._validate_defi_vulnerability(vulnerability, content):
                        vulnerabilities.append(vulnerability)
        
        return vulnerabilities

    def _validate_defi_vulnerability(self, vulnerability: DeFiVulnerability, content: str) -> bool:
        """Validate DeFi vulnerability with additional context checks."""
        
        # Check for mitigation patterns
        mitigation_patterns = {
            "oracle_manipulation": [
                r"circuitBreaker|emergencyStop",
                r"priceValidation|priceCheck",
                r"timestamp.*validation|freshness.*check"
            ],
            "flash_loan_attack": [
                r"flashLoan.*protection|antiFlashLoan",
                r"reentrancyGuard|nonReentrant",
                r"flashLoan.*validation"
            ],
            "liquidation_manipulation": [
                r"liquidation.*protection|antiLiquidation",
                r"healthFactor.*validation",
                r"liquidation.*threshold"
            ],
            "governance_attack": [
                r"governance.*protection|antiGovernance",
                r"timelock|executionDelay",
                r"quorum.*validation"
            ]
        }
        
        vuln_type = vulnerability.vuln_type.value
        if vuln_type in mitigation_patterns:
            for pattern in mitigation_patterns[vuln_type]:
                if re.search(pattern, content, re.IGNORECASE):
                    # Mitigation found, reduce confidence
                    vulnerability.confidence *= 0.5
                    vulnerability.context["mitigation_found"] = pattern
        
        # Only report vulnerabilities with sufficient confidence
        return vulnerability.confidence > 0.3

    def generate_poc_suggestion(self, vulnerability: DeFiVulnerability) -> str:
        """Generate proof-of-concept suggestion for vulnerability."""
        
        poc_templates = {
            "oracle_manipulation": """
// Oracle Manipulation PoC
contract OracleAttack {
    function exploitOracle() external {
        // 1. Manipulate oracle price
        // 2. Execute trade at manipulated price
        // 3. Profit from price difference
    }
}
            """,
            "flash_loan_attack": """
// Flash Loan Attack PoC
contract FlashLoanAttack {
    function exploitFlashLoan() external {
        // 1. Initiate flash loan
        // 2. Manipulate protocol state
        // 3. Execute profitable trade
        // 4. Repay flash loan
        // 5. Keep profit
    }
}
            """,
            "liquidation_manipulation": """
// Liquidation Manipulation PoC
contract LiquidationAttack {
    function exploitLiquidation() external {
        // 1. Manipulate health factor
        // 2. Trigger unfair liquidation
        // 3. Profit from liquidation
    }
}
            """,
            "governance_attack": """
// Governance Attack PoC
contract GovernanceAttack {
    function exploitGovernance() external {
        // 1. Manipulate voting power
        // 2. Execute malicious proposal
        // 3. Take control of protocol
    }
}
            """
        }
        
        vuln_type = vulnerability.vuln_type.value
        return poc_templates.get(vuln_type, "// PoC template not available")

    def get_immunefi_bounty_estimate(self, vulnerability: DeFiVulnerability) -> str:
        """Estimate Immunefi bounty potential for vulnerability."""
        
        bounty_ranges = {
            "critical": "$50,000 - $2,000,000",
            "high": "$10,000 - $250,000", 
            "medium": "$1,000 - $50,000",
            "low": "$500 - $5,000"
        }
        
        return bounty_ranges.get(vulnerability.severity, "Unknown")

    def analyze_oracle_dependencies(self, content: str) -> List[Dict[str, Any]]:
        """Analyze oracle dependencies and potential manipulation vectors."""
        oracle_issues = []
        
        # Check for direct oracle calls without validation
        direct_calls = re.findall(r'(\w+)\.latestRoundData\(\)|(\w+)\.getPrice\(\)', content)
        for match in direct_calls:
            oracle_issues.append({
                "type": "direct_oracle_call",
                "severity": "high",
                "description": f"Direct oracle call: {match[0] or match[1]}",
                "recommendation": "Add price validation and circuit breakers"
            })
        
        # Check for stale price usage
        stale_patterns = [
            r'price.*=.*oracle\.getPrice\(\)',
            r'price.*=.*feed\.latestRoundData\(\)'
        ]
        
        for pattern in stale_patterns:
            if re.search(pattern, content, re.IGNORECASE):
                oracle_issues.append({
                    "type": "stale_price_usage",
                    "severity": "medium",
                    "description": "Potential stale price usage",
                    "recommendation": "Add timestamp validation"
                })
        
        return oracle_issues

    def analyze_flash_loan_risks(self, content: str) -> List[Dict[str, Any]]:
        """Analyze flash loan risks and attack vectors."""
        flash_loan_issues = []
        
        # Check for flash loan initiation
        if re.search(r'flashLoan\(|borrow\(.*amount.*\)', content, re.IGNORECASE):
            flash_loan_issues.append({
                "type": "flash_loan_detected",
                "severity": "critical",
                "description": "Flash loan functionality detected",
                "recommendation": "Implement flash loan protection mechanisms"
            })
        
        # Check for flash loan callbacks
        if re.search(r'receiveFlashLoan\(|onFlashLoan\(', content, re.IGNORECASE):
            flash_loan_issues.append({
                "type": "flash_loan_callback",
                "severity": "high",
                "description": "Flash loan callback function detected",
                "recommendation": "Validate flash loan callbacks and implement reentrancy protection"
            })
        
        return flash_loan_issues

    def generate_comprehensive_report(self, vulnerabilities: List[DeFiVulnerability]) -> Dict[str, Any]:
        """Generate comprehensive DeFi vulnerability report."""
        
        report = {
            "summary": {
                "total_vulnerabilities": len(vulnerabilities),
                "critical_count": len([v for v in vulnerabilities if v.severity == "critical"]),
                "high_count": len([v for v in vulnerabilities if v.severity == "high"]),
                "medium_count": len([v for v in vulnerabilities if v.severity == "medium"]),
                "low_count": len([v for v in vulnerabilities if v.severity == "low"])
            },
            "vulnerabilities": [],
            "recommendations": [],
            "bounty_potential": {
                "estimated_total": "$0",
                "breakdown": {}
            }
        }
        
        # Process vulnerabilities
        for vuln in vulnerabilities:
            vuln_data = {
                "type": vuln.vuln_type.value,
                "severity": vuln.severity,
                "confidence": vuln.confidence,
                "line_number": vuln.line_number,
                "description": vuln.description,
                "attack_vector": vuln.attack_vector,
                "financial_impact": vuln.financial_impact,
                "exploit_complexity": vuln.exploit_complexity,
                "immunefi_bounty_potential": vuln.immunefi_bounty_potential,
                "poc_suggestion": vuln.poc_suggestion,
                "fix_suggestion": vuln.fix_suggestion,
                "code_snippet": vuln.code_snippet
            }
            report["vulnerabilities"].append(vuln_data)
        
        # Generate recommendations
        unique_fixes = set(v.fix_suggestion for v in vulnerabilities)
        report["recommendations"] = list(unique_fixes)
        
        # Calculate bounty potential
        bounty_total = 0
        for vuln in vulnerabilities:
            bounty_range = vuln.immunefi_bounty_potential
            # Extract minimum bounty value
            min_bounty = re.search(r'\$([0-9,]+)', bounty_range)
            if min_bounty:
                min_value = int(min_bounty.group(1).replace(',', ''))
                bounty_total += min_value
        
        report["bounty_potential"]["estimated_total"] = f"${bounty_total:,}"
        
        return report
