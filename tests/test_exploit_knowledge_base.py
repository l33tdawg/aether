"""Tests for the exploit knowledge base."""

import unittest
from core.exploit_knowledge_base import (
    ExploitKnowledgeBase,
    ExploitPattern,
    ExploitCategory,
)
from core.protocol_archetypes import ProtocolArchetype


class TestExploitKnowledgeBase(unittest.TestCase):
    """Test the exploit knowledge base."""

    def setUp(self):
        self.kb = ExploitKnowledgeBase()

    def test_has_50_plus_patterns(self):
        self.assertGreaterEqual(len(self.kb.all_patterns), 50)

    def test_all_categories_represented(self):
        categories = {p.category for p in self.kb.all_patterns}
        for cat in ExploitCategory:
            self.assertIn(cat, categories, f"Missing category: {cat.value}")

    def test_get_by_id(self):
        pattern = self.kb.get_by_id("INF-001")
        self.assertIsNotNone(pattern)
        self.assertEqual(pattern.name, "ERC-4626 First Depositor Inflation")
        self.assertEqual(pattern.severity, "critical")

    def test_get_by_id_nonexistent(self):
        self.assertIsNone(self.kb.get_by_id("NONEXISTENT-999"))

    def test_get_by_category(self):
        reentrancy = self.kb.get_by_category(ExploitCategory.REENTRANCY)
        self.assertGreaterEqual(len(reentrancy), 5)
        for p in reentrancy:
            self.assertEqual(p.category, ExploitCategory.REENTRANCY)

    def test_get_for_archetype_vault(self):
        vault_patterns = self.kb.get_for_archetype(ProtocolArchetype.VAULT_ERC4626)
        self.assertGreater(len(vault_patterns), 5)
        # Should include inflation attacks
        ids = [p.id for p in vault_patterns]
        self.assertIn("INF-001", ids)

    def test_get_for_archetype_bridge(self):
        bridge_patterns = self.kb.get_for_archetype(ProtocolArchetype.BRIDGE)
        self.assertGreater(len(bridge_patterns), 3)
        ids = [p.id for p in bridge_patterns]
        self.assertIn("BRG-001", ids)

    def test_get_for_archetypes_multiple(self):
        patterns = self.kb.get_for_archetypes([
            ProtocolArchetype.VAULT_ERC4626,
            ProtocolArchetype.LENDING_POOL,
        ])
        # Should be more than just vault patterns
        vault_only = self.kb.get_for_archetype(ProtocolArchetype.VAULT_ERC4626)
        self.assertGreaterEqual(len(patterns), len(vault_only))

    def test_get_critical_patterns(self):
        critical = self.kb.get_critical_patterns()
        self.assertGreater(len(critical), 10)
        for p in critical:
            self.assertEqual(p.severity, "critical")

    def test_search(self):
        results = self.kb.search("flash loan")
        self.assertGreater(len(results), 0)
        # Should find flash loan related patterns
        self.assertTrue(any("flash" in p.name.lower() for p in results))

    def test_search_case_insensitive(self):
        results1 = self.kb.search("REENTRANCY")
        results2 = self.kb.search("reentrancy")
        self.assertEqual(len(results1), len(results2))

    def test_format_for_prompt(self):
        text = self.kb.format_for_prompt()
        self.assertIn("Known Exploit Patterns", text)
        self.assertIn("CRITICAL", text)
        self.assertIn("Code indicators", text)

    def test_format_for_prompt_limited(self):
        text = self.kb.format_for_prompt(max_patterns=5)
        # Should have exactly 5 pattern headers
        pattern_count = text.count("### ")
        self.assertEqual(pattern_count, 5)

    def test_format_for_focus_areas(self):
        text = self.kb.format_for_focus_areas(['reentrancy'])
        self.assertIn("Known Exploit Patterns", text)
        # Should contain reentrancy patterns
        self.assertTrue(
            'reentrancy' in text.lower() or 'RE-' in text,
            "Expected reentrancy patterns in output"
        )

    def test_format_for_focus_areas_empty(self):
        text = self.kb.format_for_focus_areas([])
        # Should return all patterns
        self.assertIn("Known Exploit Patterns", text)

    def test_format_for_focus_areas_unknown(self):
        text = self.kb.format_for_focus_areas(['nonexistent_area'])
        # Should return all patterns as fallback
        self.assertIn("Known Exploit Patterns", text)

    def test_pattern_fields_complete(self):
        """Every pattern should have all required fields populated."""
        for p in self.kb.all_patterns:
            self.assertTrue(p.id, f"Pattern missing id")
            self.assertTrue(p.name, f"Pattern {p.id} missing name")
            self.assertTrue(p.description, f"Pattern {p.id} missing description")
            self.assertTrue(p.code_indicators, f"Pattern {p.id} missing code_indicators")
            self.assertTrue(p.missing_protections, f"Pattern {p.id} missing missing_protections")
            self.assertTrue(p.exploit_mechanism, f"Pattern {p.id} missing exploit_mechanism")
            self.assertTrue(p.real_world_examples, f"Pattern {p.id} missing real_world_examples")
            self.assertTrue(p.applicable_archetypes, f"Pattern {p.id} missing applicable_archetypes")
            self.assertTrue(p.detection_prompt, f"Pattern {p.id} missing detection_prompt")
            self.assertIn(p.severity, ['critical', 'high', 'medium'])

    def test_pattern_ids_unique(self):
        ids = [p.id for p in self.kb.all_patterns]
        self.assertEqual(len(ids), len(set(ids)), "Duplicate pattern IDs found")


class TestExploitCategory(unittest.TestCase):
    """Test ExploitCategory enum."""

    def test_all_categories(self):
        expected = [
            'inflation_share', 'reentrancy', 'oracle', 'governance',
            'bridge', 'precision_rounding', 'access_control', 'economic_defi', 'logic',
        ]
        for val in expected:
            found = any(c.value == val for c in ExploitCategory)
            self.assertTrue(found, f"Missing category value: {val}")


if __name__ == '__main__':
    unittest.main()
