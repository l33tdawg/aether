#!/usr/bin/env python3
"""
Integration tests for Enhanced Vulnerability Detector with new Foundry and Security recognizers
"""

import unittest
from unittest.mock import patch, MagicMock
from core.enhanced_vulnerability_detector import EnhancedVulnerabilityDetector


class TestEnhancedVulnerabilityDetectorIntegration(unittest.TestCase):
    """Test integration of new recognizers into Enhanced Vulnerability Detector."""

    def setUp(self):
        """Set up test fixtures."""
        self.detector = EnhancedVulnerabilityDetector()

    def test_foundry_script_filtering(self):
        """Test that Foundry scripts are properly filtered."""
        foundry_script = """
pragma solidity ^0.8.0;

import {Script} from "forge-std/Script.sol";

contract DeployScript is Script {
    function run() external {
        uint256 snapshot = vm.snapshot();
        vm.prank(deployerAddress());
        (bool success,) = target.call(data);
        require(success, "Call failed");
        vm.revertTo(snapshot);
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(foundry_script, "contracts/script/Deploy.s.sol")

        # Should filter out reentrancy false positive
        reentrancy_vulns = [v for v in vulnerabilities if 'reentrancy' in v.vulnerability_type.lower()]
        self.assertEqual(len(reentrancy_vulns), 0, "Foundry script external calls should be filtered")

    def test_security_pattern_filtering(self):
        """Test that legitimate security patterns are filtered."""
        risc0_contract = """
pragma solidity ^0.8.0;

contract RiscZeroVerifierEmergencyStop {
    function estop() external onlyOwner {
        _pause();
    }

    function estop(bytes calldata receipt) external {
        if (receipt.claimDigest != bytes32(0)) {
            revert InvalidProofOfExploit();
        }
        verifyIntegrity(receipt);
        _pause();
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(risc0_contract)

        # Should filter out access control false positives
        access_vulns = [v for v in vulnerabilities if 'access' in v.vulnerability_type.lower()]
        validation_vulns = [v for v in vulnerabilities if 'validation' in v.vulnerability_type.lower()]

        # These should be minimal or zero due to security pattern recognition
        print(f"Access vulns: {len(access_vulns)}, Validation vulns: {len(validation_vulns)}")

    def test_production_code_not_filtered(self):
        """Test that legitimate production vulnerabilities are not filtered."""
        vulnerable_contract = """
pragma solidity ^0.8.0;

contract Vulnerable {
    mapping(address => uint256) public balances;

    function withdraw(uint256 amount) public {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
    }

    function transfer(address to, uint256 amount) public {
        balances[msg.sender] -= amount;  // State change before external call
        (bool success,) = to.call(abi.encodeWithSignature("receiveTokens(uint256)", amount));
        if (!success) {
            balances[msg.sender] += amount;  // Attempted rollback
        }
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(vulnerable_contract)

        # Should still detect legitimate reentrancy
        reentrancy_vulns = [v for v in vulnerabilities if 'reentrancy' in v.vulnerability_type.lower()]
        self.assertGreater(len(reentrancy_vulns), 0, "Legitimate reentrancy should be detected")

    def test_mixed_patterns(self):
        """Test contracts with both Foundry and security patterns."""
        mixed_contract = """
pragma solidity ^0.8.0;

import {Test} from "forge-std/Test.sol";

contract EmergencyStopTest is Test {
    address target;

    function setUp() public {
        target = address(new EmergencyStop());
    }

    function testEmergencyStop() public {
        uint256 snapshot = vm.snapshot();

        // Test emergency stop
        vm.prank(owner);
        EmergencyStop(target).estop();

        vm.revertTo(snapshot);
    }
}

contract EmergencyStop {
    address public owner;

    modifier onlyOwner() {
        require(msg.sender == owner);
        _;
    }

    function estop() external onlyOwner {
        _pause();
    }

    function _pause() internal {
        // Pause logic
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(mixed_contract, "test/EmergencyStop.t.sol")

        # Should filter Foundry-related issues but still detect any real issues
        # The main point is that it doesn't crash and processes correctly
        self.assertIsInstance(vulnerabilities, list)

    def test_empty_and_edge_cases(self):
        """Test edge cases and empty inputs."""
        # Empty contract
        vulnerabilities = self.detector.analyze_contract("")
        self.assertEqual(len(vulnerabilities), 0)

        # Contract with only comments
        comment_only = """
// This is a comment
/* Multi-line
   comment */
pragma solidity ^0.8.0;
"""
        vulnerabilities = self.detector.analyze_contract(comment_only)
        self.assertIsInstance(vulnerabilities, list)

    def test_file_path_handling(self):
        """Test different file path scenarios."""
        contract_code = "contract Test {}"

        # Script file
        vulns_script = self.detector.analyze_contract(contract_code, "contracts/script/Deploy.s.sol")
        self.assertIsInstance(vulns_script, list)

        # Test file
        vulns_test = self.detector.analyze_contract(contract_code, "test/MyTest.t.sol")
        self.assertIsInstance(vulns_test, list)

        # Regular contract
        vulns_regular = self.detector.analyze_contract(contract_code, "contracts/MyContract.sol")
        self.assertIsInstance(vulns_regular, list)

    @patch('core.enhanced_vulnerability_detector.EnhancedVulnerabilityDetector._analyze_existing_patterns')
    @patch('core.enhanced_vulnerability_detector.EnhancedVulnerabilityDetector._analyze_with_new_detectors')
    def test_filtering_integration(self, mock_new_detectors, mock_existing_patterns):
        """Test that filtering logic integrates correctly."""
        # Mock the analysis methods to return controlled vulnerabilities
        mock_existing_patterns.return_value = [
            type('MockVuln', (), {
                'vulnerability_type': 'reentrancy',
                'line_number': 10,
                'severity': 'high',
                'confidence': 0.8,
                'description': 'External call after state change',
                'code_snippet': 'call()',
                'swc_id': 'SWC-107'
            })(),
            type('MockVuln', (), {
                'vulnerability_type': 'access_control',
                'line_number': 5,
                'severity': 'medium',
                'confidence': 0.7,
                'description': 'Missing access control',
                'code_snippet': 'function()',
                'swc_id': 'SWC-105'
            })()
        ]
        mock_new_detectors.return_value = []

        # Test with Foundry script - should filter reentrancy
        foundry_script = """
pragma solidity ^0.8.0;

contract TestScript {
    function test() public {
        uint256 snapshot = vm.snapshot();
        (bool success,) = addr.call(data);
        vm.revertTo(snapshot);
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(foundry_script)

        # Should have filtered the reentrancy vuln but kept access control
        vuln_types = [v.vulnerability_type for v in vulnerabilities]
        self.assertNotIn('reentrancy', vuln_types)
        self.assertIn('access_control', vuln_types)

    def test_performance(self):
        """Test that new recognizers don't significantly impact performance."""
        import time

        # Create a moderately complex contract
        contract_code = """
pragma solidity ^0.8.0;

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";

contract ComplexContract is Ownable {
    mapping(address => uint256) public balances;
    bool public paused;

    modifier whenNotPaused() {
        require(!paused, "Paused");
        _;
    }

    function deposit() public payable whenNotPaused {
        balances[msg.sender] += msg.value;
    }

    function withdraw(uint256 amount) public whenNotPaused {
        require(balances[msg.sender] >= amount);
        balances[msg.sender] -= amount;
        (bool success,) = msg.sender.call{value: amount}("");
        require(success);
    }

    function emergencyPause() external onlyOwner {
        paused = true;
    }

    function unpause() external onlyOwner {
        paused = false;
    }
}
"""

        start_time = time.time()
        vulnerabilities = self.detector.analyze_contract(contract_code)
        end_time = time.time()

        duration = end_time - start_time
        print(f"Analysis took {duration:.2f} seconds")

        # Should complete in reasonable time (< 5 seconds for this size)
        self.assertLess(duration, 5.0, "Analysis should complete in reasonable time")

        # Should still function correctly
        self.assertIsInstance(vulnerabilities, list)

    def test_backward_compatibility(self):
        """Test that existing functionality still works."""
        # Test that the detector can still analyze basic contracts
        basic_contract = """
pragma solidity ^0.8.0;

contract Basic {
    uint256 public value;

    function setValue(uint256 _value) public {
        value = _value;
    }
}
"""
        vulnerabilities = self.detector.analyze_contract(basic_contract)

        # Should not crash and return a list
        self.assertIsInstance(vulnerabilities, list)

        # Should not have false positives for basic contracts
        high_severity = [v for v in vulnerabilities if hasattr(v, 'severity') and v.severity == 'high']
        self.assertEqual(len(high_severity), 0, "Basic contract should not have high-severity vulnerabilities")


if __name__ == '__main__':
    unittest.main()
