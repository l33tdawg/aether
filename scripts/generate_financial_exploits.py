#!/usr/bin/env python3
"""
Generate Foundry PoCs for direct financial exploits using foundry_poc_generator.
Targets: MOROFT minting, DistributionV6 access control, L2TokenReceiverV2 fee theft.
"""

import sys
import os
import json
import asyncio
import logging
from pathlib import Path

# Add core to path
sys.path.insert(0, str(Path(__file__).parent.parent))

from core.foundry_poc_generator import FoundryPoCGenerator

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s [%(levelname)s] %(name)s: %(message)s'
)
logger = logging.getLogger(__name__)


async def main():
    """Main orchestration for generating exploit PoCs."""
    
    project_root = Path(__file__).parent.parent
    findings_file = project_root / "exploit_findings.json"
    output_dir = project_root / "tests" / "exploits" / "generated"
    
    logger.info(f"Project root: {project_root}")
    logger.info(f"Findings file: {findings_file}")
    logger.info(f"Output dir: {output_dir}")
    
    # Ensure output directory exists
    os.makedirs(output_dir, exist_ok=True)
    
    # Verify findings file exists
    if not findings_file.exists():
        logger.error(f"Findings file not found: {findings_file}")
        sys.exit(1)
    
    # Initialize generator with fork configuration
    config = {
        'max_compile_attempts': 5,
        'max_runtime_attempts': 1,
        'enable_fork_run': False,  # We'll do fork testing manually
        'template_only': False,
        'min_severity': 'high',
    }
    
    generator = FoundryPoCGenerator(config=config)
    
    try:
        # Generate comprehensive PoC suite
        logger.info("Starting PoC generation for financial exploit targets...")
        
        # We need to process each finding individually
        with open(findings_file, 'r') as f:
            findings_data = json.load(f)
        
        vulnerabilities = findings_data['audit']['vulnerabilities']
        logger.info(f"Processing {len(vulnerabilities)} vulnerabilities")
        
        for vuln in vulnerabilities:
            contract_path = vuln['file_path']
            finding_id = vuln['id']
            contract_name = vuln['contract_name']
            
            if not os.path.exists(contract_path):
                logger.warning(f"Contract file not found: {contract_path}, skipping {finding_id}")
                continue
            
            logger.info(f"\n{'='*70}")
            logger.info(f"Generating PoC for {finding_id} ({contract_name})")
            logger.info(f"{'='*70}")
            
            finding_output_dir = str(output_dir / finding_id)
            os.makedirs(finding_output_dir, exist_ok=True)
            
            # Load contract source
            with open(contract_path, 'r') as f:
                contract_source = f.read()
            
            # Discover entrypoints for this finding
            entrypoints = generator.discover_entrypoints(contract_source, vuln['line'])
            
            if not entrypoints:
                logger.warning(f"No entrypoints found for {finding_id}")
                continue
            
            logger.info(f"Found {len(entrypoints)} entrypoints for {contract_name}")
            for ep in entrypoints[:3]:  # Show top 3
                logger.info(f"  - {ep.name}() [relevance: {ep.relevance_score:.2f}]")
            
            # Synthesize PoC
            logger.info(f"Synthesizing PoC for {finding_id}...")
            from core.foundry_poc_generator import NormalizedFinding, VulnerabilityClass
            
            # Create NormalizedFinding object
            finding = NormalizedFinding(
                id=finding_id,
                vulnerability_type=vuln['type'],
                vulnerability_class=VulnerabilityClass.ACCESS_CONTROL 
                    if vuln['type'] == 'access_control' 
                    else VulnerabilityClass.OVERFLOW_UNDERFLOW,
                severity=vuln['severity'],
                confidence=vuln['confidence'],
                description=vuln['description'],
                line_number=vuln['line'],
                swc_id="",
                file_path=contract_path,
                contract_name=contract_name,
                status="pending",
                validation_confidence=0.8,
                validation_reasoning="Target for financial exploit",
                models=["gpt-4o-mini"],
                abi_data=None
            )
            
            # Generate test
            test_result = await generator.synthesize_poc(
                finding=finding,
                contract_code=contract_source,
                entrypoints=entrypoints,
                output_dir=finding_output_dir
            )
            
            logger.info(f"Test generation completed")
            logger.info(f"  Compiled: {test_result.compiled}")
            logger.info(f"  Compile attempts: {test_result.attempts_compile}")
            
            if test_result.compile_errors:
                logger.warning(f"Compile errors:")
                for err in test_result.compile_errors[:3]:
                    logger.warning(f"    - {err[:100]}")
            
            # Attempt to compile and repair
            if not test_result.compiled:
                logger.info(f"Attempting iterative compilation fix for {finding_id}...")
                result = await generator._iterative_compilation_fix(test_result, finding_output_dir)
                
                if result['success']:
                    logger.info(f"✅ Compilation fix succeeded in {result['iterations']} iterations")
                    test_result.compiled = True
                else:
                    logger.warning(f"❌ Compilation fix failed after {result['iterations']} iterations")
            
            # Save test code to file
            test_file = Path(finding_output_dir) / f"{finding_id}.t.sol"
            with open(test_file, 'w') as f:
                f.write(test_result.test_code)
            logger.info(f"Test code saved to: {test_file}")
            
            # Save exploit code if generated
            if test_result.exploit_code:
                exploit_file = Path(finding_output_dir) / f"{finding_id}_exploit.sol"
                with open(exploit_file, 'w') as f:
                    f.write(test_result.exploit_code)
                logger.info(f"Exploit code saved to: {exploit_file}")
        
        logger.info(f"\n{'='*70}")
        logger.info("PoC generation completed!")
        logger.info(f"Output directory: {output_dir}")
        logger.info(f"{'='*70}")
        
    except Exception as e:
        logger.error(f"PoC generation failed: {e}", exc_info=True)
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())
